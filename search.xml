<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linear Regression</title>
      <link href="/Linear-Regression/"/>
      <url>/Linear-Regression/</url>
      
        <content type="html"><![CDATA[<p>别看线性回归算法原理简单，但其中也还有许多特殊的问题需要特别的手段处理。比如离群点就是一个特别的案例。<br>少数离群点会显著影响训练集的均值结果，对回归线的整体拟合度产生较大的影响，因此我们需要找出其中的离群点并去除它们。</p><a id="more"></a><p><strong>异常值点</strong>: 异常值是指数据中有异常表现的数据点。在一个回归模型中，异常值点包括离群点，高杠杆值点和强影响点，这些点都可能对结果产生较大的负面影响，因此对异常值点的判断及修正对建立正确的回归模型非常重要。</p><p><strong>Outliers(离群点)</strong>: 离群点通常指残差非常大的点，即模型预测的y值与真实的y值相差非常大。通常检测离群点的方法有： 方法1：用箱线图判断，如果图中的点出现在四个分位数外的一般都是离群点。 方法2：用QQ图检测，落在置信区间外的点通常被认为是离群点。 方法3：通常认为标准化残差的绝对值大于2的点可能是离群点，也有资料说是大于3，可视情况而定 方法4：用car包的outlierTest()函数求得最大标准化残差绝对值Bonferroni调整后的p值，从而作出判断。 对离群点，我们一般会选择删除，删除离群点还有利于提高数据集对于正态分布假设的拟合度。</p><p><strong>Leverage(高杠杆值点)</strong>: 高杠杆值点指的是x值比较异常，通常与响应变量值y没有关系。 判断高杠杆值点的方法： 方法1： 杠杆点在简单线性回归中较容易辨别，一般找出预测值超出正常范围的观测点即杠杆点。 方法2： 计算点的帽子统计量，若该点的帽子统计量大于帽子统计量的均值的2或3倍，通常被认为是高杠杆值点。</p><p><strong>Influential(强影响点)</strong>: 即对模型参数估计值影响有些比例失衡的点。例如，若移除模型的一个观测点时，模型会发生巨大的改变。一般来说，高杠杆值点，若是离群点，则是强影响点。当然强影响点也不局限于此，强影响点是指对统计推断有影响的点，一般用cook距离进行判断，若cook距离的值大于4/(n-k-1),则表明是强影响点</p><h1 id="回归诊断"><a href="#回归诊断" class="headerlink" title="回归诊断"></a>回归诊断</h1><p>线性回归有诸多假设条件，对于残差来说，要求符合正态性、同方差、无自相关，因此残差诊断分析成为线性回归中必不可少一个环节。<br>假设：</p><ol><li>因变量是连续变量</li><li>自变量可以被定义为连续变量</li><li>因变量和自变量之间存在线性关系</li><li>具有相互独立的观测值</li><li>不存在显著的异常值</li><li>等方差性</li><li>回归残差近似正态分布</li></ol><p>残差图是指以某种残差为纵坐标，以其他适宜的变量为横坐标的散点图，所以残差图、残差散点图都是一个概念。这里横坐标有多种选择，最常见的选择是：1.因变量的拟合值；2. 某自变量的观察值等。</p><p>残差（residual）：</p><script type="math/tex; mode=display">e_{i} = Y_{i}-\hat{Y_{i}}</script><h4 id="高杠杆值点"><a href="#高杠杆值点" class="headerlink" title="高杠杆值点"></a>高杠杆值点</h4><p>高杠杆值点是与其他预测变量有关的离群点，即它们是由许多异常的预测变量组合起来的，与响应变量值没有关系。 高杠杆值的观测点可通过帽子矩阵的值（hat statistic）判断。对于一个给定的数据集，帽子均值为p/n，其中p是模型估计的参数数目（包含截距项），n是样本量。一般来说，若观测点的帽子值大于帽子均值的2或3倍，则可认定为高杠杆值点。</p><h4 id="离群点"><a href="#离群点" class="headerlink" title="离群点"></a>离群点</h4><p>指那些模型预测效果不佳的观测点，通常有很大的、或正或负的残差，正残差说明模型低估了响应值，负残差说明高佑了响应值。 <code>outlierTest()</code>函数是根据单个最大（或正或负）残差值的显著性来判断是否有离群点，若不显著，则说明数据集中没有离群点，若显著，则必须删除该离群点，然后再检验是否还有其他离群点存在。qqPlot图中落在置信区间带外的点可被认为时离群点，本例中未发现有离群点</p><h4 id="高杠杆值点-1"><a href="#高杠杆值点-1" class="headerlink" title="高杠杆值点"></a>高杠杆值点</h4><p>高杠杆值点是与其他预测变量有关的离群点，即它们是由许多异常的预测变量组合起来的，与响应变量值没有关系。 高杠杆值的观测点可通过帽子矩阵的值（hat statistic）判断。对于一个给定的数据集，帽子均值为p/n，其中p是模型估计的参数数目（包含截距项），n是样本量。一般来说，若观测点的帽子值大于帽子均值的2或3倍，则可认定为高杠杆值点。</p><h4 id="强影响点"><a href="#强影响点" class="headerlink" title="强影响点"></a>强影响点</h4><p>强影响点，即对模型参数估计值影响有些比例失衡的点。例如，当移除 模型的一个观测点时模型会发生巨大的改变，那么需要检测一下数据中是否存在强影响点。Cook距离，或称为D统计量。Cook’s D值大于4/(n-k-1)，则表明它是强影响点，其中n为样本量大小，k是预测变量数目（有助于鉴别强影响点，但并不提供关于这些点如何影响模型的信息），如下所示：</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="[http://rvdsd.top/2017/06/07/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-09%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/](http://rvdsd.top/2017/06/07/BioStatistics/生物统计-09线性回归/">线性回归笔记</a>)</li><li><a href="http://chenyuan.date/2017/11/Logistic-regression/" target="_blank" rel="noopener">Logistic regression</a></li><li><a href="https://bookdown.org/hezhijian/book/" target="_blank" rel="noopener">《数理统计讲义》</a></li><li>王斌会. 多元统计分析及R语言建模[M]. 暨南大学出版社, 2010.</li><li>汤银才. R语言与统计分析[M]. 高等教育出版社, 2008.</li><li>卡巴科弗. R语言实战[M]. 人民邮电出版社, 2016.</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CatBoost</title>
      <link href="/CatBoost/"/>
      <url>/CatBoost/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/XmpvNH97k1z6P9kYA36X_Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XmpvNH97k1z6P9kYA36X_Q</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用数据库连接池提升读写性能</title>
      <link href="/Connection-Pool/"/>
      <url>/Connection-Pool/</url>
      
        <content type="html"><![CDATA[<p>以我目前使用较多的Python语言编程为例，可以使用<code>PyMysql</code>来连接MySQL数据库并进行“query、insert、update”等操作，但是这样的方案你每次请求连接MySQL都会有一个单独的连接，这很浪费资源，特别是当请求的数量达到一定数量时会对MySQL的性能产生明显的影响。因此在实际使用中，数据库连接池技术通常被用来进行数据库连接中的资源复用。</p><h1 id="Solution：DBUtils"><a href="#Solution：DBUtils" class="headerlink" title="Solution：DBUtils"></a>Solution：DBUtils</h1><p>DBUtils是一个允许在非线程安全数据库接口周围使用线程安全包装器的Python数据库连接池工具包。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据库连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Cheat Sheet</title>
      <link href="/Docker-Cheat-Sheet/"/>
      <url>/Docker-Cheat-Sheet/</url>
      
        <content type="html"><![CDATA[<p>为什么要使用Docker：“有了Docker，开发人员能够借助任何工具、使用语言来构建任何应用”。Docker化的应用是完全绿色便携的，能运行在任何平台。</p><a id="more"></a><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><p>Linux：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></tbody></table></figure><p></p><p>OR</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot from 2019-09-20 22-12-42.png"></p><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><div class="table-container"><table><thead><tr><th>Docker语法</th><th>描述</th></tr></thead><tbody><tr><td>docker search  searchterm</td><td>Search Docker Hub for images.</td></tr><tr><td>docker pull user/image</td><td>Downloads an image from Docker Hub.</td></tr><tr><td>docker login</td><td>Authenticate to Docker Hub (or other Docker registry).</td></tr><tr><td>docker push user/image</td><td>Uploads an image to Docker Hub. You must be authenticated to run this command.</td></tr></tbody></table></div><h2 id="Image-and-Container-Information"><a href="#Image-and-Container-Information" class="headerlink" title="Image and Container Information"></a>Image and Container Information</h2><div class="table-container"><table><thead><tr><th>Docker语法</th><th>描述</th></tr></thead><tbody><tr><td>docker ps</td><td>List all running containers.</td></tr><tr><td>docker ps -a</td><td>List all container instances, with their ID and status.</td></tr><tr><td>docker history user/image</td><td>Lists the history of an image.</td></tr><tr><td>docker logs [container name or ID]</td><td>Displays the logs from a running container.</td></tr><tr><td>docker port [container name or ID]</td><td>Displays the exposed port of a running container.</td></tr><tr><td>docker diff [container name or ID]</td><td>Lists the changes made to a container.</td></tr></tbody></table></div><h2 id="Work-With-Images-and-Containers"><a href="#Work-With-Images-and-Containers" class="headerlink" title="Work With Images and Containers"></a>Work With Images and Containers</h2><div class="table-container"><table><thead><tr><th>Docker语法</th><th>描述</th></tr></thead><tbody><tr><td>docker run -it user/image</td><td>Runs an image, creating a container and changing the terminal to the terminal within the container.</td></tr><tr><td>docker run -p $HOSTPORT:$CONTAINERPORT -d user/image</td><td>Run an image in detached mode with port forwarding.</td></tr><tr><td>ctrl+p then ctrl+q</td><td>From within the container’s command prompt, detach and return to the host’s prompt.</td></tr><tr><td>docker attach [container name or ID]</td><td>Changes the command prompt from the host to a running container.</td></tr><tr><td>docker stop [container name or ID]</td><td>Stop a container.</td></tr><tr><td>docker rm -f [container name or ID]</td><td>Delete a container.</td></tr><tr><td>docker rmi</td><td>Delete an image.</td></tr><tr><td>docker tag user/image:tag user/image:newtag</td><td>Add a new tag to an image.</td></tr><tr><td>docker exec [container name or ID] shell command</td><td>Executes a command within a running container.</td></tr></tbody></table></div><h2 id="Image-Creation"><a href="#Image-Creation" class="headerlink" title="Image Creation"></a>Image Creation</h2><div class="table-container"><table><thead><tr><th>Docker语法</th><th>描述</th></tr></thead><tbody><tr><td>docker commit user/image</td><td>Save a container as an image.</td></tr><tr><td>docker save user/image</td><td>Save an image to a tar archive.</td></tr><tr><td>docker build -t sampleuser/ubuntu .</td><td>Builds a Docker image from a Dockerfile in the current directory.</td></tr><tr><td>docker load</td><td>Loads an image from file.</td></tr></tbody></table></div><h2 id="Docker-net-http-TLS-handshake-timeout的解决办法"><a href="#Docker-net-http-TLS-handshake-timeout的解决办法" class="headerlink" title="Docker net/http: TLS handshake timeout的解决办法"></a>Docker net/http: TLS handshake timeout的解决办法</h2><p>由于国内网络环境问题，Docker pull国外镜像出现无法使用的网络问题，因此更换国内镜像：<br>修改 <code>sudo vim /etc/docker/daemon.json</code>，添加如下地址：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://khec465u.mirror.aliyuncs.com"</span></span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重启Docker服务：<code>sudo service docker restart</code></p><h2 id="解决每次使用Docker命令都需要root权限的问题"><a href="#解决每次使用Docker命令都需要root权限的问题" class="headerlink" title="　解决每次使用Docker命令都需要root权限的问题"></a>　解决每次使用Docker命令都需要root权限的问题</h2><p>将你使用的具有root权限的用户加入docker group： <code>sudo usermod -aG docker $USER</code></p><p><a href="https://www.linode.com/docs/applications/containers/docker-commands-quick-reference-cheat-sheet/" target="_blank" rel="noopener">https://www.linode.com/docs/applications/containers/docker-commands-quick-reference-cheat-sheet/</a></p><hr><h1 id="Kubernets"><a href="#Kubernets" class="headerlink" title="Kubernets"></a>Kubernets</h1><p><strong>Deploying the Dashboard UI</strong>：<code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</code><br><a href="https://jimmysong.io/kubernetes-handbook/guide/auth-with-kubeconfig-or-token.html" target="_blank" rel="noopener">使用 kubeconfig 或 token 进行用户身份认证</a><br><strong>生成 token</strong></p><p>需要创建一个admin用户并授予admin角色绑定，使用下面的yaml文件创建admin用户并赋予他管理员权限，然后可以通过token访问kubernetes，该文件见<a href="https://github.com/rootsongjc/kubernetes-handbook/tree/master/manifests/dashboard-1.7.1/admin-role.yaml" target="_blank" rel="noopener">admin-role.yaml</a>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 serviceaccount 和角色绑定:</span></span><br><span class="line">$ kubectl create -f admin-role.yaml</span><br><span class="line"><span class="comment"># 获取admin-token的secret名字:</span></span><br><span class="line">$ kubectl -n kube-system get secret|grep admin-token</span><br><span class="line"><span class="comment"># 获取token的值</span></span><br><span class="line">$ kubectl -n kube-system describe secret admin-token-528zm</span><br><span class="line"><span class="comment"># 使用 kubectl 提供的 Proxy 服务来访问Dashboard</span></span><br><span class="line"><span class="comment"># 如果8001端口号占用，加 --port 8002 参数</span></span><br><span class="line">kubectl proxy</span><br><span class="line"><span class="comment"># 打开如下地址：</span></span><br><span class="line"><span class="comment"># http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="/ " data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screen Shot 2019-12-20 at 11.16.39 AM.png"><br><a href="https://spin.atomicobject.com/2019/07/11/docker-volumes-explained/" target="_blank" rel="noopener">Docker Volumes: Why, When, and Which Ones?</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派4B 玩转指南</title>
      <link href="/Raspberry-pi-4/"/>
      <url>/Raspberry-pi-4/</url>
      
        <content type="html"><![CDATA[<p>我的新玩具树莓派4B到手啦，我选择的是2GB RAM版本，刷上系统先，开干!</p><a id="more"></a><h2 id="安装轻量级无图形界面系统"><a href="#安装轻量级无图形界面系统" class="headerlink" title="安装轻量级无图形界面系统"></a>安装轻量级无图形界面系统</h2><p>树莓派开发板没有配置板载FLASH，因为它支持SD卡启动，所有我们需要下载相应镜像，并将其烧写在SD上，启动系统即可。(这个镜像里包含了我们通常所说的bootloader、kernel、文件系统)</p><p>树莓派由于其开源特性，支持非常多的系统类型：</p><p>Raspbian、Arch Linux ARM、Debian Squeeze、Firefox OS、Gentoo Linux、OpenWRT、<br>Google Chrome OS、Raspberry Pi Fedora Remix、Slackware ARM<br>QtonPi、Slackware ARM、WebOS、RISC OS、FreeBSD、NetBSD、Android 4.0(Ice Cream Sandwich)</p><p>树莓派4B暂时只提供官方raspbian系统</p><p>树莓派官网的下载地址：<a href="http://www.raspberrypi.org/downloads" target="_blank" rel="noopener">http://www.raspberrypi.org/downloads</a></p><p>我下载安装的轻量化无图形界面系统为 <strong>Raspbian Buster Lite</strong> Minimal image based on Debian Buster。使用的镜像刻录工具是 <strong>balenaEtcher-1.5.56-x64.AppImage</strong>。</p><h2 id="启动树莓派"><a href="#启动树莓派" class="headerlink" title="启动树莓派"></a>启动树莓派</h2><p>烧写完后把MicroSD卡直接插入树莓派的MicroSD卡插槽，另外我们给莓派连接显示器、电源、鼠标、键盘，打开数据线上的电源开关以后，就可以进入树莓派系统了。正常情况下红色电源灯常亮，绿色信号灯不规律闪烁。红灯偶尔出现灭的情况可能是供电不足，只要系统可以正常进入就可以了。</p><h2 id="连接WiFi"><a href="#连接WiFi" class="headerlink" title="连接WiFi"></a>连接WiFi</h2><p><code>sudo raspi-config</code>：选择【2 Network Options】-&gt;【N2 Wi-fi】-&gt;输入SSID、密码。<br><code>sudo iwlist wlan0 scan</code>：扫描树莓派已经识别的wifi</p><h2 id="启用SSH"><a href="#启用SSH" class="headerlink" title="启用SSH"></a>启用SSH</h2><p><code>sudo raspi-config</code>：选择【5 Interface Options】-&gt;[SSH]进行SSH的启用</p><h2 id="更换国内源"><a href="#更换国内源" class="headerlink" title="更换国内源"></a>更换国内源</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib</span><br><span class="line"></span><br><span class="line"># 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br></pre></td></tr></tbody></table></figure><p>使用<code>sudo apt-get update</code>进行更新</p><h2 id="显示CPU温度"><a href="#显示CPU温度" class="headerlink" title="显示CPU温度"></a>显示CPU温度</h2><p><code>cat /sys/class/thermal/thermal_zone0/temp</code>：返回值除以1000极为当前CPU温度</p><h2 id="必备软件安装"><a href="#必备软件安装" class="headerlink" title="必备软件安装"></a>必备软件安装</h2><p><code>sudo apt install vim tmux git</code>：安装VIM、tmux、git<br>安装Python3：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line">chmod +x Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line">./Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line"></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>curl -sLf https://spacevim.org/install.sh | bash</code>：配置SpaceVim</p><p><strong>安装Docker</strong>:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sL get.docker.com | sed <span class="string">'s/9)/10)/'</span> | sh</span><br><span class="line">pip3 config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">sudo pip3 install docker-compose</span><br></pre></td></tr></tbody></table></figure><p></p><p>更换Docker清华镜像<br><code>sudo vim /etc/apt/sources.list.d/docker.list</code>:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb [arch=armhf] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/raspbian buster stable</span><br></pre></td></tr></tbody></table></figure><p></p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/docker-ce/" target="_blank" rel="noopener">Docker Community Edition 镜像使用帮助</a></p><h2 id="关机与重启"><a href="#关机与重启" class="headerlink" title="关机与重启"></a>关机与重启</h2><p><code>sudo shutdown</code>：一分钟之后关机，<code>shutdown -c</code>取消关机<br><code>sudo shutdown now</code>：立即关机<br><code>sudo reboot</code>、<code>sudo shutdown -r</code>：重新启动<br><code>sudo shutdown 11:00</code>：上午11:00定时关机<br><code>sudo shutdown +10</code>：10分钟后关机</p><h2 id="打造树莓派路由器"><a href="#打造树莓派路由器" class="headerlink" title="打造树莓派路由器"></a>打造树莓派路由器</h2><p><a href="https://github.com/billz/raspap-webgui" target="_blank" rel="noopener">billz/<strong>raspap-webgui</strong></a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name=gitea -p 1008x:3000 -v /var/lib/gitea:/data --restart unless-stopped kunde21/gitea-arm:latest</span><br></pre></td></tr></tbody></table></figure><h2 id="打造私人git服务器"><a href="#打造私人git服务器" class="headerlink" title="打造私人git服务器"></a>打造私人git服务器</h2><p><strong>安装Gitea</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitea/gitea:latest</span><br><span class="line"></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line">sudo mkdir -p /var/lib/gitea</span><br><span class="line"></span><br><span class="line">docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /var/lib/gitea:/data gitea/gitea:latest</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="打造家用云服务器"><a href="#打造家用云服务器" class="headerlink" title="打造家用云服务器"></a>打造家用云服务器</h2><p><strong>安装NextCloudPi</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Start docker with custom storage volume with:</span><br><span class="line">sudo mkdir /media/ncdata</span><br><span class="line"># 主机80端口已被raspap-webgui占用</span><br><span class="line">docker run -d -p 4443:4443 -p 443:443 -p 81:80 -v /media/ncdata:/data --name nextcloudpi ownyourbits/nextcloudpi-armhf $DOMAIN</span><br><span class="line"># 观察nextcloudpi的安装进度</span><br><span class="line">docker logs -f nextcloudpi</span><br></pre></td></tr></tbody></table></figure><p></p><p>Login with user <code>pi</code> and password <code>raspberry</code>(&lt;- For default).<br><strong>进入系统设置</strong><br><code>sudo raspi-config</code><br><strong>进入nextcloud app 设置</strong><br><code>sudo sudo ncp-config</code><br><a href="https://docs.nextcloudpi.com/en/how-to-get-started-with-ncp-docker/" target="_blank" rel="noopener">https://docs.nextcloudpi.com/en/how-to-get-started-with-ncp-docker/</a></p><h2 id="挂载移动硬盘并设置Samba共享"><a href="#挂载移动硬盘并设置Samba共享" class="headerlink" title="挂载移动硬盘并设置Samba共享"></a>挂载移动硬盘并设置Samba共享</h2><p><strong>挂载硬盘</strong><br>我的硬盘之前安装过Ubuntu系统，因此为ext4文件系统，树莓派的是Debian系统可以直接读取ext4文件系统，因此挂载后可以直接读取，如果是Windows的NTFS系统需要另外处理<br>插上硬盘，查看状态：sudo fdisk -l<br>新建一个目录 ，让树莓派将硬盘挂载到创建的目录：<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/toshiba</span><br><span class="line">sudo mount /dev/sda2  /mnt/data</span><br></pre></td></tr></tbody></table></figure><p></p><p>还可以设置开机自动挂载</p><p><strong>Samba</strong><br>sudo apt install samba samba-common-bin<br>sudo vim /etc/samba/smb.conf<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pi]           # Name will show on Internet</span><br><span class="line">path = /mnt/data</span><br><span class="line">valid users = pi</span><br><span class="line">browseable = yes</span><br><span class="line">public = yes</span><br><span class="line">writable = yes</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置<code>pi</code>用户的密码：sudo smbpasswd -a pi<br>重启Samba服务：sudo systemctl restart smbd.service</p><p>打开MacOS的finder，从<code>Go</code>选项中点击<code>Connect to Server…</code>，输入树莓派Samba地址：<code>192.168.1.3/pi</code>输入用户名密码即可完成连接。</p><hr><p><a href="https://docs.gitea.io/zh-tw/install-with-docker/" target="_blank" rel="noopener">https://docs.gitea.io/zh-tw/install-with-docker/</a></p><p><a href="https://docs.gitea.io/zh-cn/install-with-docker/" target="_blank" rel="noopener">https://docs.gitea.io/zh-cn/install-with-docker/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Raspbian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Raspberry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Smart Beta</title>
      <link href="/Smart-Beta/"/>
      <url>/Smart-Beta/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DeepWalk</title>
      <link href="/DeepWalk/"/>
      <url>/DeepWalk/</url>
      
        <content type="html"><![CDATA[<p>DeepWalk(2014’KDD)，一种用于学习网络中顶点的潜在表示方法.DeepWalk提出了新的、无监督的、独立于标签分布的（捕获结构信息时不考虑标签）、捕获图结构信息的算法。算法目标是学习图的结构特征<script type="math/tex">\mathbf{X}_{\mathrm{E}} \in \mathbf{R}^{|\mathbf{V}| \times \mathbf{d}}</script>，其中d是节点的潜在表示（向量形式）的维数。图结构特征可以用于任何分类算法。将<script type="math/tex">\mathbf{X}_{\mathrm{E}} \in \mathbf{R}^{|\mathbf{V}| \times \mathbf{d}}</script>与简单的机器学习算法集成，还可以用来实现很多其他问题。<br><a id="more"></a></p><p>图的表示：令G =(V,E)，其中V表示网络的节点，E是网络中的连接，E⊆ (V×V)。<br>GL=(V,E,X,Y)是部分标记的社交网络。X是各个节点的属性空间，X∈R|V|×S，其中S是每个节点的属性向量的特征空间的大小；Y∈R|V|×|Y|，Y是标签的集合。</p><p><a href="https://github.com/phanein/deepwalk" target="_blank" rel="noopener">phanein/deepwalk</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/elasticsearch/"/>
      <url>/elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p><h1 id="Linux上的安装"><a href="#Linux上的安装" class="headerlink" title="Linux上的安装"></a>Linux上的安装</h1><blockquote><p>jdk至少需要在1.8.0_73以上版本</p></blockquote><a id="more"></a><p>解压文件<code>tar -zxvf elasticsearch-x.x.x.tar.gz</code>，<code>./bin/elasticsearch</code>为启动文件，但如果此时直接启动elasticsearch的话，会报错<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Image 3.png"><br>原因是elasticsearch默认不支持root用户运行，因为正式环境用root运行可能会有安全风险，不建议用root来跑。我们可以单独为elasticsearch单独创建一个用户<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m elastic -s /bin/bash          <span class="comment">#创建elastic用户，并使用/bin/bash作为shell</span></span><br><span class="line">sudo passwd elastic                           <span class="comment">#为elastic用户设置密码，之后需要连续输入两次密码</span></span><br><span class="line">sudo adduser elastic sudo                     <span class="comment">#为elastic用户增加管理员权限</span></span><br><span class="line">chown -R elastic:elastic  elasticsearch-x.x.x <span class="comment">#为elastic添加文件权限</span></span><br><span class="line">su - elastic                                  <span class="comment">#切换当前用户为用户elastic</span></span><br><span class="line"><span class="built_in">cd</span> elasticsearch-x.x.x                        <span class="comment">#切换目录</span></span><br><span class="line">./bin/elasticsearch                           <span class="comment">#执行</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 <code>-d</code> 。<br>如果你是在 Windows 上面运行 Elasticseach，你应该运行 <code>bin\elasticsearch.bat</code> 而不是 <code>bin\elasticsearch</code> 。<br>使用 <code>curl http://localhost:9200/</code> 查看是否运行，如果返回如下信息则标示运行正常：<br></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"RjxKv_d"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"SYM-Wb6xR3mqGLx4bHtBNA"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : {</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"6.1.3"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"af51318"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2018-01-26T18:22:55.523Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"7.1.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p><a href="https://www.biaodianfu.com/centos-7-install-elasticsearch.html" target="_blank" rel="noopener">Elasticsearch在Centos 7上的安装与配置</a><br><a href="https://es.xiaoleilu.com/010_Intro/05_What_is_it.html" target="_blank" rel="noopener">Elasticsearch权威指南</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>machine learning in finance</title>
      <link href="/ML-in-Finance/"/>
      <url>/ML-in-Finance/</url>
      
        <content type="html"><![CDATA[<p><strong>沪深300指数</strong>由上海和深圳证券市场中市值大、流动性好的300只股票组成，综合反映中国A股市场上市股票价格的整体表现。<br><strong>恒生指数</strong>(Hang Seng Index)是以反映香港股市行情的重要指标，指数由五十只恒指成份股的市值计算出来的，代表了香港交易所所有上市公司的十二个月平均市值涵盖率的63%。<br><strong>标普500</strong>是由标准普尔於1957年创立的，被广泛认为是三只股指中衡量美国经济状况最好的一项指标。标普500股票平均价格指数是由每支成分股公司的市场价值之和除以一个由标准普尔设定的除数得到的终值。简而言之就是，所有股票的市值总和除以标普除数，或总市值/标普除数。<br><strong>道琼斯工业平均指数</strong>，简称道指，是三只股指中历史最为悠久也是全球最知名的股指。道指最早是在1884年由道琼斯公司的创始人查尔斯·亨利·道开始编制的一种算术平均股价指数。道指代表了华尔街日报确认的30只大盘股。不同於标普500和纳指，道指成分股的比重是根据股票价格排序的，也就是说股票价格越高的公司越能影响道指的表现。道指股票价格平均指数是入选股票的价格之和除以道指除数得到的终值。<br><strong>纳斯达克指数</strong>，简称纳指，1985年开始交易，是三只股指中最为年轻的股指。纳指代表著在纳斯达克上市的最大的非金融公司，其中科技股所占比重较大，因此通常被认为是一只科技股指。该股指是根据每个公司的市场价值来设置权重，这意味著每个公司对指数的影响力是由其市场价值决定的。</p><a id="more"></a><p><strong>市场（或代表性指数）收益率market rate of return</strong>：国内市场通常使用沪深300指数作为市场代表，美股则常用标普500指数，港股则常用恒生指数</p><p><strong>无风险利率risk-free rate</strong>：这是投资者将资金投资于某一项没有任何风险的投资对象而能得到的利息率，例如以人民币投资的中国国债、美元投资的美国国库券、以欧元交易和投资的德国政府债券等。该数字通常以百分比表示。<br><img alt="Investing.com - 中国政府债券" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-08-12-11-34-20.png"></p><h1 id="Capital-Asset-Pricing-Model资本资产定价模型"><a href="#Capital-Asset-Pricing-Model资本资产定价模型" class="headerlink" title="Capital Asset Pricing Model资本资产定价模型"></a>Capital Asset Pricing Model资本资产定价模型</h1><p>在金融世界，人们手持多余的资金时候本能欲望都会寻求让资金尽量增长，投资因此诞生。但并不是每项投资都能带来收益，人的本能让人追求收益畏惧风险。<br>在现实世界的自由投资途径中，低风险高收益的投资项人们会蜂拥而至进行瓜分，高风险低收益的对象会逐渐被人抛弃。<br>现实世界的投资途径如此之多，有一类投资能让你保证获得收益，这类投资称为无风险收益，例如以国家信用做背书的国债和银行定期存款。但有些人为了获得更高的收益愿意承担一定的风险选择投资股市，因此有一个市场的平均收益。有没有一个收益最大风险最小的投资组合？它在哪里？这是每一个投资者每天都在考虑的问题。为了搞清这个问题，经济学家尝试简化世界，构建了CAPM模型来进行风险评估和收益预计：</p><script type="math/tex; mode=display">E(r_{i})=r_{f}+\beta[E(r_{m})-r_{f}]</script><p>其中</p><ul><li>$E(r_{i})$是资产$i$的期望收益率;</li><li>$r_{f}$是无风险收益率，通常以短期国债的利率来近似替代;</li><li>$\beta$是资产$i$的系统性风险系数;</li><li>$E(r_{m})$是市场收益率，通常用股票价格指数收益率的平均值或所有股票的平均收益率来代替;<!-- - $E(r_{m})-r_{f}$是市场风险溢价(Market Risk Premium)，即市场投资组合的期望收益率与无风险收益率之差。 -->这个简洁的模型将无风险收益与市场平均收益都考虑进来，毕竟如果没有一个预估的高收益吸引投资者，那还不如把钱存个定期。</li></ul><h1 id="Beta系数"><a href="#Beta系数" class="headerlink" title="Beta系数"></a>Beta系数</h1><p><strong>Beta系数$\beta$</strong>作为一个统计学上的概念，用以度量一项资产系统性风险的指标，是资本资产定价模型的参数之一。指用以衡是资产i的系统性风险系数，量一种证券或一个投资证券组合相对总体市场的波动性的一种证券系统性风险的评估工具。Beta系数可用于计算股票的预期收益率。Beta系数是股票分析师们在选择资产组合中的股票时要考虑的基本因素之一，其他因素包括市盈率、股东权益、资本负债比率等。</p><ul><li>如果是负值，则显示其变化的方向与大盘的变化方向相反;大盘涨的时候它跌，大盘跌的时候它涨；有一些行业组织，如黄金矿工，其中负beta很常见。</li><li>$\beta$ =0，表示投资组合和市场走向没有相关性，如固定收益类；</li><li>当$\beta$=1，说明投资对象的价值与市场强烈相关。在投资组合中加入Beta为1的股票并没有增加任何风险，也没有增加获得超额收益的可能性。</li><li>当$\beta$&lt;1，显示其价值波动理论上小于市场，意味着在投资组合中加入这样的对象能减小风险，公共事业股票utility stocks通常有较低的beta，因为它们变化往往比市场平均值更慢。</li><li>当$\beta$&gt;1，显示其价值波动理论上大于市场。例如如果一个股票的Beta为1.2，说明其比市场还多20%的波动性，科技股通常拥有比市场基准更高的beta，这样的对象会增加投资组合的风险但也更可能带来超额收益。</li></ul><h2 id="Beta系数有什么用"><a href="#Beta系数有什么用" class="headerlink" title="Beta系数有什么用;"></a>Beta系数有什么用;</h2><ul><li>使用Beta来选择股票是减少波动性和创建更多元化投资组合的工具之一。</li><li>计算资本成本，进行资产估值、做出投资决策、制定考核及激励标准</li><li>计算单个资产或组合的系统风险(投资组合的Beta等于单个Beta系数的加权求和)，进行投资管理</li><li>牛市时选择高Beta证券，将成倍放大市场收益；熊市时选择低Beta证券以抵御市场风险</li></ul><!-- ![](v4-728px-Calculate-Beta-Step-3-Version-4.jpg.jfif) --><p><img alt="图中我们可以看出，谷歌股票的回报波动比较大（蓝色），标普500的回报波动比较小（橙色）" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/download.png"></p><h1 id="Beta系数计算方法"><a href="#Beta系数计算方法" class="headerlink" title="Beta系数计算方法"></a>Beta系数计算方法</h1><h2 id="通过相关系数计算Beta"><a href="#通过相关系数计算Beta" class="headerlink" title="通过相关系数计算Beta"></a>通过相关系数计算Beta</h2><p>既然Beta是衡量股票收益相对于市场收益的风险程度，于是可以通过计算两者的相关系数来确定Beta：</p><script type="math/tex; mode=display">Beta=\beta_{p}=\frac{Cov(D_{p},D_{m})}{Var(D_{m})}</script><p>其中<script type="math/tex">D_{p}</script>为策略每日收益，<script type="math/tex">D_{m}</script>为大盘每日收益，<script type="math/tex">Cov(D_{p},D_{m})</script>是策略每日收益与大盘每日收益的协方差,<script type="math/tex">Var(D_{m})</script>为大盘每日收益方差</p><h2 id="通过历史已知的策略收益反推"><a href="#通过历史已知的策略收益反推" class="headerlink" title="通过历史已知的策略收益反推"></a>通过历史已知的策略收益反推</h2><p>在CAPM模型中如果已知历史策略收益，那么带入已知项可求得Beta：</p><script type="math/tex; mode=display">Beta=\beta_{p}=\frac{E(r_{i})-r_{f}}{E(r_{m})-r_{f}}</script><h2 id="通过线性回归拟合"><a href="#通过线性回归拟合" class="headerlink" title="通过线性回归拟合"></a>通过线性回归拟合</h2><p>既然在CAPM模型中Beta作为市场收益减去无风险收益的系数，对于历史已知的股票收益，</p><script type="math/tex; mode=display">R_{p}=\alpha+\beta_{p} R_{m}+\varepsilon</script><p>将大盘收益率作为Y，将策略历史收益率作为X进行回归，$\varepsilon$是建模误差。通过最小化回归方程预测的 y 值与实际 y 值之间的平方差（垂直距离），能够得到一条最合理的回归直线，直线与Y轴截距是事后的 $\alpha$，即与市场指数回报相比，超额回报的衡量。如果截距是负数，则意味着策略在风险调整的基础上表现落后于大盘，而截距是正数，则意味着其在风险调整基础上有超额收益。回归线的斜率系数 Beta 被计算为 x 和 y 的协方差除以 x 的方差，在数学上与方式一是一致的。</p><p>这种方式得出的Beta值相对稳定<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/download1.png"></p><h1 id="Alpha系数"><a href="#Alpha系数" class="headerlink" title="Alpha系数"></a>Alpha系数</h1><p>实际风险回报和平均预期风险回报的差额即 α 系数。<br>投资中面临着系统性风险(即$\beta$)和非系统性风险(即$\alpha$)，$\alpha$是投资者获得与市场波动无关的回报。比如</p><ul><li>α&gt;0，表示一基金或股票的价格可能被低估，建议买入。亦即表示该基金或股票以投资技术获得比平均预期回报大的实际回报。较高的α一般由股票的个性特征所决定，与大势和行业无关，应尽可能寻找高α的个股。</li><li>α&lt;0，表示一基金或股票的价格可能被高估，建议卖空。亦即表示该基金或股票以投资技术获得比平均预期回报小的实际回报。</li><li>α=0，表示一基金或股票的价格准确反映其内在价值，未被高估也未被低估。亦即表示该基金或股票以投资技术获得平均与预期回报相等的实际回报。</li></ul><h1 id="Alpha的计算"><a href="#Alpha的计算" class="headerlink" title="Alpha的计算"></a>Alpha的计算</h1><p>alpha是超额收益，它与市场波动无关，也就是说不是靠系统性的上涨而获得收益。</p><script type="math/tex; mode=display">Alpha=\alpha=\mathrm{R}_{p}-\left[R_{f}+\beta *\left(R_{m}-R_{f}\right)\right]</script><h1 id="使用Python计算Beta及Alpha系数"><a href="#使用Python计算Beta及Alpha系数" class="headerlink" title="使用Python计算Beta及Alpha系数"></a>使用Python计算Beta及Alpha系数</h1><h2 id="CAPM及Beta、Alpha系数的局限"><a href="#CAPM及Beta、Alpha系数的局限" class="headerlink" title="CAPM及Beta、Alpha系数的局限"></a>CAPM及Beta、Alpha系数的局限</h2><p>Beta系数为股票评估提供了参考，但它具有它固有的局限性。尽管Beta可用于确定证券的短期风险，并用于CAPM分析波动率以计算股权成本，由于β系数是使用历史数据点计算的，因此对于希望预测股票未来走势的投资者来说，它变得没那么有意义。Beta对长期投资的作用也不大，因为股票的波动性每年都会发生显着变化，具体取决于公司的增长阶段和其他因素。</p><p>CAPM(资产资本定价模型)是在金融经济学中发挥了广泛的应用，但其作为对理想情况的一个建模，建立在假设投资者信息对等、投资行为不会对股票价格产生影响的前提下。有研究学者指出，CAPM不适用于中国股票市场，收益率和Beta之间并不是线性相关。</p><p>许多学者提出异议，认为市场过于“有效”，投资者除非碰巧，否则无法重复地赚得超额收益。另一方面，由Russ Wermers领衔的对共同基金的实证研究得到的结论认为，基金经理寻找、挑选有正α值的证券是有价值的。然而这一研究结论遭到非议，批评者认为Russ的结论受到“幸存者偏差”的影响。虽然受到争议，詹森阿尔法仍然被广泛的用于评价基金经理表现。</p><p><strong>Good References:</strong></p><ol><li><a href="https://www.cnvar.cn/2019/01/11/beta-calculation-linear-regression/" target="_blank" rel="noopener">贝塔值（beta）的线性回归方法实践</a></li><li><a href="https://zh.wikihow.com/%E8%AE%A1%E7%AE%97%E8%82%A1%E7%A5%A8%E7%9A%84-Beta-%E7%B3%BB%E6%95%B0" target="_blank" rel="noopener">如何计算股票的 Beta 系数</a></li><li><a href="https://www.money-zine.com/investing/stocks/stock-beta-and-volatility/" target="_blank" rel="noopener">Stock Beta and Volatility</a></li><li><a href="https://www.cnvar.cn/2017/08/28/negative-betas/" target="_blank" rel="noopener">贝塔系数(Betas)能否为负数?一个经常被问到的面试问题</a></li><li><a href="https://xueqiu.com/2551686004/129137796" target="_blank" rel="noopener">沪深300指数与标普500指数差距有多大？</a></li><li><a href="https://xueqiu.com/2551686004/102206316" target="_blank" rel="noopener">跨越半个世纪的资产配置量化研究，少踩坑，多赚钱</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Outfits dataset</title>
      <link href="/Outfits-dataset/"/>
      <url>/Outfits-dataset/</url>
      
        <content type="html"><![CDATA[<h1 id="Task："><a href="#Task：" class="headerlink" title="Task："></a>Task：</h1><p>1、Fill in the blank</p><p>2、Outfit generation given texts or images</p><p>3、 Compatibility prediction</p><a id="more"></a><h1 id="Dataset："><a href="#Dataset：" class="headerlink" title="Dataset："></a>Dataset：</h1><p><strong>The Polyvore dataset</strong></p><p>是一个流行的时尚搭配网站，用户可以自由搭配喜欢的时装配饰等单品，并通过在线社区分享，同时了解其它用户的穿衣搭配。Polyvore数据集是从Polyvore.com上爬取的用户搭配方案与单品信息数据集，根据爬取的数量不同有多个不同的版本。网络上公开可用的The Polyvore dataset 有 <a href="https://github.com/xthan/polyvore-datasepolyvore-datasett" target="_blank" rel="noopener">polyvore-dataset</a> 等，其中包含的搭配Outfits方案数与单品Items数量如下：</p><blockquote><p><code>#Outfits</code>: 21889 (17316 for training, 1497 for validation and 3076 for testing)<br><code>#Categories</code>: 380<br><code>#Items</code>: 164,379<br>Max Items/Outfit: 8<br>Average Items/Outfit: 6.5<br>Text Available?: Titles &amp; Descriptions</p></blockquote><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-07-25-23-05-54.png"></p><p><a href="https://drive.google.com/drive/folders/0B4Eo9mft9jwoVDNEWlhEbUNUSE0" target="_blank" rel="noopener">polyvore-images.tar.gz</a> 是一个更大的版本（33,375 outfits），polyvore-dataset为其真子集。</p><h2 id="论文中相关数据使用情况："><a href="#论文中相关数据使用情况：" class="headerlink" title="论文中相关数据使用情况："></a>论文中相关数据使用情况：</h2><p><a href="https://arxiv.org/abs/1707.05691" target="_blank" rel="noopener">Learning Fashion Compatibility with Bidirectional LSTMs</a> “只用了polyvore-dataset”<br><a href="https://arxiv.org/abs/1902.08009" target="_blank" rel="noopener">Dressing as a Whole: Outfit Compatibility Learning Based on Node-wise Graph Neural Networks</a> “只用了polyvore-dataset”<br><a href="https://arxiv.org/abs/1803.09196" target="_blank" rel="noopener">Learning Type-Aware Embeddings for Fashion Compatibility</a> “只用了自己爬取的更大的polyvore数据集”<br><a href="https://github.com/WangXin93/fashion_compatibility_mcn" target="_blank" rel="noopener">Outfit Compatibility Prediction and Diagnosis with Multi-Layered Comparison Network</a>:尚未公开论文，但从代码看就polyvore-dataset一个数据集</p><!--**The Fashion-Gen Outfits dataset****Amazon products dataset** --><h1 id="Learning-Fashion-Compatibility-with-Bidirectional-LSTMs"><a href="#Learning-Fashion-Compatibility-with-Bidirectional-LSTMs" class="headerlink" title="Learning Fashion Compatibility with Bidirectional LSTMs"></a>Learning Fashion Compatibility with Bidirectional LSTMs</h1><p>将一个搭配方案视为从上到下然后到饰品的单品序列。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>交叉验证Cross Validation</title>
      <link href="/Cross-Validation/"/>
      <url>/Cross-Validation/</url>
      
        <content type="html"><![CDATA[<p>模型效果评估是机器学习开发中相当重要的一步，无论使用哪种最先进的state-of-the-art算法来构建假设函数并训练机器学习模型，都必须评估其性能后才能继续使用它。Evaluate模型最简单、最快捷的方法就是将数据集拆分为训练和测试集，使用训练集数据训练模型，并通过计算accuracy检查其准确性。并且在执行拆分之前不要忘记对数据集进行shuffle。但是这种方法并不能保证万无一失，简单来说，在最终确定模型时不能完全依赖这种方法。你可知道为什么？<br><a id="more"></a><br>举个例子：<br>在进行垃圾邮件分类的案例中，数据中包含98％的垃圾邮件和2％的非垃圾邮件有效电子邮件是很常见的情况。在这种情况下，即使你没有创建任何模型，只是将每个输入分类为垃圾邮件，都将获得98%的准确性。这种情况称为<strong>准确性悖论accuracy paradox</strong>。<br>想象一下如果这是肿瘤细胞或胸部X射线分类的模型会发生什么，而你已经将这个98％准确性模型推向市场，这样的算法可没法对患者产生任何帮助。</p><h1 id="划分数据集的作用"><a href="#划分数据集的作用" class="headerlink" title="划分数据集的作用"></a>划分数据集的作用</h1><p><strong>训练集</strong><br>用来训练模型内参数的数据集，Classfier直接根据训练集来调整自身获得更好的分类效果，比如SGD算法在训练集上计算梯度寻找权重调整方向，树模型在训练集上计算信息增益或残差寻找最佳分裂点。</p><p><strong>验证集</strong><br>​用于在训练过程中检验模型的状态，收敛情况。验证集通常用于调整超参数(那些需要手动设定的参数)，根据几组模型验证集上的表现决定哪组超参数拥有最好的性能，这是其在交叉验证部分的主要作用。</p><p>​同时验证集在训练过程中还可以用来监控模型是否发生过拟合，一般来说验证集表现稳定后，若继续训练，训练集表现还会继续上升，但是验证集会出现不升反降的情况，这样一般就发生了过拟合。所以验证集也用来判断何时停止训练(Early stopping)。</p><p><strong>测试集</strong><br>测试集用来评价模型泛化能力，即之前模型使用验证集确定了超参数，使用训练集调整了参数，最后使用一个从没有见过的数据集来判断这个模型是否Work。</p><h1 id="交叉验证是什么？"><a href="#交叉验证是什么？" class="headerlink" title="交叉验证是什么？"></a>交叉验证是什么？</h1><p>Cross Validation是一种评估模型性能的重要方法，主要用于在多个模型中（不同种类模型或同一种类不同超参数组合）挑选出在当前问题场景下表现最优的模型（model selection）。根据分成不同数据组的数量主要分为以下三大类：</p><h2 id="Train-Test-spilt-groups-2"><a href="#Train-Test-spilt-groups-2" class="headerlink" title="Train/Test spilt: # groups =2"></a>Train/Test spilt: # groups =2</h2><p>在拿到数据之后通常会将所有数据分成两组，一组<strong>train_set</strong>用于训练模型;另一组用作保持集<strong>holdout set</strong>，用于检查模型在完全看不见的数据中的行为方式。下图总结了执行拆分的整个想法。<br></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.25</span>, random_state = <span class="number">42</span>, shuffle = <span class="literal">True</span>, stratify = y)</span><br></pre></td></tr></tbody></table></figure><p><code>X</code>是原始全体数据的特征，<code>y</code>是全体数据的标签，<code>shuffle</code>为True则会将所有样本先随机洗牌再切分，<code>stratify</code>用于处理不平衡的样本，将样本按照标签的不同进行分层采样。<br>好处：处理简单，只需随机把原始数据分为两组即可<br>坏处：但没有达到交叉的思想，由于是随机的将原始数据分组，所以最后验证集分类准确率的高低与原始数据的分组有很大的关系，得到的结果并不具有说服性。</p><h2 id="K折交叉验证，K-Fold-Cross-Validation-groups-K"><a href="#K折交叉验证，K-Fold-Cross-Validation-groups-K" class="headerlink" title="K折交叉验证，K-Fold Cross Validation: # groups =K"></a>K折交叉验证，K-Fold Cross Validation: # groups =K</h2><p>在训练集（train set）上训练得到的模型表现良好，但在测试集（test set）的预测结果不尽如人意，这就说明模型可能出现了过拟合（overfitting），bias低而variance高，在未知数据上的泛化能力差。<br>一个改进方案是，在训练集的基础上进一步划分出新的训练集和验证集（validate set），在新训练集训练模型，在验证集测试模型，不断调整初始模型（超参数等），使得训练得到的模型在验证集上的表现最好，最后放到测试集上得到这个最优模型的评估结果。<br>这个方案的问题在于模型的表现依赖于验证集的划分，可能使某些特殊样本被划入验证集，导致模型的表现出现异常（偏好或偏差）。而且训练集划了一部分给验证集后，训练模型能得到的数据就变少了，也会影响训练效果。因为通常来说，训练数据越多，越能反映出数据的真实分布，模型训练的效果就越好，越可能得到无偏估计。<br>交叉验证思想应运而生，交叉验证可以充分使用所有的训练数据用于评估模型。<br><br>K折交叉验证是最基本的cv方法，具体方法为，将训练集随机等分为k份，取其中一份为验证集评估模型，其余k-1份为训练集训练模型，重复该步骤k次，每次都取一份不同的子集为验证集，最终得到k个不同的模型（不是对一个模型迭代k次）和k个评分，综合这k个模型的表现（平均得分或其他）评估模型在当前问题中的优劣。<br></p><blockquote><p>K值的选取很有讲究，K越大，在训练集上的Bias就会越小，但训练集越大会导致Variance越大，同时花费的时间越长，所以选取适当大小的K很重要，经验值（empirical value）是K=5或10。</p></blockquote><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># scikit-learn k-fold cross-validation</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="comment"># data sample</span></span><br><span class="line">data = array([<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>])</span><br><span class="line"><span class="comment"># prepare cross validation</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">3</span>, shuffle = <span class="literal">True</span>, random_state= <span class="number">1</span>)</span><br><span class="line"><span class="comment"># enumerate splits</span></span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> kfold.split(data):</span><br><span class="line">    print(<span class="string">'train: %s, test: %s'</span> % (data[train], data[test]))</span><br></pre></td></tr></tbody></table></figure><h2 id="留一法，Leave-one-out（LOO）-groups-len-dataset"><a href="#留一法，Leave-one-out（LOO）-groups-len-dataset" class="headerlink" title="留一法，Leave one out（LOO）: # groups = len(dataset)"></a>留一法，Leave one out（LOO）: # groups = len(dataset)</h2><p>考虑一种极端情况，将K设为样本总数N，留一法每次在训练集的N个样本中选一个不同的样本作为验证集，其余样本为训练集，训练得到N-1个不同的模型。LOOCV是特殊的K-fold。</p><h2 id="嵌套交叉验证，Nested-Cross-Validation"><a href="#嵌套交叉验证，Nested-Cross-Validation" class="headerlink" title="嵌套交叉验证，Nested Cross Validation"></a>嵌套交叉验证，Nested Cross Validation</h2><p>嵌套交叉验证（Nested Cross Validation）将调参和模型选择结合起来比较好的方式是嵌套交叉验证，其挑选的模型在训练集和测试集上的误差估计几乎没有出入。<br>嵌套交叉验证流程图如下（也被称作5*2 cross-validation）：<br><br>内层交叉验证（innner loop）：用于模型选择，可以进行特征工程处理数据。<br>外层交叉验证（outer loop）：用于模型评估，使用所有数据集进行分割，而不仅是训练集，且用Stratified K-Fold保证类别比例不变。外层每一折都使用内层得到的最优参数组合进行训练。<br>演示代码：<br></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gs = GridSearchCV(estimator=pipe_svc, ... param_grid=param_grid, ... scoring=<span class="string">'accuracy'</span>, ... cv=<span class="number">2</span>)</span><br><span class="line">scores = cross_val_score(gs, X_train, y_train, ... scoring=<span class="string">'accuracy'</span>, cv=<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><p>嵌套交叉验证可以看做是GridSearchCV的升级版，普通GridSearchCV训练的模型只在一部分数据上进行测试，而嵌套交叉验证可以使模型在全部数据上进行测试，能更好的说明模型的泛化能力。</p><h1 id="选择合适的数据划分策略"><a href="#选择合适的数据划分策略" class="headerlink" title="选择合适的数据划分策略"></a>选择合适的数据划分策略</h1><p>在大多数数据划分工具包中，默认采用随机划分进行交叉验证。但是随机的结果并不总是最好的答案，有时候甚至是错误的。<br>在进行分类问题时，我们需要保证每一个类别都有样本出现在训练集和测试集当中，即使有些类别数量很少。而纯随机采样的划分策略有可能会导致某一部分数据并不包含某个类别。当这部分数据做了训练集，CV算法将崩溃，因为测试集当中包含模型从没见过的类别。如果遇到某类别数量很少的问题，则需要使用分层采样策略：每种类别按比例随机采样。</p><p>同样，比如在进行时间序列建模时，使用随机方法将在不知不觉的日期混合中打破训练集和测试集的时间连续性。在这类问题中，训练集代表我们现在拥有的数据，测试集代表未来的数据，我们需要确保当每个数据区用于测试时，只有先前的样本用于训练。一种方法是按年/月划分，然后对划分的每部分，仅使用时间较早的数据进行训练。</p><p>这种有目的地划分的策略对于<strong>时间序列</strong>问题是很有必要的，在其他情况下也可带来启发。例如，我们可以按城市划分数据，看看模型如何适用于以前从未见过的新城市，或者如果之前只看过少量城市，那么模型将如何运作。不同类型的分区策略会请求我们模型不同的问题，让我们能了解它在不同情况下的表现，掌握这一点就不会被生产中模型性能的变化感到意外了。</p><p><strong>为什么不使用cv过程中产生的最优模型？</strong><br>交叉验证并非用于建立具体模型，而是用于模型选择（model selection），cv中间过程产生的误差最小的模型并不一定是最优的，可能只是表面现象，因为只使用了一部分数据进行训练模型，且验证集的划分也不一定客观。当选定模型后，需要在<strong>全部训练集上重新训练模型</strong>。</p><figure class="highlight py"><figcaption><span>plot_nested_cross_validation_iris.py</span><a href="https://scikit-learn.org/stable/_downloads/plot_nested_cross_validation_iris.py" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Security-Policy"</span> content=<span class="string">"default-src 'none'; style-src 'unsafe-inline'; img-src data:; connect-src 'self'"</span>&gt;</span><br><span class="line">    &lt;title&gt;Page not found &amp;middot; GitHub Pages&lt;/title&gt;</span><br><span class="line">    &lt;style type=<span class="string">"text/css"</span> media=<span class="string">"screen"</span>&gt;</span><br><span class="line">      body {</span><br><span class="line">        background-color: <span class="comment">#f1f1f1;</span></span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        font-family: <span class="string">"Helvetica Neue"</span>, Helvetica, Arial, sans-serif;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      .container { margin: <span class="number">50</span>px auto <span class="number">40</span>px auto; width: <span class="number">600</span>px; text-align: center; }</span><br><span class="line"></span><br><span class="line">      a { color: <span class="comment">#4183c4; text-decoration: none; }</span></span><br><span class="line">      a:hover { text-decoration: underline; }</span><br><span class="line"></span><br><span class="line">      h1 { width: <span class="number">800</span>px; position:relative; left: <span class="number">-100</span>px; letter-spacing: <span class="number">-1</span>px; line-height: <span class="number">60</span>px; font-size: <span class="number">60</span>px; font-weight: <span class="number">100</span>; margin: <span class="number">0</span>px <span class="number">0</span> <span class="number">50</span>px <span class="number">0</span>; text-shadow: <span class="number">0</span> <span class="number">1</span>px <span class="number">0</span> <span class="comment">#fff; }</span></span><br><span class="line">      p { color: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>); margin: <span class="number">20</span>px <span class="number">0</span>; line-height: <span class="number">1.6</span>; }</span><br><span class="line"></span><br><span class="line">      ul { list-style: none; margin: <span class="number">25</span>px <span class="number">0</span>; padding: <span class="number">0</span>; }</span><br><span class="line">      li { display: table-cell; font-weight: bold; width: <span class="number">1</span>%; }</span><br><span class="line"></span><br><span class="line">      .logo { display: inline-block; margin-top: <span class="number">35</span>px; }</span><br><span class="line">      .logo-img<span class="number">-2</span>x { display: none; }</span><br><span class="line"><span class="meta">      @media</span></span><br><span class="line">      only screen <span class="keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="number">2</span>),</span><br><span class="line">      only screen <span class="keyword">and</span> (   min--moz-device-pixel-ratio: <span class="number">2</span>),</span><br><span class="line">      only screen <span class="keyword">and</span> (     -o-min-device-pixel-ratio: <span class="number">2</span>/<span class="number">1</span>),</span><br><span class="line">      only screen <span class="keyword">and</span> (        min-device-pixel-ratio: <span class="number">2</span>),</span><br><span class="line">      only screen <span class="keyword">and</span> (                min-resolution: <span class="number">192</span>dpi),</span><br><span class="line">      only screen <span class="keyword">and</span> (                min-resolution: <span class="number">2</span>dppx) {</span><br><span class="line">        .logo-img<span class="number">-1</span>x { display: none; }</span><br><span class="line">        .logo-img<span class="number">-2</span>x { display: inline-block; }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">#suggestions {</span></span><br><span class="line">        margin-top: <span class="number">35</span>px;</span><br><span class="line">        color: <span class="comment">#ccc;</span></span><br><span class="line">      }</span><br><span class="line">      <span class="comment">#suggestions a {</span></span><br><span class="line">        color: <span class="comment">#666666;</span></span><br><span class="line">        font-weight: <span class="number">200</span>;</span><br><span class="line">        font-size: <span class="number">14</span>px;</span><br><span class="line">        margin: <span class="number">0</span> <span class="number">10</span>px;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class="container"&gt;</span><br><span class="line"></span><br><span class="line">      &lt;h1&gt;404&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;&lt;strong&gt;File not found&lt;/strong&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        The site configured at this address does <span class="keyword">not</span></span><br><span class="line">        contain the requested file.</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        If this <span class="keyword">is</span> your site, make sure that the filename case matches the URL.&lt;br&gt;</span><br><span class="line">        For root URLs (like &lt;code&gt;http://example.com/&lt;/code&gt;) you must provide an</span><br><span class="line">        &lt;code&gt;index.html&lt;/code&gt; file.</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;a href="https://help.github.com/pages/"&gt;Read the full documentation&lt;/a&gt;</span><br><span class="line">        for more information about using &lt;strong&gt;GitHub Pages&lt;/strong&gt;.</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div id=<span class="string">"suggestions"</span>&gt;</span><br><span class="line">        &lt;a href="https://githubstatus.com"&gt;GitHub Status&lt;/a&gt; &amp;mdash;</span><br><span class="line">        &lt;a href="https://twitter.com/githubstatus"&gt;@githubstatus&lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;a href="/" class="logo logo-img-1x"&gt;</span><br><span class="line">        &lt;img width=<span class="string">"32"</span> height=<span class="string">"32"</span> title=<span class="string">""</span> alt=<span class="string">""</span> src=<span class="string">"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTZCRDY3REIzRjAxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTZCRDY3RUIzRjAxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdCQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjdDQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+SM9MCAAAA+5JREFUeNrEV11Ik1EY3s4+ddOp29Q5b0opCgKFsoKoi5Kg6CIhuwi6zLJLoYLopq4qsKKgi4i6CYIoU/q5iDAKs6syoS76IRWtyJ+p7cdt7sf1PGOD+e0c3dygAx/67ZzzPM95/877GYdHRg3ZjMXFxepQKNS6sLCwJxqNNuFpiMfjVs4ZjUa/pmmjeD6VlJS8NpvNT4QQ7mxwjSsJiEQim/1+/9lgMHgIr5ohuxG1WCw9Vqv1clFR0dCqBODElV6v90ogEDjGdYbVjXhpaendioqK07CIR7ZAqE49PT09BPL2PMgTByQGsYiZlQD4uMXtdr+JxWINhgINYhGT2MsKgMrm2dnZXgRXhaHAg5jEJodUAHxux4LudHJE9RdEdA+i3Juz7bGHe4mhE9FNrgwBCLirMFV9Okh5eflFh8PR5nK5nDabrR2BNJlKO0T35+Li4n4+/J+/JQCxhmu5h3uJoXNHPbmWZAHMshWB8l5/ipqammaAf0zPDDx1ONV3vurdidqwAQL+pEc8sLcAe1CCvQ3YHxIW8Pl85xSWNC1hADDIv0rIE/o4J0k3kww4xSlwIhcq3EFFOm7KN/hUGOQkt0CFa5WpNJlMvxBEz/IVQAxg/ZRZl9wiHA63yDYieM7DnLP5CiAGsC7I5sgtYKJGWe2A8seFqgFJrJjEPY1Cn3pJ8/9W1e5VWsFDTEmFrBcoDhZJEQkXuhICMyKpjhahqN21hRYATKfUOlDmkygrR4o4C0VOLGJKrOITKB4jijzdXygBKixyC5TDQdnk/Pz8qRw6oOWGlsTKGOQW6OH6FBWsyePxdOXLTgxiyebILZCjz+GLgMIKnXNzc49YMlcRdHXcSwxFVgTInQhC9G33UhNoJLuqq6t345p9y3eUy8OTk5PjAHuI9uo4b07FBaOhsu0A4Unc+T1TU1Nj3KsSSE5yJ65jqF2DDd8QqWYmAZrIM2VlZTdnZmb6AbpdV9V6ec9znf5Q7HjYumdRE0JOp3MjitO4SFa+cZz8Umqe3TCbSLvdfkR/kWDdNQl5InuTcysOcpFT35ZrbBxx4p3JAHlZVVW1D/634VRt+FvLBgK/v5LV9WS+10xMTEwtRw7XvqOL+e2Q8V3AYIOIAXQ26/heWVnZCVfcyKHg2CBgTpmPmjYM8l24GyaUHyaIh7XwfR9ErE8qHoDfn2LTNAVC0HX6MFcBIP8Bi+6F6cdW/DICkANRfx99fEYFQ7Nph5i/uQiA214gno7K+guhaiKg9gC62+M8eR7XsBsYJ4ilam60Fb7r7uAj8wFyuwM1oIOWgfmDy6RXEEQzJMPe23DXrVS7rtyD3Df8z/FPgAEAzWU5Ku59ZAUAAAAASUVORK5CYII="</span>&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">      &lt;a href="/" class="logo logo-img-2x"&gt;</span><br><span class="line">        &lt;img width=<span class="string">"32"</span> height=<span class="string">"32"</span> title=<span class="string">""</span> alt=<span class="string">""</span> src=<span class="string">"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEQUM1QkUxRUI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEQUM1QkUxRkI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdGQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjgwQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+hfPRaQAAB6lJREFUeNrsW2mME2UYbodtt+2222u35QheoCCYGBQligIJgkZJNPzgigoaTEj8AdFEMfADfyABkgWiiWcieK4S+QOiHAYUj2hMNKgYlEujpNttu9vttbvdw+chU1K6M535pt3ubHCSyezR+b73eb73+t7vrfXsufOW4bz6+vom9/b23ovnNNw34b5xYGAgODg46Mbt4mesVmsWd1qSpHhdXd2fuP/Afcput5/A88xwymcdBgLqenp6FuRyuWV4zu/v759QyWBjxoz5t76+/gun09mK5xFyakoCAPSaTCazNpvNPoYVbh6O1YKGRF0u13sNDQ27QMzfpiAAKj0lnU6/gBVfAZW2WWpwwVzy0IgP3G73FpjI6REhAGA9qVRqA1b9mVoBVyIC2tDi8Xg24+dUzQiAbS/s7Ox8G2o/3mKCC+Zw0efzPQEfcVjYrARX3dbV1bUtHo8fMgt42f+Mp0yUTVQbdWsAHVsikdiHkHaPxcQXQufXgUBgMRxme9U0AAxfH4vFvjM7eF6UkbJS5qoQwEQGA57Ac5JllFyUVZZ5ckUEgMVxsK2jlSYzI+QXJsiyjzNEAJyJAzb/KQa41jJKL8pODMQiTEAymXw5n8/P0IjD3bh7Rgog59aanxiIRTVvV/oj0tnHca/WMrVwODwB3raTGxzkBg/gnZVapFV62Wy2n5AO70HM/5wbJ0QnXyQSaVPDIuNZzY0V3ntHMwxiwHA0Gj2Np7ecIBDgaDAYXKCQJM1DhrgJ3nhulcPbl8j4NmHe46X/g60fwbz3aewjkqFQaAqebWU1AOqyQwt8Id6qEHMc97zu7u7FGGsn7HAiVuosVw7P35C1nccdgSCxop1dHeZswmfHMnxBo6ZTk+jN8dl/vF7vWofDsa+MLN9oEUBMxOb3+1eoEsBVw6Zmua49r8YmhAKDiEPcMwBsxMiqQ+ixzPFxZyqRpXARG/YOr1ObFJ0gUskXBbamcR1OKmMUvDxHRAu8/LmY3jFLMUpFqz9HxG65smYJdyKyECOxDiEAe/p1gjF2oonivZAsxVgl2daa4EQWCW6J55qFAFFZiJWYLxNQy2qOSUzGRsyXCUDIeliwAHEO4WSlWQBRFoZakXcKmCXmyXAKs0Ve9vl8q42WoIYpJU4hV3hKcNs8m9gl7p/xQ73eF5kB4j5mNrWmTJRNwAzqiV1CxjVTZCIkEq+Z1bZFZSN2CenmVAFVy4Plz8xKAGWjjAKFk6lCBMDR/MJjLLMSQNm43xAiQKTaA+9/wewhDjL+JVI1kkTSSOTcKbMTwPqESAot6dn6Fr1gHwVJju6IRuyiByPuUUBAg5DGkAgBmxlvdgIEK9gDkohdY/BJo4CAG0R8miRSsGABkgVQs4KXu098IgUXSSRsFAoKZiVAVDY2WUiiPTjYRi41KwGisrGsLtlsth8Fiwnz2fBkQvWfRtlE3iF2yW63/yCacXZ1dW02GwGyTFaRd4idJnCKHRaCxYRHoG5LTKT6SyiToP1fJHbmAYPYRR0UnZQtMnA6s0zg+GZBlt0Gdo7EPHgpE3Q6nZ8YyLhc8Xj8MJh/aKTAY+5FPAKHLE7RdwuYJZmNwzyCMkBCYyKROJBMJl9B/PXXCjjmCmDOVzH3fiPpObEWGqoKe4EBl8v1hlqsdLvd23mkxHM9pc9kMpmno9HoeTii7ewbHEZPPx1ztLS1tV3AnGuMjiNjvbQFuHw6zDo5By7dTPAQNBgMLrRarTkSls1mnwT7uwp9virx9QzbW/HuV/j5d/b+6jniKlllP8lkeONJDk+dq9GsQTnC4fB1heO0K47Hwe7WdDr9nAKgXwOBwHI+C45Htj1d6sd429TUNEcmUdc+PRaLHcvn87dXW4ugzdsaGxufL94NFv9zi1J7GVbhlvb2dnaJ3SVrxfc+n2+NTsZ7/H7/Mr3g5XdSIHyJSH1PZ+7fToyl2+ErqilgZ4NaLYB9goVGaHjR93Hv1ZrU4XDsFT20kH3PObzbWk0CgG1jacVIUnAQb9F+VexyLMzkpcLv0IJV7AHQIOCAUYHx7v5qgScmYHtTqSAyZLEJTK22Bie4iq3xsqpm4SAf9Hq9a2DnJ4uLK3SEULcdRvp3i3zHySqpficxEdsQc1NrlYXXvR+O7qASSezXB+h1SuUomgg9LL8BUoV4749EIolKh+EiqWmqVEZlDgHks2pxHw7xTqUQw9J5NcAXOK10AGIoZ6Zli6JY6Z1Q461KoZ4NiKLHarW+KDsxlDUPHZ5zPQZqUVDPJsTqb5n9malbpAh8C2XXDLl62+WZIDFRUlNVOiwencnNU3aQEkL+cDMSoLvZo2fQB7AJssNAuFuvorlDVVkkg2I87+jo2K2QAVphDrfyViK5VqtO34OkaxXCp+7drdDBCAdubm6eidX+2WwqT5komwh4YQLk+H4aE93h8Xg2gvHekQZOGSgLZTLyDTLJ4Lx9/KZWKBSainT4Iy3FqQBfnUZR42PKQFksBr9QKVXCPusD3OiA/RkQ5kP8qV/Jl1WywAp/6+dcmPM2zL1UrUahe4JqfnWWKXIul3uUbfP8njAFLW1OFr3gdFtZ72cNH+PtQT7/brW+NXqJAHh0y9V8/U/A1U7AfwIMAD7mS3pCbuWJAAAAAElFTkSuQmCC"</span>&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>References:<br>[1] Wayne Folta. <em>Nested Cross Validation: When Cross Validation Isn’t Enough.</em> Oct. 2017. URL: <a href="https://www.elderresearch.com/blog/nested-cross-validation" target="_blank" rel="noopener">https://www.elderresearch.com/blog/nested-cross-validation</a>.<br>[2] scikit-learn.org. <em>Nested versus non-nested cross-validation</em>. June 2019. URL: <a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_nested_cross_validation_iris.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/auto_examples/model_selection/plot_nested_cross_validation_iris.html</a>.<br>[3] 行走的程序猿. <em>cross validation - 机器学习中的交叉验证法探究</em>. May 2018. URL: <a href="https://www.jianshu.com/p/cdf6df99b44b" target="_blank" rel="noopener">https://www.jianshu.com/p/cdf6df99b44b</a>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cross Validation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark编程指南</title>
      <link href="/Spark-Programming-Tutorial/"/>
      <url>/Spark-Programming-Tutorial/</url>
      
        <content type="html"><![CDATA[<p>Spark编程指南、API文档：  <a href="https://spark.apache.org/docs/latest/#spark-overview" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/#spark-overview</a><br><a id="more"></a></p><h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><p>Spark支持的文件读写来源有：文件系统(本地文件系统、HDFS、远程Amazon S3)、数据库(MySQL、HBase、Hive)<br>SPark支持支持很多其他常见的文件格式：文本文件、JSON、CSV、SequenceFile，以及protocol buffer<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/1136325-20170915111603547-1070150402.png"></p><h2 id="读取本地文件系统"><a href="#读取本地文件系统" class="headerlink" title="读取本地文件系统"></a>读取本地文件系统</h2><p>要加载本地文件，必须采用<code>file:///</code>开头的这种格式;<br><code>Spark 将传入的路径作为目录对待，会在那个目录下输出多个文件</code><br>如果路径简写为<code>path/to/somewhere</code>，<code>sc.textFile()</code>将默认认为其为HDFS路径<br></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">myRdd = sc.textFile(<span class="string">"file:///home/holden/repos/spark/README.md"</span>) <span class="comment">#读取本地文本文件</span></span><br><span class="line"></span><br><span class="line">outputFile = <span class="string">"file:///home/holden/repos/spark/result.txt"</span> <span class="comment"># 保存为本地文本文件</span></span><br><span class="line">myRdd.saveAsTextFile(outputFile)</span><br><span class="line"></span><br><span class="line">myRdd = sc.textFile(<span class="string">"hdfs://master:9000/user/root/people.txt"</span>) <span class="comment"># 从HDFS加载数据</span></span><br><span class="line"></span><br><span class="line">myRdd = sc.textFile(<span class="string">"s3://your_bucket/"</span>) <span class="comment"># 从 AWS s3 加载数据</span></span><br><span class="line">myRDD.saveAsTextFile(<span class="string">"s3://your_bucket/test/"</span>)  <span class="comment"># 将数据保存到 AWS s3</span></span><br><span class="line"></span><br><span class="line">jsonRdd = sc.textFile(<span class="string">"file:///usr/local/people.json"</span>) <span class="comment"># 加载JSON文件</span></span><br><span class="line"></span><br><span class="line">myRdd = sc.read.format(<span class="string">'csv'</span>)</span><br><span class="line">               .options(header=<span class="string">'true'</span>, inferSchema=<span class="string">'true'</span>)</span><br><span class="line">               .load(<span class="string">'/diamonds.csv'</span>) <span class="comment"># 读取CSV文件</span></span><br><span class="line"></span><br><span class="line">df.write.parquet(<span class="string">"output/proto.parquet"</span>)</span><br><span class="line"><span class="comment"># using SQLContext to read parquet file</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SQLContext</span><br><span class="line">sqlContext = SQLContext(sc)</span><br><span class="line"></span><br><span class="line">df = sqlContext.read.parquet(<span class="string">"output/proto.parquet"</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><p><a href="https://hadoop.apache.org/docs/r1.2.1/file_system_shell.html" target="_blank" rel="noopener">File System Shell Guide</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala刚刚入门的学习笔记</title>
      <link href="/Hello-Scala/"/>
      <url>/Hello-Scala/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="http://twitter.github.io/scala_school/basics.html" target="_blank" rel="noopener">Basics</a></strong>：Values, functions, classes, methods, inheritance, try-catch-finally. Expression-oriented programming<br><strong><a href="http://twitter.github.io/scala_school/basics2.html" target="_blank" rel="noopener">Basics continued</a></strong>：Case classes, objects, packages, apply, update, Functions are Objects (uniform access principle), pattern matching.<br><strong><a href="http://twitter.github.io/scala_school/collections.html" target="_blank" rel="noopener">Collections</a></strong>：Lists, Maps, functional combinators (map, foreach, filter, zip, folds)<br><strong><a href="http://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html" target="_blank" rel="noopener">Pattern matching &amp; functional composition</a></strong>：More functions! PartialFunctions, more Pattern Matching<br><strong><a href="http://twitter.github.io/scala_school/type-basics.html" target="_blank" rel="noopener">Type &amp; polymorphism basics</a></strong>：Basic Types and type polymorphism, type inference, variance, bounds, quantification<br><strong><a href="http://twitter.github.io/scala_school/advanced-types.html" target="_blank" rel="noopener">Advanced types</a></strong>: Advanced Types, view bounds, higher-kinded types, recursive types, structural types<br><strong><a href="http://twitter.github.io/scala_school/sbt.html" target="_blank" rel="noopener">Simple Build Tool</a>:</strong> All about SBT, the standard Scala build tool<br><strong><a href="http://twitter.github.io/scala_school/coll2.html" target="_blank" rel="noopener">More collections</a></strong>: Tour of the Scala Collections library<br><strong><a href="http://twitter.github.io/scala_school/specs.html" target="_blank" rel="noopener">Testing with specs</a></strong>:<br><strong><a href="http://twitter.github.io/scala_school/concurrency.html" target="_blank" rel="noopener">Concurrency in Scala</a>:</strong> Runnable, Callable, threads, Futures<br><strong><a href="http://twitter.github.io/scala_school/java.html" target="_blank" rel="noopener">Java + Scala</a></strong>: Java interop: Using Scala from Java<br><strong><a href="http://twitter.github.io/scala_school/finagle.html" target="_blank" rel="noopener">An introduction to Finagle</a></strong>: Finagle primitives: Future, Service, Filter, Builder<br><strong><a href="http://twitter.github.io/scala_school/searchbird.html" target="_blank" rel="noopener">Searchbird</a></strong>: Building a distributed search engine using Finagle</p><p><strong><a href="http://twitter.github.io/scala_school/" target="_blank" rel="noopener">Scala School!</a></strong><br><a href="https://www.52cs.com/archives/3077" target="_blank" rel="noopener">一个简洁的scala快速教程</a><br><a href="http://dblab.xmu.edu.cn/blog/spark/" target="_blank" rel="noopener">子雨大数据之Spark入门教程（Scala版）</a><br><a href="https://www.runoob.com/scala/scala-tutorial.html" target="_blank" rel="noopener">Scala 教程|菜鸟教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然常数e到底自然在哪？</title>
      <link href="/Euler-number/"/>
      <url>/Euler-number/</url>
      
        <content type="html"><![CDATA[<p>自然常数$e$是一个奇妙的数字，这里的$e$并不仅仅代表一个字母，它还是一个数学中的无理常数，约等于2.718281828459。<br>但你是否有想过，它到底怎么来的呢？为啥一个无理数却被人们称之为“自然常数”？<br></p><a id="more"></a><p>说到$e$，我们会很自然地想起另一个无理常数$\pi$。$\pi$的含义可以通过下图中的内接与外切多边形的边长逼近来很形象的理解。<br><img alt="图片来源: betterexplained" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/641.jfif"></p><p>假设一个圆的直径为1，其外切与内接多边形的周长可以构成$\pi$ 的估计值的取值范围上下限，内接与外切多边形的边越多，取值范围就越窄，只要边数足够多，取值范围上下限就可以越来越逼近圆周率$\pi$ 。</p><p>如果说$\pi$ 的计算很直观，那$e$呢？所以在此也用一种图解法来直观理解e。</p><p>首先，我们需要知道e 这个表示自然底数的符号是由瑞士数学和物理学家Leonhard Euler(莱昂纳德·欧拉)命名的，取的正是Euler的首字母“e ”。</p><p><img alt="Leonhard Euler (1707-1783)" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/640.jpg"><br>但实际上，第一个发现这个常数的，并非欧拉本人，而是雅可比·伯努利（Jacob Bernoulli）。</p><p><img alt="伯努利家族" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/641.jpg"></p><p>伯努利家族是17〜18世纪瑞士的一个赫赫有名的家族，其中出了很多著名的数理科学家，雅可比·伯努利是约翰·伯努利（Johann Bernoulli）的哥哥，而约翰·伯努利则是欧拉的数学老师。总之，大佬们之间有着千丝万缕的联系。<br></p><p>要了解e 的由来，一个最直观的方法是引入一个经济学名称“<span style="color:red"><strong>复利(Compound Interest)</strong></span>”。</p><blockquote><p><strong>复利率法</strong>（英文：compound interest），是一种计算利息的方法。按照这种方法，利息除了会根据本金计算外，新得到的利息同样可以生息，因此俗称“利滚利”、“驴打滚”或“利叠利”。只要计算利息的周期越密，财富增长越快，而随着年期越长，复利效应亦会越为明显。—— 维基百科</p></blockquote><p>在引入“<strong>复利模型</strong>”之前，先试着看看更基本的 “指数增长模型”。</p><p>我们知道，大部分细菌是通过二分裂进行繁殖的，假设某种细菌1天会分裂一次，也就是一个增长周期为1天，如下图，这意味着：<strong>每一天，细菌的总数量都是前一天的两倍</strong>。<br><img alt="(图片来源: betterexplained)" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510111844.png"></p><p>显然，如果经过$x$天（或者说，经过个增长周期）的分裂，就相当于翻了$x$倍。在第$x$天时，细菌总数将是初始数量的$2x$倍。如果细菌的初始数量为1，那么$x$天后的细菌数量即为$2x$：</p><script type="math/tex; mode=display">\mathbf{细菌数量}=2^{x}</script><p>如果假设初始数量为$K$，那么$x$天后的细菌数量则为$K\cdot 2x$：</p><script type="math/tex; mode=display">\mathbf{细菌数量}=K\cdot 2^{x}</script><p>因此，只要保证所有细菌一天分裂一次，不管初始数量是多少，最终数量都将是初始数量的2x 倍。因此也可以写为：</p><script type="math/tex; mode=display">Q=2^{x}</script><p>上式含义是：<strong>第$x$天时，细菌总数量是细菌初始数量的$Q$倍</strong>。</p><p>如果将 “<strong>分裂</strong>”或“<strong>翻倍</strong>”换一种更文艺的说法，也可以说是：“<strong>增长率为100%</strong>”。那我们可以将上式写为：</p><script type="math/tex; mode=display">Q=(1+100 \%)^{x}</script><p>当增长率不是100%，而是50%、25%之类的时候，则只需要将上式的100%换成想要的增长率即可。这样就可以得到更加普适的公式：</p><script type="math/tex; mode=display">Q=(1+r)^{x}</script><p><strong>这个公式的数学内涵是</strong>：<span style="color:red"><strong>一个增长周期内的增长率为$r$，在增长了$x$个周期之后，总数量将为初始数量的$Q$倍</strong></span>。</p><p>以上为指数增长的简单实例，下面来看看雅可比·伯努利的发现：</p><p>假设你有1元钱存在银行里，此时发生了严重的通货膨胀，银行的利率飙到了100%（夸张一下，为了方便计算）。如果银行一年付一次利息，自然在一年后你可以拿到1元的本金（蓝色圆）和1元的利息（绿色圆），总共两元的余额。<br><img alt="(图片来源: betterexplained)" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112331.png"><br>现在银行的年利率不变，但银行为了招揽客户，推出一项惠民政策，每半年就付一次利息。那么到第六个月的时候，你就能够提前从银行拿到0.5元的利息了。<br><img alt="(图片来源: betterexplained)" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112343.png"></p><p>机智的你会马上把这0.5元的利息再次存入银行，这0.5元的利息也将在下一结算周期产生利息(红色圆)，专业术语叫“复利”，那么年底的存款余额将等于2.25元。<br><img alt="(图片来源: betterexplained)" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112351.png"></p><p>此时，我们可以换个角度这样看：即，每个结算（增长）周期为半年，每半年的利率是50%（或者说100%/2），一年结算两次利息，且第一次结算完后，立马将利息存入。此时我们的计算公式和结果如下：</p><script type="math/tex; mode=display">Q=\left(1+\frac{100 \%}{2}\right)^{2}=2.25</script><p>继续，假设现在银行为了和其他银行抢生意，短期不想赚钱了，每四个月就付一次利息！而机智的你依然一拿到利息就立马存入，与半年结算一次利息类似：即，每个结算周期为四个月，每四个月的利率是33.33%（或者说100%/3），一年结算三次利息，且前两次结算完后，都立马将所有利息存入。<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112417.png"></p><p>此时计算公式和结果如下：</p><script type="math/tex; mode=display">Q=\left(1+\frac{100 \%}{3}\right)^{3} \approx 2.37037</script><p>我的天，年利率虽然没有变，但随着每年利息交付次数的增加，你年底能从银行拿到的钱居然也在增加！</p><p>那么是不是会一直增大到无穷大呢？想得倒美…</p><p>现在假设存款人和银行都疯了，银行在保证年利率为100%的前提下连续不断地付给存款人利息，存款人天天呆在银行不走，拿到利息就往银行里存。这样，所得利息即所谓“<span style="color:red"><strong>连续复利</strong></span>”。</p><p>但是，你会发现，似乎有一个“天花板”挡住了你企图靠1块钱疯狂赚取1个亿的小目标，这个“天花板”就是$e$ ！<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112410.jpg"></p><p>如果，我们进行一系列的迭代运算，我们将看到以下结果：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112404.png"><br>其中，$n$指的是一年中结算利息的次数。</p><p>只要在年利率保持100%不变的情况下，不断地提高利息的结算次数，余额就将会逼近$e$=2.718281845…</p><p>然后，终于可以祭出这个高等数学微积分里计算$e$的一个重要极限了：</p><script type="math/tex; mode=display">e = \mathop {\lim }\limits_{n \to \infty } \left( {1 + \frac{1}{n}} \right)^n</script><p>现在再回头看这个重要极限，想必会有更加直观的理解。</p><p>也就是说，就算银行的年利率是100%，再怎么求银行给你“复利”，年底也不可能得到超过本金e 倍的余额。况且，我是没见过哪个银行的年利率是100%。</p><p>虽然正常的银行不会推出连续复利这种优惠政策，但在自然界中，大多数事物都处在一种“无意识的连续增长”状态中。对于一个连续增长的事物，如果单位时间的增长率为100%，那么经过一个单位时间后，其将变成原来的$e$倍。生物的生长与繁殖，就也类似于“利滚利”的过程。</p><p>再比如，在等角螺线中：<br><img alt="等角螺线" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112358.png"></p><p>如果用极坐标表示，其通用数学表达式为：</p><script type="math/tex; mode=display">r=a \cdot e^{b \cdot \theta}</script><p>其中，$a$、$b$ 为系数，$r$ 螺线上的点到坐标原点的距离，$θ$ 为转角。这正是一个以自然常数$e$为底的指数函数。</p><p>例如，鹦鹉螺外壳切面就呈现优美的等角螺线：<br><br>热带低气压的外观也像等角螺线：<br><br>就连旋涡星系的旋臂都像等角螺线：<br></p><p>或许这也是e 被称为“<span style="color:red"><strong>自然常数</strong></span>”的原因吧。当然，自然常数e 的奇妙之处还远不止这些，一本书都写不完。</p><p><strong>Good References:</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/yAZiYYJBUJuesBCTUL_tBg" target="_blank" rel="noopener">自然常数e到底自然在哪？|科研狗</a></li><li><a href="https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/" target="_blank" rel="noopener">An Intuitive Guide To Exponential Functions &amp; e</a></li><li><a href="https://betterexplained.com/articles/prehistoric-calculus-discovering-pi/" target="_blank" rel="noopener">Prehistoric Calculus: Discovering Pi</a></li><li><a href="https://en.wikipedia.org/wiki/Compound_interest" target="_blank" rel="noopener">Compound interest</a></li><li><a href="https://en.wikipedia.org/wiki/Leonhard_Euler" target="_blank" rel="noopener">Leonhard Euler</a></li><li><a href="https://en.wikipedia.org/wiki/Logarithmic_spiral" target="_blank" rel="noopener">Logarithmic spiral</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然常数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过反向代理远程访问内网主机</title>
      <link href="/How-to-access-intranet-hosts-with-reverse-proxy/"/>
      <url>/How-to-access-intranet-hosts-with-reverse-proxy/</url>
      
        <content type="html"><![CDATA[<p>首先一定需要一台固定IP的服务器做转发代理，而且保证我们需要连接的目标主机能够通过SSH连接这台主机。原理在这里</p><p><strong>2019年5月7日19:00:39 更新 目前已发现一款优秀的开源反向代理软件<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">FRP</a>，使用体验很稳定，已经基本抛弃ssh进行命令行操作的方式，ssh的方式很不稳定。</strong></p><a id="more"></a><h1 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h1><p>分为Server端配置和Client配置，详见frp readme。</p><h2 id="配合Supervisor守护FRP"><a href="#配合Supervisor守护FRP" class="headerlink" title="配合Supervisor守护FRP"></a>配合Supervisor守护FRP</h2><p>使用Supervisor来做进程的监控，让服务器重启或者FRP down掉之后还能自动重新连接</p><p>安装Supervisor：<code>sudo apt install supervisor</code><br>编辑FRP client的配置文件：<code>vim /etc/supervisord.d/frpc.ini</code>：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[program:frps]</span><br><span class="line">command = ./frp_0.24.1_linux_amd64/frpc -c ./frp_0.24.1_linux_amd64/frpc.ini</span><br><span class="line">autostart = true</span><br></pre></td></tr></tbody></table></figure><p></p><p>重启Supervisor后配置生效：<code>sudo service supervisord restart</code></p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>主要使用命令如下：</p><h2 id="在目标主机上执行如下命令："><a href="#在目标主机上执行如下命令：" class="headerlink" title="在目标主机上执行如下命令："></a>在目标主机上执行如下命令：</h2><p><code>ssh -fCNR B_port:localhost:22 B_username@B_IP</code><br>其中<code>B_username</code>表示代理服务器的用户名，<code>B_IP</code>表示代理服务器IP地址，<code>B_port</code>表示与目标主机建立直接转发连接的代理服务器端口，这里我使用的是代理服务器1234端口，<strong>某些云主机还需要添加安全规则使B_port能够被外网访问</strong></p><p>测试转发连接是否建立成功：<br><strong>在代理服务器上查看<code>ss -ant</code> ：</strong><br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180729122546729"></p><p>在目标主机上查看 <code>ps aux | grep ssh</code> ：<br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180729123244214"></p><h2 id="在代理服务器上执行如下命令"><a href="#在代理服务器上执行如下命令" class="headerlink" title="在代理服务器上执行如下命令:"></a>在代理服务器上执行如下命令:</h2><p><code>ssh -fCNL *:1235:localhost:1234 localhost</code></p><h2 id="稳定方式"><a href="#稳定方式" class="headerlink" title="稳定方式"></a>稳定方式</h2><p>在目标主机上运行：<code>autossh -M 1235 -NR 1234:localhost:22 ubuntu@193.112.140.**</code>，意思是在中转主机上的端口<code>1235</code>上建立监听，保持连接。</p><p>然后我们在本地就可以通过ssh，经过代理服务器转发来登陆远程内网服务器了：<br><code>ssh -p 1235 A_username@B_IP</code><br>其中A_username是目标主机的用户名</p><p>References:<br><a href="https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html" target="_blank" rel="noopener">https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark学习笔记之Broadcast Join性能调优</title>
      <link href="/Spark-Performance-Tuning-with-Broadcast-Join/"/>
      <url>/Spark-Performance-Tuning-with-Broadcast-Join/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache() or not Cache() in Spark, 这是一个价值百万的问题</title>
      <link href="/Data-Persistence-in-Spark/"/>
      <url>/Data-Persistence-in-Spark/</url>
      
        <content type="html"><![CDATA[<p>Spark一个重要的功能就是将RDD持久化到内存中。当对RDD进行持久化操作时，每个节点都会将自己操作的RDD的partition持久化到内存中，并在之后对RDD的反复使用中，直接使用内存中缓存的partition。这样的话，对于一个RDD反复执行的操作场景中，就只需要对RDD计算一次即可，而不需要反复计算RDD。巧妙使用RDD持久化,甚至在某种场景下，可以将Spark应用程序性能提升10倍。对于迭代式算法和快速交互应用来说，RDD的持久化是非常必要的。<br><a id="more"></a></p><p>要持久化一个RDD，只需要调用RDD的cache()或者persist()方法即可。在该RDD第一次被计算出来时，就会直接缓存到每个节点中。而且Spark的持久化机制还是自动容错的，如果持久化的RDD的任何partition丢失了，那么Spark会自动通过其源RDD,使用transformation操作重新计算该partition。</p><p>Spark自己在shuffle过程中，会进行数据的持久化，比如写在磁盘中，主要是为了在节点失败时，避免需要重新计算整个过程。</p><h1 id="cache-和presist-的区别"><a href="#cache-和presist-的区别" class="headerlink" title="cache()和presist()的区别"></a>cache()和presist()的区别</h1><p>Spark提供了5中等级的持久化存储级别</p><ul><li>MEMORY_ONLY</li><li>MEMORY_ONLY_SER</li><li>MEMORY_AND_DISK</li><li>MEMORY_AND_DISK_SER</li><li>DISK_ONLY</li></ul><p>cache()和presist()的区别在于，cache()是persist()的一种简化方式，<code>cache()</code>的底层就是调用persist()的无参版本，即调用<code>persist(StorageLevel.MEMORY_ONLY)</code>,将数据持久化到内存中。如果需要从内存中清除缓存，那么可以使用<code>unpersist()</code>方法。</p><div class="table-container"><table><thead><tr><th style="text-align:center">cache()=persist(StorageLevel.MEMORY_ONLY)</th><th style="text-align:center">persist(StorageLevel.MEMORY_AND_DISK)</th></tr></thead><tbody><tr><td style="text-align:center"><img alt="MEMORY_ONLY" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/ekNcE.png"></td><td style="text-align:center"><img alt="MEMORY_AND_DISK" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/cjD3K.png"></td></tr></tbody></table></div><h1 id="什么时候应该持久化RDD或DataFrame？"><a href="#什么时候应该持久化RDD或DataFrame？" class="headerlink" title="什么时候应该持久化RDD或DataFrame？"></a>什么时候应该持久化RDD或DataFrame？</h1><p>在以下情况下，你绝对应该<code>cache()</code>RDD或DataFrame：</p><ul><li>在一个迭代循环中重复使用它们时，一定要cache()（ie. 机器学习算法中）</li><li>在某个应用、任务中，一个RDD或DataFrame复用两次及以上的，一定要cache，避免不必要的重复计算。</li><li>当重新计算生成RDD或DataFrame的成本很高时，请记住cache()（即HDFS，在一组复杂的map()，filter()等之后）如果Worker节点死亡，这有助于恢复过程。</li></ul><p>要记住的是，当Worker节点内存不够用时，Spark将以LRU方式自动从Workers中替换RDD分区，并且这种替换在每个Worker上是独立发生。</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/DInZf.png"></p><p><a href="https://stackoverflow.com/questions/26870537/what-is-the-difference-between-cache-and-persist" target="_blank" rel="noopener">What is the difference between cache and persist?</a><br><a href="https://www.jianshu.com/p/0b2ea4cfdc8a" target="_blank" rel="noopener">spark 数据持久化与释放</a><br><a href="https://unraveldata.com/to-cache-or-not-to-cache/" target="_blank" rel="noopener">TO CACHE OR NOT TO CACHE, THAT’S THE MILLION DOLLAR QUESTION</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置ssh密钥登录与别名登录</title>
      <link href="/ssh-login-without-passwd/"/>
      <url>/ssh-login-without-passwd/</url>
      
        <content type="html"><![CDATA[<p>通常我们在 Termianl 下用 ssh 链接远程主机的时候，每次都需要输入一长串的用户名加主机地址，是不是觉得很麻烦？那么好吧，这个 Tips 也需能帮你解决这一烦恼，让你通过密钥甚至别名快速登录远程主机。<br><a id="more"></a></p><h1 id="通过密钥登录"><a href="#通过密钥登录" class="headerlink" title="通过密钥登录"></a>通过密钥登录</h1><h2 id="查看local有没有公钥"><a href="#查看local有没有公钥" class="headerlink" title="查看local有没有公钥"></a>查看local有没有公钥</h2><p><code>ls ~/.ssh/</code><br><img alt="ls ~/.ssh/" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180816111251441"></p><p>如果local没有公钥的话需要生成公钥<br><code>ssh-keygen</code>：产生公钥与私钥对<br><img alt="ssh-keygen" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-05-04-16-51-01.png"></p><h2 id="将公钥上传给主机"><a href="#将公钥上传给主机" class="headerlink" title="将公钥上传给主机"></a>将公钥上传给主机</h2><p><code>ssh-copy-id</code> 将本机的公钥复制到目的机器的authorized_keys文件中<br>使用方式为：<code>ssh-copy-id -i .ssh/id_rsa.pub name@193.112.x.xxx</code><br><img alt="ssh-copy-id" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-05-04-16-31-52.png"><br>我这里多出来的-oPort=xxxx参数是因为我配置了反向代理，所以需要指定登录端口号。</p><h2 id="登录到远程机器不用输入密码"><a href="#登录到远程机器不用输入密码" class="headerlink" title="登录到远程机器不用输入密码"></a>登录到远程机器不用输入密码</h2><p>直接使用命令：<code>ssh hailin@193.112.x.xxx -oPort=xxxx</code></p><h1 id="配置ssh别名登录"><a href="#配置ssh别名登录" class="headerlink" title="配置ssh别名登录"></a>配置ssh别名登录</h1><p><code>vi ~/.ssh/config</code><br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180809175741834"><br>登录到远程机器使用简短的别名：<br><code>ssh GPU</code><br><code>ssh cloud</code><br>即可登录！</p><p><a href="https://blog.csdn.net/yanzhibo/article/details/75804619" target="_blank" rel="noopener">https://blog.csdn.net/yanzhibo/article/details/75804619</a><br><a href="https://blog.csdn.net/superbfly/article/details/66970114" target="_blank" rel="noopener">https://blog.csdn.net/superbfly/article/details/66970114</a><br><a href="https://stackoverflow.com/questions/48328446/id-rsa-pub-file-ssh-error-invalid-format" target="_blank" rel="noopener">https://stackoverflow.com/questions/48328446/id-rsa-pub-file-ssh-error-invalid-format</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终端复用神器Tmux</title>
      <link href="/Tmux/"/>
      <url>/Tmux/</url>
      
        <content type="html"><![CDATA[<p>Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机；是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。<br><a id="more"></a><br>1）Tmux功能：</p><ul><li>提供了强劲的、易于使用的命令行界面。</li><li>可横向和纵向分割窗口。</li><li>窗格可以自由移动和调整大小，或直接利用四个预设布局之一。</li><li>支持 UTF-8 编码及 256 色终端。</li><li>可在多个缓冲区进行复制和粘贴。</li><li>可通过交互式菜单来选择窗口、会话及客户端。</li><li>支持跨窗口搜索。</li><li>支持自动及手动锁定窗口。</li></ul><p>2）Tmux安装<br>a）ubuntu版本下直接apt-get安装</p><blockquote><p>sudo apt-get install tmux</p></blockquote><p>b）在Mac OS中安装</p><blockquote><p>brew install tmux</p></blockquote><h1 id="Tmux-快捷键-amp-速查表"><a href="#Tmux-快捷键-amp-速查表" class="headerlink" title="Tmux 快捷键 &amp; 速查表"></a>Tmux 快捷键 &amp; 速查表</h1><p>启动新会话：</p><pre><code>tmux [new -s 会话名 -n 窗口名]</code></pre><p>恢复会话：</p><pre><code>tmux at [-t 会话名]</code></pre><p>列出所有会话：</p><pre><code>tmux ls</code></pre><p><a name="killSessions"></a>关闭会话：</p><pre><code>tmux kill-session -t 会话名orTMUX Prefix (e.g. ctrl+b) + :kill-session</code></pre><p><a name="killAllSessions"></a>关闭所有会话：</p><pre><code>tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill</code></pre><h1 id="在-Tmux-中，按下-Tmux-前缀-ctrl-b，然后："><a href="#在-Tmux-中，按下-Tmux-前缀-ctrl-b，然后：" class="headerlink" title="在 Tmux 中，按下 Tmux 前缀 ctrl+b，然后："></a>在 Tmux 中，按下 Tmux 前缀 <code>ctrl+b</code>，然后：</h1><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><pre><code>:new&lt;回车&gt;  启动新会话s           列出所有会话$           重命名当前会话</code></pre><h2 id="窗口-标签页"><a href="#窗口-标签页" class="headerlink" title="窗口 (标签页)"></a><a name="WindowsTabs"></a>窗口 (标签页)</h2><pre><code>c  创建新窗口w  列出所有窗口n  后一个窗口p  前一个窗口f  查找窗口,  重命名当前窗口&amp;  关闭当前窗口</code></pre><h2 id="调整窗口排序"><a href="#调整窗口排序" class="headerlink" title="调整窗口排序"></a>调整窗口排序</h2><pre><code>swap-window -s 3 -t 1  交换 3 号和 1 号窗口swap-window -t 1       交换当前和 1 号窗口move-window -t 1       移动当前窗口到 1 号</code></pre><h2 id="窗格（分割窗口）"><a href="#窗格（分割窗口）" class="headerlink" title="窗格（分割窗口）"></a><a name="PanesSplits"></a>窗格（分割窗口）</h2><pre><code>%  垂直分割"  水平分割o  交换窗格x  关闭窗格⍽  左边这个符号代表空格键 - 切换布局q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格{ 与上一个窗格交换位置} 与下一个窗格交换位置z 切换窗格最大化/最小化</code></pre><h2 id="同步窗格"><a href="#同步窗格" class="headerlink" title="同步窗格"></a><a name="syncPanes"></a>同步窗格</h2><p>这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setw synchronize-panes</span><br></pre></td></tr></tbody></table></figure><p>你可以指定开或关，否则重复执行命令会在两者间切换。<br>这个选项值针对某个窗口有效，不会影响别的会话和窗口。<br>完事儿之后再次执行命令来关闭。<a href="http://blog.sanctum.geek.nz/sync-tmux-panes/" target="_blank" rel="noopener">帮助</a></p><h2 id="调整窗格尺寸"><a href="#调整窗格尺寸" class="headerlink" title="调整窗格尺寸"></a>调整窗格尺寸</h2><p>如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：</p><pre><code>PREFIX : Alt + ↓          当前窗格向下扩大 1 格PREFIX : Alt + ↑          当前窗格向上扩大 1 格PREFIX : Alt + ←          当前窗格向左扩大 1 格PREFIX : Alt + →          当前窗格向右扩大 1 格PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格</code></pre><h2 id="文本复制模式："><a href="#文本复制模式：" class="headerlink" title="文本复制模式："></a>文本复制模式：</h2><p>按下<strong>前缀 [</strong>进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：</p><pre><code>setw -g mode-keys vi</code></pre><p>启用这条配置后，就可以使用 h、j、k、l 来移动光标了。</p><p>想要退出文本复制模式的话，按下回车键就可以了。一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。</p><p>例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。</p><pre><code>vi             emacs        功能^              M-m          反缩进Escape         C-g          清除选定内容Enter          M-w          复制选定内容j              Down         光标下移h              Left         光标左移l              Right        光标右移L                           光标移到尾行M              M-r          光标移到中间行H              M-R          光标移到首行k              Up           光标上移d              C-u          删除整行D              C-k          删除到行末$              C-e          移到行尾:              g            前往指定行C-d            M-Down       向下滚动半屏C-u            M-Up         向上滚动半屏C-f            Page down    下一页w              M-f          下一个词p              C-y          粘贴C-b            Page up      上一页b              M-b          上一个词q              Escape       退出C-Down or J    C-Down       向下翻C-Up or K      C-Up         向下翻n              n            继续搜索?              C-r          向前搜索/              C-s          向后搜索0              C-a          移到行首Space          C-Space      开始选中               C-t          字符调序</code></pre><h2 id="杂项："><a href="#杂项：" class="headerlink" title="杂项："></a>杂项：</h2><pre><code>d  退出 tmux（tmux 仍在后台运行）t  窗口中央显示一个数字时钟?  列出所有快捷键:  命令提示符</code></pre><h2 id="配置选项："><a href="#配置选项：" class="headerlink" title="配置选项："></a>配置选项：</h2><pre><code># 鼠标支持 - 设置为 on 来启用鼠标* setw -g mode-mouse off* set -g mouse-select-pane off* set -g mouse-resize-pane off* set -g mouse-select-window off# 设置默认终端模式为 256colorset -g default-terminal "screen-256color"# 启用活动警告setw -g monitor-activity onset -g visual-activity on# 居中窗口列表set -g status-justify centre# 最大化/恢复窗格unbind Up bind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmpunbind Downbind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp</code></pre><h2 id="配置文件（-tmux-conf）："><a href="#配置文件（-tmux-conf）：" class="headerlink" title="配置文件（~/.tmux.conf）："></a>配置文件（~/.tmux.conf）：</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础设置</span></span><br><span class="line"><span class="built_in">set</span> -g default-terminal <span class="string">"screen-256color"</span></span><br><span class="line"><span class="built_in">set</span> -g display-time 3000</span><br><span class="line"><span class="built_in">set</span> -g escape-time 0</span><br><span class="line"><span class="built_in">set</span> -g <span class="built_in">history</span>-limit 65535</span><br><span class="line"><span class="built_in">set</span> -g base-index 1</span><br><span class="line"><span class="built_in">set</span> -g pane-base-index 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前缀绑定 (Ctrl+a)</span></span><br><span class="line"><span class="built_in">set</span> -g prefix ^a</span><br><span class="line">unbind ^b</span><br><span class="line"><span class="built_in">bind</span> a send-prefix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割窗口</span></span><br><span class="line">unbind <span class="string">'"'</span></span><br><span class="line"><span class="built_in">bind</span> - splitw -v</span><br><span class="line">unbind %</span><br><span class="line"><span class="built_in">bind</span> | splitw -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选中窗口</span></span><br><span class="line"><span class="built_in">bind</span>-key k select-pane -U</span><br><span class="line"><span class="built_in">bind</span>-key j select-pane -D</span><br><span class="line"><span class="built_in">bind</span>-key h select-pane -L</span><br><span class="line"><span class="built_in">bind</span>-key l select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy-mode 将快捷键设置为 vi 模式</span></span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用鼠标(Tmux v2.1)</span></span><br><span class="line"><span class="built_in">set</span> -g mouse on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新配置文件</span></span><br><span class="line"><span class="built_in">bind</span> r <span class="built_in">source</span>-file ~/.tmux.conf \; display <span class="string">"已更新"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment"># Tmux Plugin Manager(Tmux v2.1)</span></span><br><span class="line"><span class="comment"># Tmux Resurrect</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-resurrect'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of plugins</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tpm'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-sensible'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Other examples:</span></span><br><span class="line"><span class="comment"># set -g @plugin 'github_username/plugin_name'</span></span><br><span class="line"><span class="comment"># set -g @plugin 'git@github.com/user/plugin'</span></span><br><span class="line"><span class="comment"># set -g @plugin 'git@bitbucket.com/user/plugin'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</span></span><br><span class="line">run <span class="string">'~/.tmux/plugins/tpm/tpm'</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br></pre></td></tr></tbody></table></figure><pre><code>Tmux (Local) → Ctrl+bTmux (Local) inside Tmux (ssh) → Ctrl+b+bTmux (Local) inside Tmux (ssh) inside Tmux (other ssh) → Ctrl+b+b+b+b</code></pre><p>References:<br><a href="https://www.cnblogs.com/kevingrace/p/6496899.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/6496899.html</a><br><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7" target="_blank" rel="noopener">https://gist.github.com/ryerh/14b7c24dfd623ef8edc7</a><br><a href="https://blog.fatedier.com/2015/12/18/terminal-multiplexer-tmux/" target="_blank" rel="noopener">终端利器 Tmux</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Spark计算TF-IDF</title>
      <link href="/Calculating-TF-IDF-With-Apache-Spark/"/>
      <url>/Calculating-TF-IDF-With-Apache-Spark/</url>
      
        <content type="html"><![CDATA[<h1 id="TF-IDF定义"><a href="#TF-IDF定义" class="headerlink" title="TF-IDF定义"></a>TF-IDF定义</h1><p>TF-IDF(Term Frequency-Inverse Document Frequency，逆文档词频)是一项广为人知的文本挖掘算法，这一算法为文档中的每一项词赋予一个<em>权重weight</em> ，在一篇文档当中如果一个词语出现的频率越高说明这个词语在这篇文档当中的重要性越高，但是如果该词语普遍出现在众多的文档的当中，说明该词语是一个常用词，对于文档的特点并不具有代表性，那么这个词语的重要性又应该降低。<br>因此我们用TF，Term Frequency来计算词语在文档当中出现的词频，其计算方式如下：</p><script type="math/tex; mode=display">TF(x) = \frac{某个词x在文章中出现的次数} {文档总词数}</script><p>而IDF(Inverse Document Frequency)表示逆向文件频率，来计算词语出现在了多少个文档当中，其计算方式如下：</p><script type="math/tex; mode=display">IDF(x) = log\frac{训练语料的总文档数}{出现词语x的文档数+1}</script><p>这里的+1是一个平滑操作，防止出现<code>除零</code>操作。<br>最终TF-IDF值就是TF与IDF的权衡结果：$TF-IDF(x) = TF(x) * IDF(x)$。</p><p>下面直接给出单机、Python版的TF-IDF程序和分布式的、PySpark版的TF-IDF程序：</p><figure class="highlight python"><figcaption><span> Python版TF-IDF程序</span><a href="/downloads/code/tfidf.py">view raw</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> stopwords</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> nltk.stem.porter <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _create_unverified_https_context = ssl._create_unverified_context</span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ssl._create_default_https_context = _create_unverified_https_context</span><br><span class="line"></span><br><span class="line">nltk.download()</span><br><span class="line"></span><br><span class="line">nltk.download(<span class="string">'punkt'</span>)</span><br><span class="line">nltk.download(<span class="string">'stopwords'</span>)</span><br><span class="line"></span><br><span class="line">text1 = <span class="string">"I heard about Spark and I love Spark"</span></span><br><span class="line"></span><br><span class="line">text2 = <span class="string">"I wish Java could use case classes'"</span></span><br><span class="line"></span><br><span class="line">text3 = <span class="string">"Logistic regression models are neat"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tokens</span><span class="params">(text)</span>:</span></span><br><span class="line">    lower = text.lower()</span><br><span class="line">    remove_punctuation_map = dict((ord(char), <span class="literal">None</span>) <span class="keyword">for</span> char <span class="keyword">in</span> string.punctuation)</span><br><span class="line">    no_punctuation = lower.translate(remove_punctuation_map)</span><br><span class="line">    tokens = nltk.word_tokenize(no_punctuation)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tokens</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stem_tokens</span><span class="params">(tokens, stemmer)</span>:</span></span><br><span class="line">    stemmed = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> tokens:</span><br><span class="line">        stemmed.append(stemmer.stem(item))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stemmed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tf</span><span class="params">(word, count)</span>:</span></span><br><span class="line">    tfv = count[word] / sum(count.values())</span><br><span class="line">    <span class="keyword">return</span> tfv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">n_containing</span><span class="params">(word, count_list)</span>:</span></span><br><span class="line">    df = sum(<span class="number">1</span> <span class="keyword">for</span> count <span class="keyword">in</span> count_list <span class="keyword">if</span> word <span class="keyword">in</span> count)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idf</span><span class="params">(word, count_list)</span>:</span></span><br><span class="line">    idfv = math.log(len(count_list) / (<span class="number">1</span> + n_containing(word, count_list)))</span><br><span class="line">    <span class="keyword">return</span> idfv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tfidf</span><span class="params">(word, count, count_list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf(word, count) * idf(word, count_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_term</span><span class="params">(text)</span>:</span></span><br><span class="line">    tokens = get_tokens(text)</span><br><span class="line">    filtered = [w <span class="keyword">for</span> w <span class="keyword">in</span> tokens <span class="keyword">if</span> <span class="keyword">not</span> w <span class="keyword">in</span> stopwords.words(<span class="string">'english'</span>)]  <span class="comment"># remove stopwords</span></span><br><span class="line">    stemmer = PorterStemmer()</span><br><span class="line">    stemmed = stem_tokens(filtered, stemmer)</span><br><span class="line">    count = Counter(stemmed)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    texts = [text1, text2, text3]</span><br><span class="line">    countlist = []</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">        countlist.append(count_term(text))</span><br><span class="line">    <span class="keyword">for</span> i, count <span class="keyword">in</span> enumerate(countlist):</span><br><span class="line">        print(<span class="string">"Top words in document {}"</span>.format(i + <span class="number">1</span>))</span><br><span class="line">        scores = {word: tfidf(word, count, countlist) <span class="keyword">for</span> word <span class="keyword">in</span> count}</span><br><span class="line">        sorted_words = sorted(scores.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> word, score <span class="keyword">in</span> sorted_words[:<span class="number">5</span>]:</span><br><span class="line">            print(<span class="string">"\tWord: {}, TF-IDF: {}"</span>.format(word, round(score, <span class="number">5</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><figcaption><span> PySpark版TF-IDF程序</span><a href="/downloads/code/tfidf-pyspark.py">view raw</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">"PySpark example"</span>).enableHiveSupport().getOrCreate()</span><br><span class="line">spark.sparkContext.setLogLevel(<span class="string">"WARN"</span>)</span><br><span class="line"><span class="comment"># Read data</span></span><br><span class="line">df = spark.sql(<span class="string">"SELECT img_label FROM sprs_log_basis.model_server_log WHERE datepart=20190425 LIMIT 10"</span>)</span><br><span class="line">df.cache()</span><br><span class="line">df.show()</span><br><span class="line"><span class="comment"># Get keys</span></span><br><span class="line">df = df.select(F.map_keys(<span class="string">"img_label"</span>).alias(<span class="string">"keys"</span>))</span><br><span class="line"><span class="comment"># Assign index</span></span><br><span class="line">df = df.withColumn(<span class="string">"doc_id"</span>, F.monotonically_increasing_id())</span><br><span class="line">NUM_doc = df.count()</span><br><span class="line"><span class="comment"># One hot words</span></span><br><span class="line">df = df.select(<span class="string">'*'</span>, F.explode(<span class="string">'keys'</span>).alias(<span class="string">'token'</span>))</span><br><span class="line">df.show()</span><br><span class="line"><span class="comment"># Calculate TF</span></span><br><span class="line">TF = df.groupBy(<span class="string">"doc_id"</span>).agg(F.count(<span class="string">"token"</span>).alias(<span class="string">"doc_len"</span>)) \</span><br><span class="line">    .join(df.groupBy(<span class="string">"doc_id"</span>, <span class="string">"token"</span>)</span><br><span class="line">          .agg(F.count(<span class="string">"keys"</span>).alias(<span class="string">"word_count"</span>)), [<span class="string">'doc_id'</span>]) \</span><br><span class="line">    .withColumn(<span class="string">"tf"</span>, F.col(<span class="string">"word_count"</span>) / F.col(<span class="string">"doc_len"</span>)) \</span><br><span class="line">    .drop(<span class="string">"doc_len"</span>, <span class="string">"word_count"</span>)</span><br><span class="line">TF.cache()</span><br><span class="line"><span class="comment"># Calculate IDF</span></span><br><span class="line">IDF = df.groupBy(<span class="string">"token"</span>).agg(F.countDistinct(<span class="string">"doc_id"</span>).alias(<span class="string">"df"</span>))</span><br><span class="line">IDF = IDF.select(<span class="string">'*'</span>, (F.log(NUM_doc / (IDF[<span class="string">'df'</span>] + <span class="number">1</span>))).alias(<span class="string">'idf'</span>))</span><br><span class="line">IDF.cache()</span><br><span class="line"><span class="comment"># Calculate TF-IDF</span></span><br><span class="line">TFIDF = TF.join(IDF, [<span class="string">'token'</span>]).withColumn(<span class="string">'tf-idf'</span>, F.col(<span class="string">'tf'</span>) * F.col(<span class="string">'idf'</span>))</span><br><span class="line">TFIDF.show()</span><br><span class="line">TFIDF.write.save(<span class="string">"s3://***.tmp.ap-southeast-1/Default/hailin/here.csv"</span>, format=<span class="string">'csv'</span>, header=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>References</strong>:<br><a href="http://www.tfidf.com/" target="_blank" rel="noopener">http://www.tfidf.com/</a><br><a href="https://dzone.com/articles/calculating-tf-idf-with-apache-spark" target="_blank" rel="noopener">https://dzone.com/articles/calculating-tf-idf-with-apache-spark</a><br><a href="https://towardsdatascience.com/sentiment-analysis-with-pyspark-bc8e83f80c35" target="_blank" rel="noopener">https://towardsdatascience.com/sentiment-analysis-with-pyspark-bc8e83f80c35</a><br><a href="http://hejunhao.me/archives/856" target="_blank" rel="noopener">http://hejunhao.me/archives/856</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark入门笔记—编程操作对象RDD与DataFrame(PySpark版)</title>
      <link href="/Program-with-RDD-in-PySpark/"/>
      <url>/Program-with-RDD-in-PySpark/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>RDD（Resilient Distributed Dataset）叫做<strong>弹性分布式数据集</strong>，<br>在之前的<a href="https://fuhailin.github.io/Spark-Tutorial/#RDD-Resilient-Distributed-Dataset">Spark基本概念</a>当中我已经介绍过RDD是Spark中最基本的数据结构，是一个不可变的分布式对象集合。Spark的核心是建立在统一的抽象RDD之上，使得Spark的各个组件可以无缝进行集成，在同一个应用程序中完成大数据计算任务。RDD的设计理念源自AMP实验室发表的论文《Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing》。<br><a id="more"></a></p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>在实际应用中，存在许多迭代式算法（比如机器学习、图算法等）和交互式数据挖掘工具，这些应用场景的共同之处是，不同计算阶段之间会重用中间结果，即一个阶段的输出结果会作为下一个阶段的输入。但是，目前的MapReduce框架都是把中间结果写入到HDFS中，带来了大量的数据复制、磁盘IO和序列化开销。虽然，类似Pregel等图计算框架也是将结果保存在内存当中，但是，这些框架只能支持一些特定的计算模式，并没有提供一种通用的数据抽象。RDD就是为了满足这种需求而出现的，它提供了一个抽象的数据架构，我们不必担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，从而避免了中间结果的存储，大大降低了数据复制、磁盘IO和序列化开销。</p><h2 id="RDD概念"><a href="#RDD概念" class="headerlink" title="RDD概念"></a>RDD概念</h2><p>一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可以分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集来创建RDD，或者通过在其他RDD上执行确定的转换操作（如map、join和groupBy）而创建得到新的RDD。RDD提供了一组丰富的操作以支持常见的数据运算，分为“行动”（Action）和“转换”（Transformation）两种类型，前者用于执行计算并指定输出的形式，后者指定RDD之间的相互依赖关系。两类操作的主要区别是，转换操作（比如map、filter、groupBy、join等）接受RDD并返回RDD，而行动操作（比如count、collect等）接受RDD但是返回非RDD（即输出一个值或结果）。RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改。因此，RDD比较适合对于数据集中元素执行相同操作的批处理式应用，而不适合用于需要异步、细粒度状态的应用，比如Web应用系统、增量式的网页爬虫等。正因为这样，这种粗粒度转换接口设计，会使人直觉上认为RDD的功能很受限、不够强大。但是，实际上RDD已经被实践证明可以很好地应用于许多并行计算应用中，可以具备很多现有计算框架（比如MapReduce、SQL、Pregel等）的表达能力，并且可以应用于这些框架处理不了的交互式数据挖掘应用。<br>Spark用Scala语言实现了RDD的API，程序员可以通过调用API实现对RDD的各种操作。RDD典型的执行过程如下：</p><ol><li>RDD读入外部数据源（或者内存中的集合）进行创建；</li><li>RDD经过一系列的“转换”操作，每一次都会产生不同的RDD，供给下一个“转换”使用；</li><li>最后一个RDD经“行动”操作进行处理，并输出到外部数据源（或者变成Scala集合或标量）。</li></ol><p>需要说明的是，RDD采用了惰性调用，即在RDD的执行过程中（如下图所示），真正的计算发生在RDD的“行动”操作，对于“行动”之前的所有“转换”操作，Spark只是记录下“转换”操作应用的一些基础数据集以及RDD生成的轨迹，即相互之间的依赖关系，而不会触发真正的计算。<br><img alt="Spark的转换和行动操作" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Spark-Action-Transformation.jpg"><br>例如，在下图中，从输入中逻辑上生成A和C两个RDD，经过一系列“转换”操作，逻辑上生成了F（也是一个RDD），之所以说是逻辑上，是因为这时候计算并没有发生，Spark只是记录了RDD之间的生成和依赖关系。当F要进行输出时，也就是当F进行“行动”操作的时候，Spark才会根据RDD的依赖关系生成DAG，并从起点开始真正的计算。<br><img alt="RDD执行过程的一个实例" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/RDD-execute-intence.jpg"><br>上述这一系列处理称为一个“血缘关系（Lineage）”，即DAG拓扑排序的结果。采用惰性调用，通过血缘关系连接起来的一系列RDD操作就可以实现管道化（pipeline），避免了多次转换操作之间数据同步的等待，而且不用担心有过多的中间数据，因为这些具有血缘关系的操作都管道化了，一个操作得到的结果不需要保存为中间数据，而是直接管道式地流入到下一个操作进行处理。同时，这种通过血缘关系把一系列操作进行管道化连接的设计方式，也使得管道中每次操作的计算变得相对简单，保证了每个操作在处理逻辑上的单一性；相反，在MapReduce的设计中，为了尽可能地减少MapReduce过程，在单个MapReduce中会写入过多复杂的逻辑。</p><h2 id="RDD特性"><a href="#RDD特性" class="headerlink" title="RDD特性"></a>RDD特性</h2><p>总体而言，Spark采用RDD以后能够实现高效计算的主要原因如下：</p><ol><li>高效的容错性。现有的分布式共享内存、键值存储、内存数据库等，为了实现容错，必须在集群节点之间进行数据复制或者记录日志，也就是在节点之间会发生大量的数据传输，这对于数据密集型应用而言会带来很大的开销。在RDD的设计中，数据只读，不可修改，如果需要修改数据，必须从父RDD转换到子RDD，由此在不同RDD之间建立了血缘关系。所以，RDD是一种天生具有容错机制的特殊集合，不需要通过数据冗余的方式（比如检查点）实现容错，而只需通过RDD父子依赖（血缘）关系重新计算得到丢失的分区来实现容错，无需回滚整个系统，这样就避免了数据复制的高开销，而且重算过程可以在不同节点之间并行进行，实现了高效的容错。此外，RDD提供的转换操作都是一些粗粒度的操作（比如map、filter和join），RDD依赖关系只需要记录这种粗粒度的转换操作，而不需要记录具体的数据和各种细粒度操作的日志（比如对哪个数据项进行了修改），这就大大降低了数据密集型应用中的容错开销；</li><li>中间结果持久化到内存。数据在内存中的多个RDD操作之间进行传递，不需要“落地”到磁盘上，避免了不必要的读写磁盘开销；</li><li>存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化开销。</li></ol><h2 id="RDD之间的依赖关系"><a href="#RDD之间的依赖关系" class="headerlink" title="RDD之间的依赖关系"></a>RDD之间的依赖关系</h2><p>RDD中不同的操作会使得不同RDD中的分区会产生不同的依赖。RDD中的依赖关系分为窄依赖（Narrow Dependency）与宽依赖（Wide Dependency），图9-10展示了两种依赖之间的区别。<br>窄依赖表现为一个父RDD的分区对应于一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区；比如图9-10(a)中，RDD1是RDD2的父RDD，RDD2是子RDD，RDD1的分区1，对应于RDD2的一个分区（即分区4）；再比如，RDD6和RDD7都是RDD8的父RDD，RDD6中的分区（分区15）和RDD7中的分区（分区18），两者都对应于RDD8中的一个分区（分区21）。<br>宽依赖则表现为存在一个父RDD的一个分区对应一个子RDD的多个分区。比如图9-10(b)中，RDD9是RDD12的父RDD，RDD9中的分区24对应了RDD12中的两个分区（即分区27和分区28）。<br>总体而言，如果父RDD的一个分区只被一个子RDD的一个分区所使用就是窄依赖，否则就是宽依赖。窄依赖典型的操作包括map、filter、union等，宽依赖典型的操作包括groupByKey、sortByKey等。对于连接（join）操作，可以分为两种情况。</p><ol><li>对输入进行协同划分，属于窄依赖（如下图(a)所示）。所谓协同划分（co-partitioned）是指多个父RDD的某一分区的所有“键（key）”，落在子RDD的同一个分区内，不会产生同一个父RDD的某一分区，落在子RDD的两个分区的情况。</li><li>对输入做非协同划分，属于宽依赖，如下图(b)所示。</li></ol><p>对于窄依赖的RDD，可以以流水线的方式计算所有父分区，不会造成网络之间的数据混合。对于宽依赖的RDD，则通常伴随着Shuffle操作，即首先需要计算好所有父分区数据，然后在节点之间进行Shuffle。<br><img alt="窄依赖与宽依赖的区别" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/9-10-.jpg"><br>Spark的这种依赖关系设计，使其具有了天生的容错性，大大加快了Spark的执行速度。因为，RDD数据集通过“血缘关系”记住了它是如何从其它RDD中演变过来的，血缘关系记录的是粗颗粒度的转换操作行为，当这个RDD的部分分区数据丢失时，它可以通过血缘关系获取足够的信息来重新运算和恢复丢失的数据分区，由此带来了性能的提升。相对而言，在两种依赖关系中，窄依赖的失败恢复更为高效，它只需要根据父RDD分区重新计算丢失的分区即可（不需要重新计算所有分区），而且可以并行地在不同节点进行重新计算。而对于宽依赖而言，单个节点失效通常意味着重新计算过程会涉及多个父RDD分区，开销较大。此外，Spark还提供了数据检查点和记录日志，用于持久化中间RDD，从而使得在进行失败恢复时不需要追溯到最开始的阶段。在进行故障恢复时，Spark会对数据检查点开销和重新计算RDD分区的开销进行比较，从而自动选择最优的恢复策略。</p><h2 id="阶段的划分"><a href="#阶段的划分" class="headerlink" title="阶段的划分"></a>阶段的划分</h2><p>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分阶段，具体划分方法是：在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到当前的阶段中；将窄依赖尽量划分在同一个阶段中，可以实现流水线计算（具体的阶段划分算法请参见AMP实验室发表的论文《Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing》）。例如，如图9-11所示，假设从HDFS中读入数据生成3个不同的RDD（即A、C和E），通过一系列转换操作后再将计算结果保存回HDFS。对DAG进行解析时，在依赖图中进行反向解析，由于从RDD A到RDD B的转换以及从RDD B和F到RDD G的转换，都属于宽依赖，因此，在宽依赖处断开后可以得到三个阶段，即阶段1、阶段2和阶段3。可以看出，在阶段2中，从map到union都是窄依赖，这两步操作可以形成一个流水线操作，比如，分区7通过map操作生成的分区9，可以不用等待分区8到分区9这个转换操作的计算结束，而是继续进行union操作，转换得到分区13，这样流水线执行大大提高了计算的效率。<br><img alt="根据RDD分区的依赖关系划分阶段" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/9-11-RDD.jpg"><br>由上述论述可知，把一个DAG图划分成多个“阶段”以后，每个阶段都代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集合。每个任务集合会被提交给任务调度器（TaskScheduler）进行处理，由任务调度器将任务分发给Executor运行。</p><h2 id="RDD运行过程"><a href="#RDD运行过程" class="headerlink" title="RDD运行过程"></a>RDD运行过程</h2><p>通过上述对RDD概念、依赖关系和阶段划分的介绍，结合之前介绍的Spark运行基本流程，这里再总结一下RDD在Spark架构中的运行过程（如图9-12所示）：</p><ol><li>创建RDD对象；</li><li>SparkContext负责计算RDD之间的依赖关系，构建DAG；</li><li>DAGScheduler负责把DAG图分解成多个阶段，每个阶段中包含了多个任务，每个任务会被任务调度器分发给各个工作节点（Worker Node）上的Executor去执行。</li></ol><p><img alt="RDD在Spark中的运行过程" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/9-12-RDD-Spark.jpg"></p><h3 id="DataFrame与RDD的区别"><a href="#DataFrame与RDD的区别" class="headerlink" title="DataFrame与RDD的区别"></a>DataFrame与RDD的区别</h3><p><img alt="DataFrame与RDD的区别" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/DataFrame-RDD.jpg"></p><ul><li>RDD是分布式的 Java对象的集合。比如，RDD[Person]是以Person为类型参数，但是，Person类的内部结构对于RDD而言却是不可知的。</li><li>DataFrame是一种以RDD为基础的分布式数据集，也就是分布式的Row对象的集合（每个Row对象代表一行记录），提供了详细的结构信息，也就是常说的模式（schema），Spark SQL可以清楚地知道该数据集中包含哪些列、每列的名称和类型。DataFrame的推出，让Spark具备了处理大规模结构化数据的能力，不仅比原有的RDD转化方式更加简单易用，而且获得了更高的计算性能。和RDD一样，DataFrame的各种变换操作也采用惰性机制，只是记录了各种转换的逻辑转换路线图（是一个DAG图），不会发生真正的计算。DAG图相当于一个逻辑查询计划，最终，会被翻译成物理查询计划，生成RDD DAG，按照RDD DAG的执行方式去完成最终的计算得到结果。</li></ul><h3 id="RDD和DataFrame不同版本API执行效率比较"><a href="#RDD和DataFrame不同版本API执行效率比较" class="headerlink" title="RDD和DataFrame不同版本API执行效率比较"></a>RDD和DataFrame不同版本API执行效率比较</h3><p>目前spark的编程接口中，执行效率是Scala DataFrame api &gt; PySpark DataFrame api &gt; Scala RDD api &gt; PySpark RDD api<br>总的来说，DataFrame执行效率高于RDD，而Scala执行效率又高于Python</p><p>Dataset 上可用的操作可分为 Transformation 和 Action 两大类操作。Transformation操作会产生新的Dataset， 而Action操作将会触发计算并返回结果。Transformation操作主要包含的算子有：<code>map()、filter()、select()、aggregate()、groupBy()</code>。Action操作主要包含的算子有<code>count()、show()、或者写数据到文件系统</code>。值得注意的是，Datasets是”惰性的”，代码运行到Transformation类算子并不会马上执行，而是先构建DAG数据流图，当代码运行到Action类算子时才会触发真正的计算</p><p><a href="http://dblab.xmu.edu.cn/blog/1681-2/" target="_blank" rel="noopener">Spark入门：RDD的设计与运行原理(Python版)</a><br><a href="http://dblab.xmu.edu.cn/blog/1700-2/" target="_blank" rel="noopener">Spark2.1.0+入门：RDD编程(Python版)</a><br><a href="https://spark.apache.org/docs/2.0.0/api/java/org/apache/spark/sql/Dataset.html" target="_blank" rel="noopener">https://spark.apache.org/docs/2.0.0/api/java/org/apache/spark/sql/Dataset.html</a><br><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/rdd-programming-guide.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark入门笔记—基本概念与环境配置</title>
      <link href="/Spark-Tutorial/"/>
      <url>/Spark-Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark中的基本概念"><a href="#Spark中的基本概念" class="headerlink" title="Spark中的基本概念"></a>Spark中的基本概念</h1><h2 id="Spark-Shell"><a href="#Spark-Shell" class="headerlink" title="Spark Shell"></a>Spark Shell</h2><p>Spark的shell提供了一个简单的API可供学习, 其也是一个用于分析数据的强有力交互工具。</p><h2 id="RDD-Resilient-Distributed-Dataset"><a href="#RDD-Resilient-Distributed-Dataset" class="headerlink" title="RDD(Resilient Distributed Dataset)"></a>RDD(Resilient Distributed Dataset)</h2><p>RDD（Resilient Distributed Dataset）叫做<strong>弹性分布式数据集</strong>，是Spark中最基本的数据结构。它是一个不可变的分布式对象集合。在RDD中的每一个数据集被划分进逻辑分区，不同的部分将在集群的不同节点上进行计算。RDD能够包含任意类型的对象，包括Python、Java、Scala甚至用户自定义类型。</p><h2 id="Spark中的组件"><a href="#Spark中的组件" class="headerlink" title="Spark中的组件"></a>Spark中的组件</h2><p>Spark组件使Apache Spark快速和可靠。为了解决使用Hadoop MapReduce时出现的问题，很多Spark组件被构建出来。 Apache Spark具有以下组件：</p><ol><li>Spark Core</li><li>Spark Streaming</li><li>Spark SQL</li><li>GraphX</li><li>MLlib (Machine Learning)</li></ol><h3 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h3><p><em>Spark Core</em>是大规模并行计算和分布式数据处理的基本引擎。它负责：</p><ol><li>内存管理和故障恢复</li><li>在群集上调度，分发和监视作业</li><li>与存储系统交互</li></ol><h3 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h3><p><em>Spark Streaming</em> 是Spark用于处理实时流数据的组件。它支持实时数据流的高吞吐量和容错流处理。基本流单元是 <em>DStream</em> ，其基本上是一系列用于处理实时数据的RDD（弹性分布式数据集）。</p><h3 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h3><p><em>Spark SQL</em> 是Spark中的一个新模块，它将关系处理与Spark的函数式编程API集成在一起。 它支持通过SQL或Hive查询语言查询数据。以下是Spark SQL的四个库：</p><ol><li>Data Source API</li><li>DataFrame API</li><li>Interpreter &amp; Optimizer</li><li>SQL Service</li></ol><h3 id="GraphX"><a href="#GraphX" class="headerlink" title="GraphX"></a>GraphX</h3><p><em>GraphX</em>是用于图形和图形并行计算的Spark API。 因此，它使用弹性分布式属性图(Resilient Distributed Property Graph)扩展了Spark RDD。</p><h3 id="MLlib"><a href="#MLlib" class="headerlink" title="MLlib"></a>MLlib</h3><p><em>MLlib</em> 代表机器学习库Machine Learning Library。Spark MLlib用于在Apache Spark中执行机器学习。</p><h1 id="Spark的安装"><a href="#Spark的安装" class="headerlink" title="Spark的安装"></a>Spark的安装</h1><p>Spark可以独立安装使用，也可以和Hadoop一起安装使用。这里我们采用和Hadoop一起安装使用，这样就可以让Spark使用HDFS存取数据。需要说明的是，当安装好Spark以后，里面就自带了Scala环境，不需要额外安装Scala.</p><h2 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h2><p><a href="https://fuhailin.github.io/Essential-Apps-for-Ubuntu/#Hadoop">https://fuhailin.github.io/Essential-Apps-for-Ubuntu/#Hadoop</a></p><h2 id="安装Spark"><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h2><p>由于我们已经自己安装了Hadoop，所以，在“Choose a package type”后面需要选择“Pre-build with user-provided Hadoop [can use with most Hadoop distributions]”，然后，点击“Download Spark”后面的“spark-2.4.2-bin-without-hadoop.tgz”下载即可。<br>Spark部署模式主要有四种：</p><ul><li>Local模式（单机模式）</li><li>Standalone模式（使用Spark自带的简单集群管理器）</li><li>YARN模式（使用YARN作为集群管理器）</li><li>Mesos模式（使用Mesos作为集群管理器）</li></ul><p>这里介绍Local模式（单机模式）的 Spark安装。我们选择Spark 2.4.2版本，并且假设当前使用用户名hadoop登录了Linux操作系统。<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf spark-2.4.2-bin-without-hadoop.tgz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">sudo mv ./spark-2.4.2-bin-without-hadoop/ ./spark</span><br><span class="line">sudo chown -R hadoop:hadoop ./spark          <span class="comment"># 此处的 hadoop 为你的用户名</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>安装后，还需要修改Spark的配置文件spark-env.sh<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/spark</span><br><span class="line">cp ./conf/spark-env.sh.template ./conf/spark-env.sh</span><br></pre></td></tr></tbody></table></figure><p></p><p>编辑spark-env.sh文件(vim ./conf/spark-env.sh)，在第一行添加以下配置信息:<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SPARK_DIST_CLASSPATH=$(/usr/<span class="built_in">local</span>/hadoop/bin/hadoop classpath)</span><br></pre></td></tr></tbody></table></figure><p></p><p>有了上面的配置信息以后，Spark就可以把数据存储到Hadoop分布式文件系统HDFS中，也可以从HDFS中读取数据。如果没有配置上面信息，Spark就只能读写本地数据，无法读写HDFS数据。然后通过如下命令，修改环境变量<code>vim ~/.bashrc</code>，在.bashrc文件中添加如下内容：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/default-java</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/<span class="built_in">local</span>/hadoop</span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/<span class="built_in">local</span>/spark</span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$SPARK_HOME</span>/python:<span class="variable">$SPARK_HOME</span>/python/lib/py4j-0.10.7-src.zip:<span class="variable">$PYTHONPATH</span></span><br><span class="line"><span class="built_in">export</span> PYSPARK_PYTHON=python3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$SPARK_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>PYTHONPATH环境变量主要是为了在Python3中引入pyspark库，PYSPARK_PYTHON变量主要是设置pyspark运行的python版本。<br>.bashrc中必须包含<code>JAVA_HOME</code>,<code>HADOOP_HOME</code>,<code>SPARK_HOME</code>,<code>PYTHONPATH</code>,<code>PYSPARK_PYTHON</code>,<code>PATH</code>这些环境变量。如果已经设置了这些变量则不需要重新添加设置。<br><img alt="SPARK_HOME环境变量" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-04-25-18-02-23.png"><br>接着还需要让该环境变量生效，执行<code>source ~/.bashrc</code>。<br>配置完成后就可以直接使用，不需要像Hadoop运行启动命令。<br>通过运行Spark自带的示例，验证Spark是否安装成功。<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/spark</span><br><span class="line">bin/run-example SparkPi</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行时会输出非常多的运行信息，输出结果不容易找到，可以通过 grep 命令进行过滤（命令中的 2&gt;&amp;1 可以将所有的信息都输出到 stdout 中，否则由于输出日志的性质，还是会输出到屏幕中）:<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/run-example SparkPi 2&gt;&amp;1 | grep <span class="string">"Pi is"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>过滤后的运行结果如下图示，<br><img alt="run-example SparkPi" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-04-25-18-01-05.png"></p><h1 id="Spark的使用-Python版PySpark"><a href="#Spark的使用-Python版PySpark" class="headerlink" title="Spark的使用(Python版PySpark)"></a>Spark的使用(Python版PySpark)</h1><p>学习Spark程序开发，建议首先通过pyspark交互式学习，加深Spark程序开发的理解。<br>PySpark提供了简单的方式来学习 API，并且提供了交互的方式来分析数据。你可以输入一条语句，PySpark会立即执行语句并返回结果，这就是我们所说的REPL（Read-Eval-Print Loop，交互式解释器），为我们提供了交互式执行环境，表达式计算完成就会输出结果，而不必等到整个程序运行完毕，因此可即时查看中间结果，并对程序进行修改，这样可以在很大程度上提升开发效率。</p><p>前面已经安装了Hadoop和Spark，如果Spark不使用HDFS和YARN，那么就不用启动Hadoop也可以正常使用Spark。如果在使用Spark的过程中需要用到 HDFS，就要首先启动 Hadoop（启动Hadoop的方法可以参考上面给出的<a href="https://fuhailin.github.io/Hadoop-Install/">Hadoop安装教程</a>）。<br>这里假设不需要用到HDFS，因此，就没有启动Hadoop。现在我们直接开始使用Spark。</p><p>注意：如果按照上面的安装步骤，已经设置了PYSPARK_PYTHON环境变量，那么你直接使用如下命令启动pyspark即可。<br><code>pyspark</code><br>如果没有设置PYSPARK_PYTHON环境变量，则使用如下命令启动pyspark<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PYSPARK_PYTHON=python3</span><br><span class="line">pyspark</span><br></pre></td></tr></tbody></table></figure><p></p><p>pyspark命令及其常用的参数如下：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --master &lt;master-url&gt;</span><br></pre></td></tr></tbody></table></figure><p></p><p>Spark的运行模式取决于传递给SparkContext的Master URL的值。Master URL可以是以下任一种形式：</p><ul><li>local 使用一个Worker线程本地化运行SPARK(完全不并行)</li><li>local[*] 使用逻辑CPU个数数量的线程来本地化运行Spark</li><li>local[K] 使用K个Worker线程本地化运行Spark（理想情况下，K应该根据运行机器的CPU核数设定）</li><li>spark://HOST:PORT 连接到指定的Spark standalone master。默认端口是7077.</li><li>yarn-client 以客户端模式连接YARN集群。集群的位置可以在HADOOP_CONF_DIR 环境变量中找到。</li><li>yarn-cluster 以集群模式连接YARN集群。集群的位置可以在HADOOP_CONF_DIR 环境变量中找到。</li><li>mesos://HOST:PORT 连接到指定的Mesos集群。默认接口是5050。</li></ul><p>需要强调的是，这里我们采用“本地模式”（local）运行Spark，关于如何在集群模式下运行Spark，可以参考后面的“在集群上运行Spark应用程序”。<br>在Spark中采用本地模式启动pyspark的命令主要包含以下参数：<br>–master：这个参数表示当前的pyspark要连接到哪个master，如果是local[*]，就是使用本地模式启动pyspark，其中，中括号内的星号表示需要使用几个CPU核心(core)；<br>–jars： 这个参数用于把相关的JAR包添加到CLASSPATH中；如果有多个jar包，可以使用逗号分隔符连接它们；</p><p>比如，要采用本地模式，在4个CPU核心上运行pyspark：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --master local[4]</span><br></pre></td></tr></tbody></table></figure><p></p><p>或者，可以在CLASSPATH中添加code.jar，命令如下：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --master local[4] --jars code.jar</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以执行“pyspark –help”命令，获取完整的选项列表，具体如下：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --help</span><br></pre></td></tr></tbody></table></figure><p></p><p>上面是命令使用方法介绍，下面正式使用命令进入pyspark环境，可以通过下面命令启动pyspark环境：<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark</span><br></pre></td></tr></tbody></table></figure><p></p><p>该命令省略了参数，这时，系统默认是“bin/pyspark–master local[*]”，也就是说，是采用本地模式运行，并且使用本地所有的CPU核心。</p><p>启动pyspark后，就会进入“&gt;&gt;&gt;”命令提示符状态,如下图所示：<br><img alt data-src="2019-04-25-21-27-07.png"></p><h1 id="Spark独立应用程序编程"><a href="#Spark独立应用程序编程" class="headerlink" title="Spark独立应用程序编程"></a>Spark独立应用程序编程</h1><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line">sc = SparkContext( <span class="string">'local'</span>, <span class="string">'test'</span>)</span><br><span class="line">logFile = <span class="string">"file:///usr/local/spark/README.md"</span></span><br><span class="line">logData = sc.textFile(logFile, <span class="number">2</span>).cache()</span><br><span class="line">numAs = logData.filter(<span class="keyword">lambda</span> line: <span class="string">'a'</span> <span class="keyword">in</span> line).count()</span><br><span class="line">numBs = logData.filter(<span class="keyword">lambda</span> line: <span class="string">'b'</span> <span class="keyword">in</span> line).count()</span><br><span class="line">print(<span class="string">'Lines with a: %s, Lines with b: %s'</span> % (numAs, numBs))</span><br></pre></td></tr></tbody></table></figure><p>一些学习资料：<br><a href="https://tech.meituan.com/2016/04/29/spark-tuning-basic.html" target="_blank" rel="noopener">Spark性能优化指南——基础篇</a><br><a href="PySpark_SQL_Cheat_Sheet_Python.pdf">PySpark_SQL_Cheat_Sheet_Python.pdf</a></p><p><strong>References</strong>:</p><ol><li><a href="http://dblab.xmu.edu.cn/blog/1709-2/" target="_blank" rel="noopener">大数据之Spark入门教程(Python版)|厦门大学数据库</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS学习笔记</title>
      <link href="/HDFS-Overview/"/>
      <url>/HDFS-Overview/</url>
      
        <content type="html"><![CDATA[<p><strong>Hadoop Distributed File System</strong>——HDFS，是世界上最可靠的存储系统。 HDFS是Hadoop的文件系统，是Hadoop不可缺少的一部分，其为2003年Google发表的Google文件系统GFS的克隆版。<br><br>Hadoop文件系统使用分布式文件系统设计开发，设计原则是存储较少数量的大文件而不是大量的小文件。用于存储在硬件集群上运行的非常大的文件。不像其他的分布式系统，HDFS是高度容错以及使用低成本的硬件设计。<br><a id="more"></a></p><h2 id="HDFS的特点"><a href="#HDFS的特点" class="headerlink" title="HDFS的特点"></a>HDFS的特点</h2><ul><li>分布式存储和处理超大型的数据量。</li><li>单个文件冗余式存储避免单节点失效可能造成的数据损失</li><li>Hadoop提供的命令接口与HDFS进行交互。</li><li>名称节点和数据节点的帮助用户内置的服务器能够轻松地检查集群的状态。</li><li>流式访问文件系统数据。</li><li>HDFS提供了文件的权限和验证。</li><li>不依赖硬件，能够运行在普通廉价的机器上</li></ul><h2 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h2><p>下面给出是Hadoop的文件系统的体系结构。<br>  <img alt="HDFS架构" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/HDFS-Architecture.jpg"><br>HDFS遵循主/从式架构，它具有以下元素。</p><h3 id="命名节点-Namenode"><a href="#命名节点-Namenode" class="headerlink" title="命名节点 - Namenode"></a>命名节点 - Namenode</h3><p>一个HDFS集群会有一个NameNode（简称NN）命名节点，该节点作为主服务器存在（master server），它执行以下任务：</p><ul><li>管理文件系统命名空间</li><li>调节客户端对文件的访问。</li><li>它也执行文件系统操作，如重命名，关闭和打开的文件和目录。</li></ul><h3 id="数据节点-Datanode"><a href="#数据节点-Datanode" class="headerlink" title="数据节点 - Datanode"></a>数据节点 - Datanode</h3><p>一个HDFS集群还会有多个DataNode（简称DN）数据节点，数据节点作为从节点存在（slave server），它执行以下任务：</p><ul><li>Datanode根据客户的请求在文件系统上执行读写操作。</li><li>根据Namenode的指令执行操作，如块的创建，删除和复制。</li></ul><h3 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h3><p>往HDFS中写入的任何文件，都会分成称为<strong>块</strong>的小块数据。 HDFS的默认块大小为128 MB，可根据要求增加，即便一个数据块大小为130M，也会被拆分为2个Block，一个大小为128M，一个大小为2M。 这些块以分布式方式存储在集群中的不同节点上。这为MapReduce提供了一种在集群中并行处理数据的机制。默认情况下，每个数据块都会有三个副本，每个副本都会被存放在不同的机器上，而且每一个副本都有自己唯一的编号。这就提供了容错、可靠性和高可用性。如下图：<br><img alt="HDFS副本机制" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/7e142940a0feb4c119be2d8df7fad13c.png"></p><p><a href="http://images.linoxide.com/hadoop-hdfs-commands-cheatsheet.pdf" target="_blank" rel="noopener">Hadoop HDFS Command Cheatsheet.pdf</a></p><p><strong>References</strong>:</p><ol><li><a href="https://data-flair.training/blogs/hadoop-hdfs-tutorial/" target="_blank" rel="noopener">HDFS Tutorial – A Complete Hadoop HDFS Overview</a></li><li><a href="https://blog.51cto.com/zero01/2090716" target="_blank" rel="noopener">HDFS伪分布式环境搭建</a></li><li><a href="https://blog.51cto.com/zero01/2090901" target="_blank" rel="noopener">Java操作HDFS开发环境搭建以及HDFS的读写流程</a></li><li><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener">HDFS Architecture官方文档</a></li><li><a href="https://www.yiibai.com/hadoop/hadoop_hdfs_operations.html#article-start" target="_blank" rel="noopener">Hadoop HDFS操作</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDFS </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04下Hadoop 3的安装与配置（伪分布式环境）</title>
      <link href="/Hadoop-Install/"/>
      <url>/Hadoop-Install/</url>
      
        <content type="html"><![CDATA[<p>本教程使用 Ubuntu 18.04 64位 作为系统环境（Ubuntu16.04 也行，32位、64位均可），请自行安装系统。如果用的是 CentOS/RedHat 系统，请查看相应的<a href="http://dblab.xmu.edu.cn/blog/install-hadoop-in-centos/" target="_blank" rel="noopener">CentOS安装Hadoop教程_单机伪分布式配置</a>。<br>本教程基于原生最新 Hadoop 3，在 Hadoop 3.1.2 (stable) 版本下验证通过，可适合任何 Hadoop 3.x.y 版本，其他版本类似。<br><a id="more"></a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="创建hadoop用户"><a href="#创建hadoop用户" class="headerlink" title="创建hadoop用户"></a>创建hadoop用户</h2><p>如果你安装 Ubuntu 的时候不是用的 “hadoop” 用户，那么需要增加一个名为 hadoop 的用户。<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m hadoop -s /bin/bash  #创建hadoop用户，并使用/bin/bash作为shell</span><br><span class="line">sudo passwd hadoop                   #为hadoop用户设置密码，之后需要连续输入两次密码</span><br><span class="line">sudo adduser hadoop sudo             #为hadoop用户增加管理员权限</span><br><span class="line">su - hadoop                          #切换当前用户为用户hadoop</span><br><span class="line">sudo apt-get update                  #更新hadoop用户的apt,方便后面的安装</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="安装SSH-设置SSH无密码登陆"><a href="#安装SSH-设置SSH无密码登陆" class="headerlink" title="安装SSH,设置SSH无密码登陆"></a>安装SSH,设置SSH无密码登陆</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server   <span class="comment">#安装SSH server</span></span><br><span class="line">ssh localhost                         <span class="comment">#登陆SSH，第一次登陆输入yes</span></span><br><span class="line"><span class="built_in">exit</span>                                  <span class="comment">#退出登录的ssh localhost</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh/                            <span class="comment">#如果没法进入该目录，执行一次ssh localhost</span></span><br><span class="line">ssh-keygen -t rsa　　</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys <span class="comment">#加入授权</span></span><br><span class="line">ssh localhost                         <span class="comment">#此时已不需密码即可登录localhost，并可见下图。如果失败则可以搜索SSH免密码登录来寻求答案</span></span><br></pre></td></tr></tbody></table></figure><h1 id="安装Java环境"><a href="#安装Java环境" class="headerlink" title="安装Java环境"></a>安装Java环境</h1><p>此处参考 <a href="https://fuhailin.github.io/Essential-Apps-for-Ubuntu/#JAVA">https://fuhailin.github.io/Essential-Apps-for-Ubuntu/#JAVA</a></p><h1 id="安装-Hadoop-3"><a href="#安装-Hadoop-3" class="headerlink" title="安装 Hadoop 3"></a>安装 Hadoop 3</h1><p>通过Apache Hadoop官方下载页面( <a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">https://hadoop.apache.org/releases.html</a> )选择最新的Binary版本进行下载（截止2019年4月25日，Hadoop最新稳定版本为3.1.2）。<br>Binary版本是编译好的二进制版本，可以直接解压安装；另一个包含 src 的则是 Hadoop 源代码，需要进行编译才可使用。<br>下面进行安装：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.cuhk.edu.hk/pub/packages/apache.org/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz</span><br><span class="line">sudo tar -zxvf  hadoop-3.1.2.tar.gz -C /usr/<span class="built_in">local</span>    <span class="comment">#解压到/usr/local目录下</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">sudo mv ./hadoop-3.1.2/ ./hadoop                      <span class="comment">#重命名为hadoop</span></span><br><span class="line">sudo chown -R hadoop ./hadoop                        <span class="comment">#修改文件权限</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>给hadoop配置环境变量，将下面代码添加到.bashrc文件:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/<span class="built_in">local</span>/hadoop</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=$(<span class="variable">$HADOOP_HOME</span>/bin/hadoop classpath):<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_COMMON_LIB_NATIVE_DIR=<span class="variable">$HADOOP_HOME</span>/lib/native</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行source ~./bashrc使设置生效，并查看hadoop是否安装成功<br><img alt="hadoop version" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop-version.png"></p><h1 id="伪分布式配置"><a href="#伪分布式配置" class="headerlink" title="伪分布式配置"></a>伪分布式配置</h1><p>Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。</p><p>Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。<br>首先将<code>JDK</code>的路径(echo $JAVA_HOME)添加到hadoop-env.sh文件，修改<code>vim ./etc/hadoop/hadoop-env.sh</code>:<br><img alt data-src="2019-04-25 14 56 11.png"></p><p>接下来修改配置文件 <code>./etc/hadoop/core-site.xml</code>:<br></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>修改配置文件 <code>./etc/hadoop/hdfs-site.xml</code>：<br></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Hadoop配置文件说明"><a href="#Hadoop配置文件说明" class="headerlink" title="Hadoop配置文件说明"></a>Hadoop配置文件说明</h2><p>Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。</p><p>此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。</p><p>配置完成后，执行 NameNode 的格式化:<br><code>./bin/hdfs namenode -format</code><br><img alt="./bin/hdfs namenode -format" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/namenode-format.png"><br>启动namenode和datanode进程，并查看启动结果<br><code>./sbin/start-dfs.sh</code><br>启动完成后，可以通过命令 <code>jps</code> 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”<br><img alt data-src="2019-04-25 15 38 08.png"><br>成功启动后，可以访问 HDFS的Web 界面 <a href="http://localhost:9870" target="_blank" rel="noopener">http://localhost:9870</a> 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。<br><img alt="HDFS Web界面" data-src="2019-04-25 15 52 37.png"><br>至此，hadoop的安装就已经完成啦！enjoy it！</p><h1 id="运行Hadoop伪分布式实例"><a href="#运行Hadoop伪分布式实例" class="headerlink" title="运行Hadoop伪分布式实例"></a>运行Hadoop伪分布式实例</h1><p>由于前面已经配置了Hadoop的环境变量，Hadoop和HDFS的命令已经包含在了系统当中，HDFS有三种shell命令方式：</p><ul><li>hadoop fs         ： 适用于任何不同的文件系统，比如本地文件系统和HDFS文件系统</li><li>hadoop dfs        ： 只能适用于HDFS文件系统</li><li>hdfs dfs          ： 跟hadoop dfs的命令作用一样，也只能适用于HDFS文件系统</li></ul><p>上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录：<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /user/hadoop</span><br></pre></td></tr></tbody></table></figure><p></p><p>接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/hadoop/input:<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir input</span><br><span class="line">hdfs dfs -put ./etc/hadoop/*.xml input</span><br></pre></td></tr></tbody></table></figure><p></p><p>复制完成后，可以通过如下命令查看文件列表：<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls input</span><br></pre></td></tr></tbody></table></figure><p></p><p>伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output 'dfs[a-z.]+'</span><br></pre></td></tr></tbody></table></figure><p></p><p>查看运行结果的命令（查看的是位于 HDFS 中的输出结果）：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -cat output/*</span><br></pre></td></tr></tbody></table></figure><p></p><p>结果如下，注意到刚才我们已经更改了配置文件，所以运行结果不同。<br><img alt data-src="2019-04-25 16 21 24.png"><br>我们也可以将运行结果取回到本地：<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -r ./output    # 先删除本地的 output 文件夹（如果存在）</span><br><span class="line">hdfs dfs -get output ./output     # 将 HDFS 上的 output 文件夹拷贝到本机</span><br><span class="line">cat ./output/*</span><br></pre></td></tr></tbody></table></figure><p></p><p>Hadoop 运行程序时，输出目录不能存在，否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -rm -r output    # 删除 output 文件夹</span><br></pre></td></tr></tbody></table></figure><p></p><p>若要关闭 Hadoop，则运行<br><code>./sbin/stop-dfs.sh</code><br>下次启动 hadoop 时，无需进行 NameNode 的初始化，只需要运行 <code>./sbin/start-dfs.sh</code> 就可以！</p><p><strong>References</strong>:</p><ol><li><a href="http://dblab.xmu.edu.cn/blog/install-hadoop/" target="_blank" rel="noopener">Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04</a></li><li><a href="https://www.cnblogs.com/87hbteo/p/7606012.html" target="_blank" rel="noopener">Ubuntu16.04 下 hadoop的安装与配置（伪分布式环境）</a></li><li><a href="https://dzone.com/articles/install-a-hadoop-cluster-on-ubuntu-18041" target="_blank" rel="noopener">Install a Hadoop Cluster on Ubuntu 18.04.1</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDFS </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tips &amp; tricks in LaTeX</title>
      <link href="/tips-tricks-in-LaTeX/"/>
      <url>/tips-tricks-in-LaTeX/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Wookai/paper-tips-and-tricks" target="_blank" rel="noopener">Wookai/paper-tips-and-tricks</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组元素循环右移问题</title>
      <link href="/move-elements-in-array-cyclically/"/>
      <url>/move-elements-in-array-cyclically/</url>
      
        <content type="html"><![CDATA[<p>一个数组A中存有N（N&amp;gt0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？要求时间复杂度为O（N），且只允许使用两个附加变量<br><a id="more"></a><br>输入描述:</p><blockquote><p>每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。</p></blockquote><p>输出描述:</p><blockquote><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><p>示例1<br>输入<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 2</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></tbody></table></figure><p></p><p>输出<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 6 1 2 3 4</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><p>假设原数组序列为abcd1234，要求变换成的数组序列为1234abcd，即循环右移了4位。比较发现，其中两段的顺序是不变的，1234和abcd，可以把这两段看成两个整体。右移k位的过程就是把数组两部分交换一下，交换过程可以通过三次反转实现：</p><p>1.反转前k部分：abcd1234-&gt;dcba1234；<br>2.反转后面部分：dcba1234-&gt;dcba4321；<br>3.整体反转：dcba4321-&gt;1234abcd<br></p><figure class="highlight cpp"><figcaption><span>move-elements-in-array-cyclically.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/algorithm/move-elements-in-array-cyclically.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vec</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (i == nums.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    M = M % nums.size();</span><br><span class="line">    reverse(nums.begin(), nums.begin() + nums.size() - M);</span><br><span class="line">    <span class="comment">// print_vec(nums);</span></span><br><span class="line">    reverse(nums.begin() + nums.size() - M, nums.end());</span><br><span class="line">    <span class="comment">// print_vec(nums);</span></span><br><span class="line">    reverse(nums.begin(), nums.end());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">    }</span><br><span class="line">    move(nums, M);</span><br><span class="line">    print_vec(nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计数组中各元素出现次数</title>
      <link href="/Count-the-number-of-occurrences/"/>
      <url>/Count-the-number-of-occurrences/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><ul><li>给定一个整数数组a，长度为N，元素取值范围为[1,N]。</li><li>统计各个元素出现的次数，要求时间复杂度为O(N)，空间复杂度为O(1)。</li><li>可以改变原来数组结构。</li></ul><a id="more"></a><p>思路：</p><ul><li>从第一个元素开始遍历，每遍历到一个元素，将（该元素值 - 1 记为index）作为一个下标值，令该下标对应的元素值为元素 index+1出现的次数。</li><li>若下标index为负值，说明该元素已经处理过，跳过；</li><li>判断，若a[index]为正，则赋初值-1；若为负，则执行减1操作。</li><li>最后，数组中存储的元素即为统计次数，而该元素对应的下标+1即为元素值。<figure class="highlight cpp"><figcaption><span>Count-the-number-of-occurrences.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/algorithm/Count-the-number-of-occurrences.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//采用while循环</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//由于元素取值范围为[1,N]，因此，可以将（当前元素值-1）作为下标值，找到相应位置处的元素，将其存储的值作为-times，因为原来存储值都为正值，为防止混淆，用负值存储</span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">        { <span class="comment">//表示该元素已经处理过了，跳过</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[temp] &gt; <span class="number">0</span>)</span><br><span class="line">        {                         <span class="comment">//第一次处理一个值</span></span><br><span class="line">            nums[i] = nums[temp]; <span class="comment">//暂存新元素</span></span><br><span class="line">            nums[temp] = <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        { <span class="comment">//已经不是第一次处理该值了</span></span><br><span class="line"></span><br><span class="line">            nums[i] = <span class="number">0</span>; <span class="comment">//没有新的元素要处理，置0</span></span><br><span class="line">            nums[temp]--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; j + <span class="number">1</span> &lt;&lt; <span class="string">","</span> + -nums[j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test{<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>};</span><br><span class="line">    count(test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】Contains Duplicate</title>
      <link href="/contains-duplicate/"/>
      <url>/contains-duplicate/</url>
      
        <content type="html"><![CDATA[<h1 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a>217. Contains Duplicate</h1><h2 id="解法一、基于排序"><a href="#解法一、基于排序" class="headerlink" title="解法一、基于排序"></a>解法一、基于排序</h2><p>对于给定的数组先排序然后再顺序查找有无重复，时间复杂度O(nlogn)。<br></p><figure class="highlight cpp"><figcaption><span>217.contains-duplicate.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/LeetCode/217.contains-duplicate.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate_Sorting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == nums[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>这里直接使用了STL<algorithm>库中sort()函数，其STL的sort()底层算法，<strong>数据量大时采用Quick Sort</strong>，分段递归排序，一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷，就改用<strong>Insertion Sort</strong>。如果<strong>递归层次过深，还会改用Heap Sort</strong>。<br>参考<a href="http://www.cppblog.com/mzty/archive/2005/12/15/1770.html" target="_blank" rel="noopener">详细解说 STL 排序(Sort)</a></algorithm><p></p><h2 id="解法二、基于Hash表"><a href="#解法二、基于Hash表" class="headerlink" title="解法二、基于Hash表"></a>解法二、基于Hash表</h2><p>将数组中的元素转换到Hash表当中时间复杂度O(n).<br></p><figure class="highlight cpp"><figcaption><span>217.contains-duplicate.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/LeetCode/217.contains-duplicate.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate_HashTable</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>.size() != nums.size();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>C++ STL中Hash Table对应的数据结构是<unordered_set>，查找某元素是否在unordered_set当中的方法是<code>const bool is_in = container.find(element) != container.end();</code>。<strong><unordered_set>底层对应的数据结构是红黑树</unordered_set></strong>。</unordered_set><p></p><h1 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="219. Contains Duplicate II"></a>219. Contains Duplicate II</h1><h1 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220. Contains Duplicate III"></a>220. Contains Duplicate III</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 字符串</title>
      <link href="/cpp-strings/"/>
      <url>/cpp-strings/</url>
      
        <content type="html"><![CDATA[<p>C++ 提供了以下两种类型的字符串表示形式：</p><ul><li><strong>C 风格字符串</strong></li><li><strong>C++ 引入的 string 类类型</strong></li></ul><a id="more"></a><h1 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C 风格字符串"></a>C 风格字符串</h1><p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p><p><code>char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};</code></p><p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p><p><code>char greeting[] = "Hello";</code></p><p>以下是 C/C++ 中定义的字符串的内存表示：<br><img alt data-src="http://www.runoob.com/wp-content/uploads/2014/08/string_representation.jpg"><br>其实，您不需要把 <code>null</code> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 <code>'\0'</code> 放在字符串的末尾。让我们尝试输出上面的字符串<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">char</span> greeting[<span class="number">6</span>] = {<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>};</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Greeting message: "</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; greeting &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>C++ 中有大量的函数用来操作以 null 结尾的字符串：</p><h3 id="strcpy-s1-s2"><a href="#strcpy-s1-s2" class="headerlink" title="strcpy(s1, s2);"></a>strcpy(s1, s2);</h3><p> 复制字符串 s2 到字符串 s1。</p><h3 id="strcat-s1-s2"><a href="#strcat-s1-s2" class="headerlink" title="strcat(s1, s2);"></a>strcat(s1, s2);</h3><p> 连接字符串 s2 到字符串 s1 的末尾。</p><h3 id="strlen-s1"><a href="#strlen-s1" class="headerlink" title="strlen(s1);"></a>strlen(s1);</h3><p> 返回字符串 s1 的长度。</p><h3 id="strcmp-s1-s2"><a href="#strcmp-s1-s2" class="headerlink" title="strcmp(s1, s2);"></a>strcmp(s1, s2);</h3><p> 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。</s2></p><h3 id="strchr-s1-ch"><a href="#strchr-s1-ch" class="headerlink" title="strchr(s1, ch);"></a>strchr(s1, ch);</h3><p> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</p><h3 id="strstr-s1-s2"><a href="#strstr-s1-s2" class="headerlink" title="strstr(s1, s2);"></a>strstr(s1, s2);</h3><p> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置</p><hr><h1 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h1><p>C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p><p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p><p>string类提供了一系列针对字符串的操作，比如：</p><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><ul><li><strong>str.length()</strong>: <code>int len = "fuhailin".length();</code>// len = 8</li><li><strong>str.size()</strong>: <code>int len = "fuhailin".size();</code> // len = 8</li></ul><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><ul><li><strong>append()</strong>: <code>str1.append(str2);</code> //在字符串的末尾添加字符</li><li><p><strong>+</strong> 连接符 : <code>str3 = str1 + str2;</code> // 连接 str1 和 str2</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"fuhailin"</span>;</span><br><span class="line">str.append(<span class="string">".github"</span>); <span class="comment">// str = "fuhailin.github"</span></span><br><span class="line">str = str + <span class="string">".io"</span>; <span class="comment">// str = "fuhailin.github.io"</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><p> <strong>2. find()</strong> — 在字符串中查找字符串<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"fuhailin"</span>;</span><br><span class="line"><span class="built_in">string</span>::size_type position1, position2;</span><br><span class="line">position1 = str.find(<span class="string">'a'</span>);</span><br><span class="line">position2 = str.find(<span class="string">"ia"</span>);</span><br><span class="line"><span class="keyword">if</span> (position1 != str.npos)  <span class="comment">//如果没找到，返回一个特别的标志c++中用npos表示，我这里npos取值是4294967295，</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"position is : %d\n"</span>, position1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Not found the flag\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (position2 != str.npos)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"position is : %d\n"</span>, position2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Not found the flag\n"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(position1).name() &lt;&lt; <span class="string">'\t'</span> &lt;&lt; <span class="keyword">typeid</span>(position2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>position is : 3<br>Not found the flag<br>unsigned int    unsigned int</p></blockquote><h3 id="字符串插入"><a href="#字符串插入" class="headerlink" title="字符串插入"></a>字符串插入</h3><p><code>string&amp; string::insert (size_type idx, const string&amp; str)</code><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"fuhailin"</span>;</span><br><span class="line">str.insert(<span class="number">5</span>, <span class="number">5</span>, <span class="string">'%'</span>); <span class="comment">// str = "fuhai%%%%%lin"</span></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p><code>string&amp; string::replace (size_t pos, size_t len, const string&amp; str)</code><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"fuhailin"</span>;</span><br><span class="line">str.replace(<span class="number">5</span>, <span class="number">1</span>, <span class="string">"Hello"</span>); <span class="comment">// str = "fuhaiHelloin"</span></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p><code>string substr (size_t pos = 0, size_t len = npos) const;</code><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"fuhailin"</span>;</span><br><span class="line"><span class="built_in">string</span> str1 = str.substr(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// str = "fuhailin"</span></span><br><span class="line"><span class="comment">// str1 = "li"</span></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL字符串解码</title>
      <link href="/URL-Decode/"/>
      <url>/URL-Decode/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在URL字符串中，如果百分号%后面跟了两个十六进制数字，那么它表示相应ASCII值所对应的字符，如<code>%2F</code>表示<code>'/'</code>，<code>%32</code>表示<code>'2'</code>。%编码还可以进行嵌套，如<code>%%32F</code>可以解码成<code>%2F</code>，再进一步解码成<code>/</code>。如果没有任何百分号后面跟的是两个十六进制数字则无法再进行解码。</p><p>现在有一系列的URL，希望你帮忙进行百分号解码，直到无法再解码为止。</p><a id="more"></a><h1 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h1><blockquote><p>第一行一个正整数T(T&lt;=10)，表示T个测试样例；<br>对于每个测试样例，输入字符串s，字符串不包含空白符且长度小于100,000。<br>有部分测试样例的字符串长度&lt;=1,000.</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>输出T行，每行一个字符串，表示解码后的结果。</p></blockquote><p>示例1<br>输入<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">%%32F</span><br></pre></td></tr></tbody></table></figure><p></p><p>输出<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="C-解决方案"><a href="#C-解决方案" class="headerlink" title="C++解决方案"></a>C++解决方案</h1><p>我这里写了一个C++的URL解码方案，主要思路是借用了一个栈，从字符串后边开始遍历，如果不是<code>%</code>则放入栈中，遇到<code>%</code>则从栈顶取出两个字符，将这个十六进制的字符串转换成ASCII码后又放入栈顶。继续遍历，直到输入字符串的头部，最后将栈中字符输出即为所得字符串。</p><figure class="highlight cpp"><figcaption><span>URL_Decode.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/algorithm/URL_Decode.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;cstdlib&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">hex2ascii</span><span class="params">(<span class="built_in">string</span> hex)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> len = hex.length();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> newString;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">string</span> byte = hex.substr(i, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">char</span> chr = (<span class="keyword">char</span>)(<span class="keyword">int</span>)strtol(byte.c_str(), <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        newString.push_back(chr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newString;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">urlDecode</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;eString)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">    <span class="built_in">string</span> newstr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = eString.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> tmp = eString[i];</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">'%'</span>)</span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            newstr.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">            newstr.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">            </span><br><span class="line">            newstr = hex2ascii(newstr);</span><br><span class="line">            s.push(newstr[<span class="number">0</span>]);</span><br><span class="line">            newstr.clear();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            s.push(tmp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    {</span><br><span class="line">        newstr.push_back(s.top());</span><br><span class="line">        s.pop();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newstr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; url_decode(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">string</span> str1 = strs[i];</span><br><span class="line">        <span class="built_in">string</span> str2 = urlDecode(str1);</span><br><span class="line">        res.push_back(str2);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; test;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        test.push_back(str);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res = url_decode(test);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中<code>string hex2ascii(string hex)</code>为十六进制的字符串转换成ASCII码的方法，两个十六进制的字符对应一个ASCII码。其中使用了<code>C 库函数 - strtol()</code>，C 库函数 <code>long int strtol(const char *str, char **endptr, int base)</code> 把参数 str 所指向的字符串根据给定的 base 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间表示多少进制，或者是特殊值 0。</p><p>试了好几个例子都没问题，但是在牛客网上提交却是0%通过，很奇怪，还希望有缘人看到这个后能指出错误。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图神经网络Graph Neural Networks</title>
      <link href="/Graph-Neural-Networks/"/>
      <url>/Graph-Neural-Networks/</url>
      
        <content type="html"><![CDATA[<p>本帖主要收集图神经网络学习资源，加上自己的一些理解。</p><p>GNN综述:<a href="https://arxiv.org/abs/1901.00596v2" target="_blank" rel="noopener">A Comprehensive Survey on Graph Neural Networks</a> ,<br>图神经网络方法与应用综述：<a href="https://arxiv.org/abs/1812.08434v3" target="_blank" rel="noopener">Graph Neural Networks: A Review of Methods and Applications</a><br>一文读懂图卷积GCN: <a href="https://mp.weixin.qq.com/s/X4kWloqPb2j4AuS1Q9N4PA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/X4kWloqPb2j4AuS1Q9N4PA</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph Neural Networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】33. Search in Rotated Sorted Array</title>
      <link href="/search-in-rotated-sorted-array/"/>
      <url>/search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>Example 1:</p><blockquote><p>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4</p></blockquote><p>Example 2:</p><blockquote><p>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</p></blockquote><a id="more"></a><h1 id="思路一：寻找旋转点"><a href="#思路一：寻找旋转点" class="headerlink" title="思路一：寻找旋转点"></a>思路一：寻找旋转点</h1><p>找到旋转点之后，旋转点两边的数组就都是有序的，于是判断target在哪边，就可以直接用二分查找快速找到了。</p><p>怎么找到旋转点？</p><h1 id="递归-二分查找"><a href="#递归-二分查找" class="headerlink" title="递归 + 二分查找"></a>递归 + 二分查找</h1><p>二分查找的好处在于可以减少一半的搜索空间，对旋转矩阵，二分查找将矩阵分为两部分，其中必然一部分有序，一部分<strong>可能</strong>无序。<br>例如对于旋转数组<code>[4, 5, 6, 7, 0, 1, 2, 3]</code>，以二分的方式将旋转数组分成两部分<code>[4, 5, 6, 7]</code> <code>[0, 1, 2, 3]</code>，这两部分都是有序的。<br>但是对于旋转数组<code>[5, 6, 7, 0, 1, 2, 3, 4]</code>，以二分的方式将旋转数组分成两部分<code>[5, 6, 7, 0]</code> <code>[1, 2, 3, 4]</code>,这两部分只有右边是有序的。<br>于是对于有序的那部分我们可以直接用二分查找快速搜索target，无序的那部分再以上面的方式划分，最终会分成右边都是有序的形式（哪怕只剩下一个值）</p><p>怎么判断划分出来的那一部分是不是有序呢？<br>观察到划分出来的那部分首元素肯定要小于划分点，而无序的那部分因为旋转过了，所以首元素要小于划分点；例如：划分点索引为3使，4&lt;7, 左边肯定是有序；5&gt;0，左边肯定是无序的，则右边为有序。于是我们可以归纳出判断数组是否有序的条件：<code>nums[left] &lt;= nums[mid]</code>则左边有序，否则右边有序。<!--7,--></p><p>对于找出了有序的部分，我们首先要判断target在不在区间中：<code>nums[left]&lt;=target &amp;&amp; nums[mid]&gt;=target</code>，在此区间范围内再二分搜索。</p><p>根据上面的思路，我们可以写出如下的代码：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> help(nums, target, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">-1</span>, right = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> rot = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (vec[left] &lt;= vec[rot])</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (vec[rot] &gt;= target &amp;&amp; vec[left] &lt;= target)</span><br><span class="line">                    left = binary_search(vec, target, left, rot);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = help(vec, target, rot + <span class="number">1</span>, right);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (vec[rot + <span class="number">1</span>] &lt;= target &amp;&amp; vec[right] &gt;= target)</span><br><span class="line">                    right = binary_search(vec, target, rot + <span class="number">1</span>, right);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = help(vec, target, left, rot);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (vec[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vec[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><p>时间复杂度分析：最好的情况下O(1)，最坏的情况下O(n)，平均时间复杂度O(n/2).<br>空间复杂度分析：由于存在递归调用，会使用栈空间，空间复杂度O(n/2).<br>上述解决方案递交到LeetCode上面AC但是成绩并不高<img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-03-08-004047.png"><br>而且写法也较为啰嗦，存在很大的优化空间。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求折线段与直线的交点数</title>
      <link href="/lines-intersection/"/>
      <url>/lines-intersection/</url>
      
        <content type="html"><![CDATA[<p>题目描述：<br>给定一个折线段，其由一个数组表示；例如数组<code>[5,3,1,4]</code>表示由[0,5] -&gt; [1,3] -&gt; [2,1] -&gt; [3,4]构成的折线段。和一个整数，表示与X轴平行的直线；例如，2表示Y=2的直线，求折线段与直线的交点数，如果无穷的交点数用-1表示</p><p>输入：<br>[5,3,1,4], 2<br>输出：<br>2</p><a id="more"></a><p>思路：<br>有交点的地方，在Y轴方向差值之和不为正数。<br>特殊情况：点在直线上怎么办，折线与直线平行怎么办？</p><ol><li>如果数组为空，没有交点返回0；</li><li>如果数组只有一个值，该点恰好在直线上，返回1；</li><li>如果线段[y1, y2]斜跨过直线，则(y1-value)*(y2-value)&lt;0;</li><li>如果线段[y1, y2]恰好有一端在直线上，则(y1-value)*(y2-value)=0；</li><li>如果线段[y1, y2]两端都在直线上，则线段与直线重合，有无穷个交点，则(y1-value)==0 &amp;&amp; (y2-value)=0，返回-1。</li></ol><p>用C++实现了一个比较啰嗦的解法：<br></p><figure class="highlight cpp"><figcaption><span>lines-intersection.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/algorithm/lines-intersection.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment">#  Author:           Hailin - https://fuhailin.github.io/lines-intersection/</span></span><br><span class="line"><span class="comment">#  Email:            hailinfufu@outlook.com</span></span><br><span class="line"><span class="comment">#  Description:      求折线段与直线的交点数/</span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (vec.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (vec.size() == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ((vec[<span class="number">0</span>] - val) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ((vec[i] - val) * (vec[i - <span class="number">1</span>] - val) &lt;= <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">if</span> ((vec[i] - val) == <span class="number">0</span>)</span><br><span class="line">                sum--;</span><br><span class="line">            <span class="keyword">if</span> ((vec[i] - val) == <span class="number">0</span> &amp;&amp; (vec[i - <span class="number">1</span>] - val) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test{<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>};</span><br><span class="line">    <span class="keyword">int</span> res = getSection(test, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三十六进制加法</title>
      <link href="/k-decimal-addition/"/>
      <url>/k-decimal-addition/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述</strong><br>36进制由0-9，a-z，共36个字符表示，最小为’0’。 ‘0’、’9’对应十进制的0、9，‘a’、’z’对应十进制的10、35</p><p>例如：</p><blockquote><p>‘1b’ 换算成10进制等于 1 <em> 36^1 + 11 </em> 36^0 = 36 + 11 = 47<br>要求按照加法规则计算出任意两个36进制正整数的和<br>如：按照加法规则，计算’1b’ + ‘2x’ = ‘48’</p><p>要求：<br>不允许把36进制数字整体转为10进制数字，计算出10进制数字的相加结果再转回为36进制</p></blockquote><a id="more"></a><p><strong>思路</strong><br>按照十进制的加法方法，满36向前进一位</p><p>C++实现代码：<br></p><figure class="highlight cpp"><figcaption><span>36hex_calculation.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/algorithm/36hex_calculation.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment">#  Author:           Hailin - https://fuhailin.github.io/</span></span><br><span class="line"><span class="comment">#  Email:            hailinfufu@outlook.com</span></span><br><span class="line"><span class="comment">#  Description:      三十六进制加法</span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;m, <span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> len1 = a.length(), len2 = b.length(), len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">    {</span><br><span class="line">        len = len1;</span><br><span class="line">        <span class="keyword">int</span> temp = len1 - len2;</span><br><span class="line">        b.insert(<span class="number">0</span>, temp, <span class="string">'0'</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len2 &gt; len1)</span><br><span class="line">    {</span><br><span class="line">        len = len2;</span><br><span class="line">        <span class="keyword">int</span> temp = len2 - len1;</span><br><span class="line">        a.insert(<span class="number">0</span>, temp, <span class="string">'0'</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        len = len1;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">string</span> sum;</span><br><span class="line">    <span class="keyword">int</span> remainder = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> one1 = a[i];</span><br><span class="line">        <span class="keyword">int</span> two1 = b[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">        {</span><br><span class="line">            one1 = a[i] - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            one1 = a[i] - <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">        {</span><br><span class="line">            two1 = b[i] - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            two1 = b[i] - <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> temp = one1 + two1 + carry;</span><br><span class="line">        remainder = temp % m;</span><br><span class="line">        carry = temp / m;</span><br><span class="line">        <span class="keyword">if</span> (remainder &gt; <span class="number">9</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">char</span> ctemp = remainder + <span class="string">'a'</span> - <span class="number">10</span>;</span><br><span class="line">            sum = sum + ctemp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">char</span> ctemp = remainder + <span class="string">'0'</span>;</span><br><span class="line">            sum = sum + ctemp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (carry)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> ctemp = <span class="string">'0'</span> + carry;</span><br><span class="line">        sum = ctemp + sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> hex;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; hex &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">string</span> res = add(hex, a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" + "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux上配置Jupyter Notebook远程访问</title>
      <link href="/remote-jupyter-notebook/"/>
      <url>/remote-jupyter-notebook/</url>
      
        <content type="html"><![CDATA[<p>现在运行深度学习的程序基本需要比较高配置的GPU服务器，所以一般会通过自己的电脑远程访问服务器。但是服务器上没有浏览器，我想在服务器上运行Jupyter Notebook该怎么访问呢？<br><a id="more"></a></p><h1 id="安装ipython-jupyter"><a href="#安装ipython-jupyter" class="headerlink" title="安装ipython, jupyter"></a>安装ipython, jupyter</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install ipython</span><br><span class="line">pip install jupyter</span><br></pre></td></tr></tbody></table></figure><p>如果是在Anaconda虚拟环境中运行Jupyter的话还需要安装<code>conda install notebook ipykernel</code>（<strong>Python3适用</strong>）</p><h1 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line"><span class="comment"># /home/hailin/.jupyter/jupyter_notebook_config.py</span></span><br></pre></td></tr></tbody></table></figure><h1 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h1><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hailin@<span class="number">601</span>GPU /]$ ipython</span><br><span class="line">Python <span class="number">3.5</span><span class="number">.2</span> |Continuum Analytics, Inc.| (default, Jul  <span class="number">2</span> <span class="number">2016</span>, <span class="number">17</span>:<span class="number">53</span>:<span class="number">06</span>)</span><br><span class="line">Type <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">IPython <span class="number">5.1</span><span class="number">.0</span> -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython's features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python's own help system.</span><br><span class="line">object?   -&gt; Details about 'object', use 'object??' for extra details.</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'sha1:43b95b731276:5d330ee6f6054613b3ab4cc59c5048ff7c70f549'</span></span><br></pre></td></tr></tbody></table></figure><h1 id="修改默认配置文件"><a href="#修改默认配置文件" class="headerlink" title="修改默认配置文件"></a>修改默认配置文件</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /home/hailin/.jupyter/jupyter_notebook_config.py</span><br><span class="line"></span><br><span class="line">c.NotebookApp.ip=<span class="string">'*'</span>&nbsp;<span class="comment">#设置访问notebook的ip，*表示所有IP，这里设置ip为都可访问&nbsp;&nbsp;</span></span><br><span class="line">c.NotebookApp.allow_remote_access = True</span><br><span class="line">c.NotebookApp.password&nbsp;=&nbsp;<span class="string">'sha1:5df252f58b7f:bf65d53125bb36c085162b3780377f66d73972d1'</span>&nbsp;<span class="comment">#填写刚刚生成的密文&nbsp;&nbsp;</span></span><br><span class="line">c.NotebookApp.open_browser&nbsp;=&nbsp;False&nbsp;<span class="comment">#&nbsp;禁止notebook启动时自动打开浏览器(在linux服务器一般都是ssh命令行访问，没有图形界面的。所以，启动也没啥用)&nbsp;&nbsp;</span></span><br><span class="line">c.NotebookApp.port&nbsp;=8888&nbsp;<span class="comment">#指定访问的端口，默认是8888</span></span><br></pre></td></tr></tbody></table></figure><h1 id="启动jupyter-notebook"><a href="#启动jupyter-notebook" class="headerlink" title="启动jupyter notebook"></a>启动jupyter notebook</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></tbody></table></figure><h1 id="本地浏览器访问远程"><a href="#本地浏览器访问远程" class="headerlink" title="本地浏览器访问远程"></a>本地浏览器访问远程</h1><p><a href="http://202.116.46.256:8888/tree?" target="_blank" rel="noopener">http://202.116.46.256:8888/tree?</a><br><img alt data-src="2019-03-02-232043.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的Virtual和Inline关键字</title>
      <link href="/Inline-and-Virtual-Function-in-CPP/"/>
      <url>/Inline-and-Virtual-Function-in-CPP/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网笔试形式</title>
      <link href="/NOWCODER/"/>
      <url>/NOWCODER/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网</a>作为近来应届学生招聘的新贵网站，大大小小许多公司都将其作为自己的校招在线笔试平台，而作为广大编程大牛刷题的社区<a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a>，两者代码提交的形式则有着很大的不同。</p><a id="more"></a><h1 id="牛客网与LeetCode"><a href="#牛客网与LeetCode" class="headerlink" title="牛客网与LeetCode"></a>牛客网与LeetCode</h1><p>在LeetCode上面，题目都已按照不同的语言类型定义好了接口函数，你只需要将给出的函数补充完整即可，并且提交运行之后LeetCode还会给出详细的错误用例。而牛客网上面的算法题目只描述出两个左右输入输出样例，你需要写出完整的可执行程序，提交运行之后只会给出测试样例通过的百分比，你不能根据提示知道你的程序疏忽了哪些测试样例，如果你通过了100%的测试样例，你的程序就被<strong>AC</strong>(Accept)了。因此即使你能在LeetCode上熟练的解决各种难题，但是不一定能在牛客网上顺利AC，这还是需要熟悉一下这些形式的。让我们来看一些常见题型，寻找一些牛客网上算法题目的提交模板吧！</p><h1 id="编程题-矩阵查数——第四范式"><a href="#编程题-矩阵查数——第四范式" class="headerlink" title="[编程题] 矩阵查数——第四范式"></a>[编程题] 矩阵查数——第四范式</h1><blockquote><p>时间限制：4秒<br>空间限制：65536K</p></blockquote><p>给定一个二维整型矩阵，已知矩阵的每一行都按照从小到大的顺序排列，每一列也都按照从小到大的顺序排列。现在给出一个数，请写一个函数返回该数是否存在于矩阵中。<br>矩阵中出现的数字与需要查找的数(k)都为0~100000之间的整数，且矩阵的大小在3000*3000以内。<br>在保证正确性的基础上，请尽量给出比较高效的解法。请列出你的算法时间复杂度与空间复杂度分别是多少？</p><p><strong>输入描述:</strong></p><blockquote><p>输入两个整数m,n, 且 0<m<=3000, 0<n<="3000。" 接着输入一个vector<vector<int>&gt; matrix矩阵，大小为m行n列，与一个int k，为需要查找的数字。</m<=3000,></p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>输出true或者false，true表示该数k存在于该matrix矩阵中，false表示该数k不存在于该matrix矩阵中。</p></blockquote><p><strong>输入例子1:</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">​​2 3 5</span><br><span class="line">​​3 4 7</span><br><span class="line">​​3 5 8</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>输出例子1:</strong></p><blockquote><p>true</p></blockquote><p><strong>例子说明1:</strong></p><blockquote><p>4位于矩阵的第二行第二列，故输出true</p></blockquote><figure class="highlight cpp"><figcaption><span>%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%95%B0.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/nowcoder/4Paradigm/%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%95%B0.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//从左下角开始遍历如果值比k小则向右走，如果值比k大则往下走</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findk</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    m--;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; i &lt; n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (matrix[m][i] == k)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[m][i] &gt; k)</span><br><span class="line">            m--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> m, n; <span class="comment">// 输入两个整数m,n, 且 0&lt;m&lt;=3000, 0&lt;n&lt;=3000.</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//接着输入一个vector&lt;vector&lt;int&gt;&gt; matrix矩阵，大小为m行n列</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; vec[i][j];</span><br><span class="line">    <span class="keyword">int</span> k; <span class="comment">//与一个int k，为需要查找的数字。</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">bool</span> res = findk(vec, k);</span><br><span class="line">    <span class="comment">//输出true或者false，true表示该数k存在于该matrix矩阵中，false表示该数k不存在于该matrix矩阵中。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> NOWCODER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Temporal Convolutional Network (TCN与TrellisNet)</title>
      <link href="/Temporal-Convolutional-Network/"/>
      <url>/Temporal-Convolutional-Network/</url>
      
        <content type="html"><![CDATA[<p>《An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling》<sup><a href="#fn_1" id="reffn_1">1</a></sup>论文阅读笔记。说来惭愧，这篇论文去年4月份就曾在技术圈里刷屏，号称横扫序列模型中如RNN、GRU、LSTM等基本模型，当时第一时间就听说了，但是一直没有弄懂技术原理，这一年来的面试中，有两次对方提到了CNN用来序列建模的优点，然而我却没有深入去理解它，今天就来攻克它。</p><a id="more"></a><p><img alt="An Overview of TCNs" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-02-27-192324.png"></p><h1 id="Temporal-Convolutional-Network简介"><a href="#Temporal-Convolutional-Network简介" class="headerlink" title="Temporal Convolutional Network简介"></a>Temporal Convolutional Network简介</h1><p>本文就序列建模, 对 CNN 和 RNN 进行了比较. 按照文章的说法, 在 RNN 的主场打了一架, 结果 CNN 完胜. 使用的模型包括针对序列建模特殊构造的CNN, 称为 Temporal Convolutional Network, TCN 和普通 RNN, GRU, LSTM.</p><p>为了比较 RNN 和 CNN 在 Sequence Modeling 上的性能, 文章构造了一种能用于序列建模的简单通用的 CNN 架构 TCN, 结合了 causal convolution, residual connection 和 dilation convolution.</p><blockquote><p>TCN 的典型特点是:</p><ol><li>卷积是 causal 的, 意味着不会存在“信息泄露leakage”，未来的信息不会泄漏到过去;</li><li>能将任意长度的序列<strong>如同RNN那样映射为相同长度的输出序列</strong>.</li></ol></blockquote><p>为实现第二个目标, TCN 使用一维全卷积结构, 通过 zero padding 使各层保持相同长度.</p><h2 id="Causal-Convolution因果卷积"><a href="#Causal-Convolution因果卷积" class="headerlink" title="Causal Convolution因果卷积"></a>Causal Convolution因果卷积</h2><p>而<strong>所谓 causal convolution, 就是计算 t 时刻的输出时, 仅对前一层 t 时刻及之前的状态进行卷积</strong>.</p><p>Causal convolution 的叠加, 高层的感受野野/历史信息与网络层数呈线性关系. 对于超长序列, 网络必须很深, 才能捕捉到足够长的历史信息. 针对这个问题, 文中使用了 dilation convolution, 使得随网络的加深, 高层的感受野呈指数扩大.</p><script src="//gist.github.com/b8af96d5d36dc12226cc9129c410afeb.js?file=causal_conv1d.py"></script><h2 id="Dilated-Convolutions扩张卷积"><a href="#Dilated-Convolutions扩张卷积" class="headerlink" title="Dilated Convolutions扩张卷积"></a>Dilated Convolutions扩张卷积</h2><p>使用Dilated Convolutions<sup><a href="#fn_2" id="reffn_2">2</a></sup>的关键是为了通过较少的参数和较少的层数实现更大的 <em>感受野 (receptive field)</em> 。 考虑一个由<script type="math/tex">k\times k</script>个卷积组成，没有池化层pooling的普通卷积网络，很容易得出每一个单元 <em>感受野</em> 的大小(影响激活的像素点)是<script type="math/tex">l*(k-1)+k</script>，其中$l$是第几层，所以有效感受野的单元数与层数成正比。这样得到的感受野是非常有限的，特别是对于高分辨率输入图像。</p><p>卷积Dilated Convolutions的出现拯救了这一问题，<br>Dilation convolution<sup><a href="#fn_2" id="reffn_2">2</a></sup> 的运算如下:  <script type="math/tex">F ( s ) = \left( \mathbf { x } * _ { d } f \right) ( s ) = \sum _ { i = 0 } ^ { k - 1 } f ( i ) \cdot \mathbf { x } _ { s - d \cdot i }</script>( <script type="math/tex">\mathbf { x }</script>表示输入序列, $f$ 表示 filter, $d$ 是 dilation factor, $k$ 是 filter size,  <script type="math/tex">s - d \cdot i</script>意味着只对过去的状态作卷积). 看图最直观.<br><img alt="A dilated causal convolution with dilation factors d = 1, 2, 4 and filter size k = 3" data-src="causal-convolution.png"><br>和传统卷积不同的是，扩张卷积允许卷积时的输入存在间隔采样，采样率受图中的d控制。 最下面一层的d=1，表示输入时每个点都采样，中间层d=2，表示输入时每2个点采样一个作为输入。一般来讲，越高的层级使用的d的大小越大。所以，扩张卷积使得有效窗口的大小随着层数呈指数型增长。这样卷积网络用比较少的层，就可以获得很大的感受野。<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screen-Shot-2016-05-12-at-09-47-12.png"></p><blockquote><p>(a). 普通卷积，1-dilated convolution，卷积核的感受野为<script type="math/tex">3 \times 3 = 9</script><br>(b). 扩张卷积，2-dilated convolution，卷积核的感受野为<script type="math/tex">7 \times 7 = 49</script><br>(c). 扩张卷积，4-dilated convolution，卷积核的感受野为<script type="math/tex">15 \times 15 = 225</script><br>一个扩张率为2的3×3卷积核，感受野与5×5的卷积核相同，但参数数量仅为$9$个，是5×5卷积参数数量的<script type="math/tex">36%</script>。</p></blockquote><h2 id="Residual-Connections残差链接"><a href="#Residual-Connections残差链接" class="headerlink" title="Residual Connections残差链接"></a>Residual Connections残差链接</h2><p>TCN 的感受野依赖于上式中的 dilation factor d 和 filter/kernel size k, 以及网络深度 n. 为获得足够大的感受野, TCN 还是不得不增加网络的深度, 因此它构造了残差单元来训练更深的网络. (残差单元在 ResNet 的笔记中有详细介绍)<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-02-27-222900.png"><br>残差链接被证明是训练深层网络的有效方法，它使得网络可以以跨层的方式传递信息。本文构建了一个残差块来代替一层的卷积。如上图所示，一个残差块包含两层的卷积和非线性映射，在每层中还加入了WeightNorm和Dropout来正则化网络。</p><h2 id="讨论和总结"><a href="#讨论和总结" class="headerlink" title="讨论和总结"></a>讨论和总结</h2><p>总体来讲，TCN模型上的创新并不是很大，因果卷积和扩展卷积也并不是本论文提出来，本文主要是将TCN的结构梳理了一下，相比于wavenet中的结构，去掉了门机制，加入了残差结构，并在很多的序列问题上进行了实验。实验效果如下：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-02-27-223110.png"><br>在多个任务上，都比标准的LSTM、GRU等效果好。</p><h2 id="TCN优缺点"><a href="#TCN优缺点" class="headerlink" title="TCN优缺点"></a>TCN优缺点</h2><p><strong>TCN 在序列建模方面的优势是</strong>:</p><ol><li>可并行性 (只要抛弃了 RNN, 神经网络基本都具有了这一优点);</li><li>通过调整 n, k, d, 可灵活地控制感受野, 能适应不同任务 (有些任务要求解决超长期依赖, 有些任务更依赖短期依赖);</li><li>稳定的梯度 (同样地, 只要抛弃了 RNN, 时间传播方向上的梯度爆炸/消失问题就自然解决了);</li><li>训练时的低内存占用，特别是面对长输入序列 (参数共享, 以及只存在沿网络方向的反向传播带来的裨益).</li></ol><p><strong>TCN 的缺点</strong>:</p><ol><li>推断时, 需要更多的内存 (此时 RNN 只需要维护一个 hidden state, 每次接受一个输入; 而 TCN 要保持一个足够长的序列, 以保留历史状态);</li><li>迁移的困难性 (不同领域任务对感受野的大小不同, 使用小 k 和小 d 学好的模型难以应用于需要大 k 和大 d 的任务).</li></ol><h2 id="Show-Me-the-Code"><a href="#Show-Me-the-Code" class="headerlink" title="Show Me the Code"></a>Show Me the Code</h2><blockquote><p>PyTorch: <a href="https://github.com/locuslab/TCN" target="_blank" rel="noopener">https://github.com/locuslab/TCN</a><br>TensorFlow: <a href="https://github.com/Songweiping/TCN-TF" target="_blank" rel="noopener">https://github.com/Songweiping/TCN-TF</a><br>Keras: <a href="https://github.com/philipperemy/keras-tcn" target="_blank" rel="noopener">https://github.com/philipperemy/keras-tcn</a><br>Notebook: <a href="https://colab.research.google.com/drive/1la33lW7FQV1RicpfzyLq9H0SH1VSD4LE" target="_blank" rel="noopener">https://colab.research.google.com/drive/1la33lW7FQV1RicpfzyLq9H0SH1VSD4LE</a></p></blockquote><h1 id="Trellis-Networks-for-Sequence-Modeling"><a href="#Trellis-Networks-for-Sequence-Modeling" class="headerlink" title="Trellis Networks for Sequence Modeling"></a>Trellis Networks for Sequence Modeling</h1><p>在写《An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling》查阅资料的过程中又发现了TCN作者同一个实验室对TCN改进的工作：《Trellis Networks for Sequence Modeling》<sup><a href="#fn_3" id="reffn_3">3</a></sup></p><blockquote><p>TrellisNet PyTorch: <a href="https://github.com/locuslab/trellisnet" target="_blank" rel="noopener">https://github.com/locuslab/trellisnet</a></p></blockquote><p>本文延续在序列模型上的探索，提出了一种新的结构，称为trellis networks，一方面，这种结构与TCN有些类似，但是在权值共享机制和隐层状态计算过程上有所不同；另一方面，作者严格证明了这种结构与某种特殊的截断循环神经网络之间是等价的，这个发现的意义在于证明trellis network同时吸取了两种结构的优势，可以某种程度上解释它的优越性能，并可以增加将CNN和RNN的一些改进融入到这个结构中。</p><h2 id="TrellisNet与TCN的区别"><a href="#TrellisNet与TCN的区别" class="headerlink" title="TrellisNet与TCN的区别"></a>TrellisNet与TCN的区别</h2><p>TrellisNet本质上也是一种特殊的时序卷积网络。时序网络有两个重要的特征：a) <strong>因果卷积</strong>，满足因果性，即时刻t的结果只与t时刻之前的状态有关，不存在t时刻之后的信息泄露；b) <strong>扩张卷积</strong>，逐层堆叠以逐渐增大感知野，建模长期依赖关系。这两个特性都可以在TrellisNet中得到满足，但是不同于TCN，TrellisNet有两个显著的不同，<strong>a) 在所有层之间进行权值共享；b) 输入序列作为每层输入的一部分</strong>。</p><p>Reference:<br><sup><a href="#fn_1" id="reffn_1">1</a></sup>: <a href="https://arxiv.org/abs/1803.01271" target="_blank" rel="noopener">An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup>: <a href="https://www.inference.vc/dilated-convolutions-and-kronecker-factorisation/" target="_blank" rel="noopener">Dilated Convolutions and Kronecker Factored Convolutions</a><br><sup><a href="#fn_3" id="reffn_3">3</a></sup>: <a href="https://arxiv.org/abs/1810.06682" target="_blank" rel="noopener">Trellis Networks for Sequence Modeling</a><br> <a href="https://zhuanlan.zhihu.com/p/52477665" target="_blank" rel="noopener">TCN论文阅读</a><br> <a href="https://medium.com/the-artificial-impostor/notes-understanding-tensorflow-part-3-7f6633fcc7c7" target="_blank" rel="noopener">[Tensorflow] Implementing Temporal Convolutional Networks</a><br> <a href="https://zhuanlan.zhihu.com/p/47422814" target="_blank" rel="noopener">论文分享：Trellis Networks for Sequence Modeling</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCN </tag>
            
            <tag> TrellisNet </tag>
            
            <tag> Sequence Modeling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoML之超参数优化</title>
      <link href="/AutoML-Hyperpam-Optimize/"/>
      <url>/AutoML-Hyperpam-Optimize/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>AutoML是指尽量不通过人来设定超参数，而是使用某种学习机制，来调节这些超参数。这些学习机制包括传统的贝叶斯优化，多臂老虎机（multi-armed bandit），进化算法，还有比较新的强化学习。</p><p>我将AutoML分为<strong>传统AutoML</strong> ，自动调节传统的机器学习算法的参数，比如随机森林，我们来调节它的max_depth, num_trees, criterion等参数。 还有一类AutoML，则专注深度学习。这类AutoML，不妨称之为<strong>深度AutoML</strong> ，与传统AutoML的差别是，现阶段深度AutoML，会将神经网络的超参数分为两类，一类是与训练有关的超参数，比如learning rate, regularization, momentum等；还有一类超参数，则可以总结为网络结构。对网络结构的超参数自动调节，也叫 <strong>Neural architecture search (nas)</strong> 。而针对训练的超参数，也是传统AutoML的自动调节，叫 <strong>Hyperparameter optimization (ho)</strong>。</p><a id="more"></a><p> 我们已经看到机器学习在许多领域取得了成功应用，但是通常这些模型对正确选取超参数都有强烈依赖。<br>每一个机器学习系统都有超参数，自动机器学习(AutoML)最基本的任务就是自动选取超参数。深度神经网络的性能更是尤其依赖于网络的结构、正则项、最优化目标等相关超参数的选取。自动超参数优化(HPO)的重要性体现在：</p><ol><li>它能显著减少机器学习应用耗费的人力；</li><li>提升机器学习算法的性能；</li><li>自动超参数优化提升了科学研究的可复用性，使科研之间的竞争更公平。因为HPO的可复现方式比手工搜索要清晰，而不同算法性能差异不会再因为超参数设置的影响。</li></ol><p>HPO在实践中也遇到了重重困难：</p><ol><li>对于大型模型、复杂的机器学习流程、大型数据集，进行模型评估是昂贵的；</li><li>配置空间是复杂并且高维的。况且通常你并不清楚一个算法的那些超参数需要优化，又是什么优化范围。</li><li>没办法获取损失函数中超参数的梯度；</li><li>当训练集大小有限时优化的参数组合又没有很强的泛化能力</li></ol><h1 id="网格搜索GridSearch："><a href="#网格搜索GridSearch：" class="headerlink" title="网格搜索GridSearch："></a>网格搜索GridSearch：</h1><ul><li><p>优点：</p><ol><li>可以找到最好的参数</li></ol></li><li><p>缺陷：</p><ol><li>随着超参数规模越来越大，GridSearch时间复杂度会呈指数型增长；</li><li>有一些参数比较重要一些参数不太重要，GridSearch就会浪费很多的资源在非重要的参数上</li></ol></li></ul><h1 id="随机搜索RandomSearch"><a href="#随机搜索RandomSearch" class="headerlink" title="随机搜索RandomSearch"></a>随机搜索RandomSearch</h1><p>每个超参数独立sample一部分对应的参数，在随机的sample上搜索</p><ul><li><p>优点：</p><ol><li>不会受限于超参数规模，不会有指数爆炸、组合爆炸的问题；</li><li>由于在不同的超参数之间是独立进行搜索，不会存在重要参数和非重要参数浪费资源的问题</li><li>在较少的迭代次数内比网格搜索找到更好的结果</li></ol></li><li><p>缺点：</p><ol><li>不能保证找到最优参数</li></ol></li></ul><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-02-24-003234.png"></p><h1 id="贝叶斯优化"><a href="#贝叶斯优化" class="headerlink" title="贝叶斯优化"></a>贝叶斯优化</h1><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>假设$A$表示一个具有$N$个超参数的机器学习算法，第$n$个超参数用<script type="math/tex">\Lambda _{n}</script>来表示，<script type="math/tex">\mathbf { \Lambda } = \Lambda _ { 1 } \times \Lambda _ { 2 } \times \ldots \Lambda _ { N }</script>表示<em>整个超参数配置空间</em>， <script type="math/tex">\boldsymbol { \lambda } \in \mathbf { \Lambda }</script>表示一个超参数向量，而<script type="math/tex">\Lambda _{\lambda}</script>表示<script type="math/tex">\Lambda</script>对<script type="math/tex">\lambda</script>的一个实例。</p><p>一个超参数的域可以是实数(比如learning rate)、整数(比如网络层数)、二元型(比如是否要用early stopping)、类别型(哪种优化目标)。</p><p>另外配置空间还具有<em>条件性</em>，例如一个超参数可能仅仅与另外一个超参数取某一特定值有关。条件参数空间可看成一个有项无环图。<br>给定数据集</p><p>Reference：</p><ol><li><a href="https://www.automl.org/wp-content/uploads/2018/11/hpo.pdf" target="_blank" rel="noopener">Chapter 1: Hyperparameter Optimization</a></li><li><a href="https://www.automl.org/book/" target="_blank" rel="noopener">AUTOML: METHODS, SYSTEMS, CHALLENGES (NEW BOOK)</a></li><li><a href="https://roamanalytics.com/2016/09/15/optimizing-the-hyperparameter-of-which-hyperparameter-optimizer-to-use/" target="_blank" rel="noopener">Optimizing the hyperparameter of which hyperparameter optimizer to use</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AutoML </tag>
            
            <tag> GridSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GBDT</title>
      <link href="/GBDT/"/>
      <url>/GBDT/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>GBDT 全称是 Gradient Boosting Decision Tree，是一种常用的 Ensemble Learning 算法。由于其出色的表现以及 XGBoost 的出现，近些年在 Kaggle 等竞赛中大放异彩。</p><p><strong>优点</strong>：</p><p><strong>缺点</strong>：</p><p>GBDT 作为一种 Ensemble Learning 算法，本质也就是融合多个弱分类器进行决策。从 GBDT 的名字可以看出，它包含两个概念：GB（Gradient Boosting） 和 DT（Decision Tree）。因此，GBDT 使用的弱分类器就是 Decision Tree，而融合的方法叫做 Gradient Boosting。但是在介绍 Gradient Boosting 前，我们先回顾一下相关的 Boosting 算法。</p><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><h2 id="Boosting介绍"><a href="#Boosting介绍" class="headerlink" title="Boosting介绍"></a>Boosting介绍</h2><ul><li>基本思想</li></ul><p>Boosting方法基于这样一种思想：</p><blockquote><p>对于一个复杂任务来说，将多个专家的判定进行适当的综合得出的判断，要比其中任何一个专家单独的判断好。很容易理解，就是”三个臭皮匠顶个诸葛亮”的意思…😄😄😄。</p></blockquote><ul><li>历史由来</li></ul><p>历史上，Kearns和Valiant首先提出了”强可学习（strongly learnable）”和“弱可学习（weakly learnable）”的概念。他们指出：</p><blockquote><p>在概率近似正确（probably approximately correct，PAC）学习框架中：<br>①. 一个概念（一个类，label），如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是强可学习的；<br>②. 一个概念（一个类，label），如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测略好，那么就称这个概念是弱可学习的。<br>Schapire后来证明了: 强可学习和弱可学习是等价的。 也就是说，在PAC学习的框架下，一个概念是强可学习的 充分必要条件 是这个概念是弱可学习的。 表示如下：<br>                                                  强可学习⇔弱可学习</p></blockquote><p>如此一来，问题便成为：在学习中，如果已经发现了”弱学习算法”，那么能否将它提升为”强学习算法”？ 通常的，发现弱学习算法通常要比发现强学习算法容易得多。那么如何具体实施提升，便成为开发提升方法时所要解决的问题。关于提升方法的研究很多，最具代表性的当数AdaBoost算法（是1995年由Freund和Schapire提出的）。</p><ul><li>Boosting学习思路</li></ul><p>对于一个学习问题来说（以分类问题为例），给定训练数据集，求一个弱学习算法要比求一个强学习算法要容易的多。Boosting方法就是从弱学习算法出发，反复学习，得到一系列弱分类器，然后组合弱分类器，得到一个强分类器。Boosting方法在学习过程中通过改变训练数据的权值分布，针对不同的数据分布调用弱学习算法得到一系列弱分类器。</p><p>这里面有两个问题需要回答：</p><ol><li>在每一轮学习之前，如何改变训练数据的权值分布？</li><li><p>如何将一组弱分类器组合成一个强分类器？</p><blockquote><p>具体不同的boosting实现，主要区别在弱学习算法本身和上面两个问题的回答上。</p></blockquote></li></ol><p>针对第一个问题，Adaboost算法的做法是：</p><p><strong>提高那些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类样本的权值。</strong></p><blockquote><p>如此，那些没有得到正确分类的样本，由于其权值加大而受到后一轮的弱分类器的更大关注。</p></blockquote><p>第二个问题，弱分类器的组合，AdaBoost采取<strong>加权多数表决</strong>的方法。具体地：</p><p><strong>加大 分类误差率小 的弱分类器的权值，使其在表决中起较大的作用；减小分类误差率大的弱分类器的权值，使其在表决中起较小的作用。</strong></p><p>AdaBoost算法的巧妙之处就在于它将这些学习思路自然并且有效地在一个算法里面实现。</p><h2 id="前向分步加法模型Forward-Stagewise-Additive-Modeling"><a href="#前向分步加法模型Forward-Stagewise-Additive-Modeling" class="headerlink" title="前向分步加法模型Forward Stagewise Additive Modeling"></a>前向分步加法模型Forward Stagewise Additive Modeling</h2><ul><li>加法模型（addtive model）<br>GBDT算法可以看成是由K棵树组成的加法模型：</li></ul><script type="math/tex; mode=display">\hat{y}_i = \sum_{k=1}^K f_k(x_i), f_k \in F \tag 0</script><p>其中$F$为所有树组成的函数空间，以回归任务为例，回归树可以看作为一个把特征向量映射为某个score的函数。该模型的参数为：$\Theta={f_1,f_2, \cdots, f_K }$。于一般的机器学习算法不同的是，加法模型不是学习d维空间中的权重，而是直接学习函数（决策树）集合。</p><p>上述加法模型的目标函数定义为：<script type="math/tex">Obj=\sum_{i=1}^n l(y_i, \hat{y}_i) + \sum_{k=1}^K \Omega(f_k)</script> ，其中 $\Omega$ 表示决策树的复杂度，那么该如何定义树的复杂度呢？比如，可以考虑树的节点数量、树的深度或者叶子节点所对应的分数的$L2$范数等等。</p><ul><li>前向分步算法<br>如何来学习加法模型呢？</li></ul><p>解这一优化问题，可以用前向分布算法（forward stagewise algorithm）。因为学习的是加法模型，如果能够从前往后，每一步只学习一个基函数及其系数（结构），逐步逼近优化目标函数，那么就可以简化复杂度。这一学习过程称之为Boosting。具体地，我们从一个常量预测开始，每次学习一个新的函数，过程如下：</p><script type="math/tex; mode=display">\begin{split}\hat{y}_i^0 &= 0 \\\hat{y}_i^1 &= f_1(x_i) = \hat{y}_i^0 + f_1(x_i) \\\hat{y}_i^2 &= f_1(x_i) + f_2(x_i) = \hat{y}_i^1 + f_2(x_i) \\& \cdots \\\hat{y}_i^t &= \sum_{k=1}^t f_k(x_i) = \hat{y}_i^{t-1} + f_t(x_i) \\\end{split}</script><p>那么，在每一步如何决定哪一个函数$f$被加入呢？指导原则还是最小化目标函数。<br>在第$t$步，模型对$x_i$的预测为：$\hat{y}_i^t= \hat{y}_i^{t-1} + f_t(x_i)$，其中$f_t(x_i)$为这一轮我们要学习的函数（决策树）。这个时候目标函数可以写为：</p><script type="math/tex; mode=display">\begin{split}Obj^{(t)} &= \sum_{i=1}^nl(y_i, \hat{y}_i^t) + \sum_{i=i}^t \Omega(f_i) \\&=  \sum_{i=1}^n l\left(y_i, \hat{y}_i^{t-1} + f_t(x_i) \right) + \Omega(f_t) + constant\end{split}\tag{1}</script><p>举例说明，假设损失函数为平方损失（square loss），则目标函数为：</p><script type="math/tex; mode=display">\begin{split}Obj^{(t)} &= \sum_{i=1}^n \left(y_i - (\hat{y}_i^{t-1} + f_t(x_i)) \right)^2 + \Omega(f_t) + constant \\&= \sum_{i=1}^n \left[2(\hat{y}_i^{t-1} - y_i)f_t(x_i) + f_t(x_i)^2 \right] + \Omega(f_t) + constant\end{split}\tag{2}</script><p>其中，$(\hat{y}_i^{t-1} - y_i)$ 称之为残差（residual）。因此，使用平方损失函数时，GBDT算法的每一步在生成决策树时只需要拟合前面的模型的残差。</p><blockquote><p><strong>泰勒公式</strong>：设$n$是一个正整数，如果定义在$a$一个包含的区间上的函数$f$在$a$点$n+1$处次可导，那么对于这个区间上的任意 $x$ 都有： <script type="math/tex">\displaystyle f(x)=\sum _{n=0}^{N}\frac{f^{(n)}(a)}{n!}(x-a)^ n+R_ n(x)</script>，其中的多项式称为函数在$a$处的泰勒展开式，<script type="math/tex">R_ n(x)</script> 是泰勒公式的余项且是 <script type="math/tex">(x-a)^ n</script> 的高阶无穷小。</p><div style="text-align: right"> ----维基百科 </div><p></p></blockquote><p>根据泰勒公式把函数$f(x+\Delta x)$在点$x$处二阶展开，可得到如下等式：</p><script type="math/tex; mode=display">f(x+\Delta x) \approx f(x) + f'(x)\Delta x + \frac12 f''(x)\Delta x^2 \tag 3</script><p>由等式(1)可知，目标函数是关于变量$\hat{y}_i^{t-1} + f_t(x_i)$的函数，若把变量$\hat{y}_i^{t-1}$看成是等式(3)中的$x$，把变量$f_t(x_i)$看成是等式(3)中的$\Delta x$，则等式(1)可转化为：</p><script type="math/tex; mode=display">Obj^{(t)} = \sum_{i=1}^n \left[ l(y_i, \hat{y}_i^{t-1}) + g_if_t(x_i) + \frac12h_if_t^2(x_i) \right]  + \Omega(f_t) + constant \tag 4</script><p>其中，<script type="math/tex">g_i</script>定义为损失函数的一阶导数，即<script type="math/tex">g_i=\partial_{\hat{y}^{t-1}}l(y_i,\hat{y}^{t-1})</script>；<script type="math/tex">h_i</script>定义为损失函数的二阶导数，即<script type="math/tex">h_i=\partial_{\hat{y}^{t-1}}^2l(y_i,\hat{y}^{t-1})</script>。</p><p>假设损失函数为平方损失函数，则<script type="math/tex">g_i=\partial_{\hat{y}^{t-1}}(\hat{y}^{t-1} - y_i)^2 = 2(\hat{y}^{t-1} - y_i)</script>，<script type="math/tex">h_i=\partial_{\hat{y}^{t-1}}^2(\hat{y}^{t-1} - y_i)^2 = 2</script>，把<script type="math/tex">g_i</script>和<script type="math/tex">h_i</script>代入等式(4)即得等式(2)。</p><p>由于函数中的常量在函数最小化的过程中不起作用，因此我们可以从等式(4)中移除掉常量项，得：</p><script type="math/tex; mode=display">Obj^{(t)} \approx \sum_{i=1}^n \left[ g_if_t(x_i) + \frac12h_if_t^2(x_i) \right]  + \Omega(f_t) \tag 5</script><p>由于要学习的函数仅仅依赖于目标函数，从等式(5)可以看出只需为学习任务定义好损失函数，并为每个训练样本计算出损失函数的一阶导数和二阶导数，通过在训练样本集上最小化等式(5)即可求得每步要学习的函数，从而根据加法模型等式(0)可得最终要学习的模型。</p><hr><p>在给定训练数据及损失函数$L(y,f(x))$的条件下，学习加法模型$f(x)$成为经验风险极小化即损失函数极小化的问题：</p><script type="math/tex; mode=display">\min_{\beta_k, \gamma_k} \quad \sum_{i=1}^{M} L \left[y^{(i)}, \sum_{k=1}^{K} \beta_k b(x^{(i)}; \gamma_k)\right] \qquad(ml.1.6.2)</script><p>通常这是一个复杂的优化问题。前向分布算法（forward stagwise algorithm）求解这一优化问题的思路是：<strong>因为学习的是加法模型，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近优化目标函数式($ml.1.6.1$)，那么就可以简化优化的复杂度。</strong> 具体地，每步只需优化如下损失函数：</p><script type="math/tex; mode=display">\min_{\beta, \gamma} \quad \sum_{i=1}^{M} L(y^{(i)}, \beta b(x^{(i)}; \gamma)) \qquad(n.ml.1.6.1)</script><p>给定训练数据集$D={(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), \cdots, (x^{(M)}, y^{(M)})}, x^{(i)} \in \mathcal{X} \subseteq R^n, y^{(i)} \in \mathcal{Y} = $ ${-1, +1}$。损失函数$L(y,f(x))$和基函数的集合${b(x; \gamma)}$，学习加法模型$f(x)$的前向分步算法如下：</p><script type="math/tex; mode=display">\{ \\   \quad 输入：训练数据集D=\{(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), \cdots, (x^{(M)}, y^{(M)})\}; 损失函数L(y, f(x));\\   \qquad\quad  基函数集\{b(x, \gamma)\}； \\   \quad 输出：加法模型f(x)。 \\   \quad 计算过程：\\   \qquad (1). 初始化f_0(x) = 0 \\   \qquad (2). 对于k=1,2,\cdots,K \\   \qquad\qquad (a). 极小化损失函数 \\   \qquad\qquad\qquad (\beta_k, \gamma_k) = \arg \min_{\beta, \gamma} \sum_{i=1}^{M} L(y^{(i)}, f_{k-1}(x^{(i)}) + \beta b(x; \gamma)) \quad(n.ml.1.6.2)\\   \qquad\qquad 得到参数\beta_k, \gamma_k. \\   \qquad\qquad (b). 更新 \\   \qquad\qquad\qquad f_k(x) = f_{k-1}(x) + \beta_k b(x; \gamma_k) \qquad(n.ml.1.6.3) \\   \qquad (3). 得到加法模型 \\   \qquad\qquad\qquad f(x) = f_K(x) = \sum_{k=1}^{K} \beta_k b(x; \gamma_k) \qquad(n.ml.1.6.4) \\   \}</script><h2 id="GBDT和Random-Forest的区别简要"><a href="#GBDT和Random-Forest的区别简要" class="headerlink" title="GBDT和Random Forest的区别简要"></a>GBDT和Random Forest的区别简要</h2><p>我们再简要说明一下另外一类集成学习的方法，Bagging</p><p>Bagging，装袋。但是这名字其实是由Bootstrap Aggregating（加速聚合）而来。指的是用并行的方案生成各个各个学习器的方案。</p><p>简单的Bagging方案<br>随机森林-一种<strong>Bagging</strong>基础上的变体<br>具体而言，Random Forest通过随机抽样、随机选取特征来产生一棵树，最后通过每棵树的结果做线性结合来产生最终的预测结果。由于每棵树的生成过程不依赖于其他树（和GBDT明显区别，GBDT每棵树的产生需要依赖上一层树的结果），所以树的生成是并行的（这也是其成为Bagging的原因）。在RF中，每棵树都是几乎完全长成（但是仅仅预测了部分样本），树的深度会很大。</p><p><strong>Boosting</strong>方法，每棵树是不能完全长成的，只需要一部分特征就去完成残差的一个迭代降低。个人认为，这特别适合解决这类问题：部分样本就用部分特征就能描述，而另外的样本可能需要其他的特征来描述，比如股票的样本有很多类型的股票，我们有的朋友对一种类型比较擅长，另外的朋友对别的类型比较擅长。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.52caml.com/head_first_ml/ml-chapter6-boosting-family/" target="_blank" rel="noopener">第06章：深入浅出ML之Boosting家族</a></li><li><a href="https://zhuanlan.zhihu.com/p/29765582" target="_blank" rel="noopener">机器学习-一文理解GBDT的原理-20171001</a></li><li><a href="https://www.zybuluo.com/yxd/note/611571#fnref:2" target="_blank" rel="noopener">GBDT算法原理深入解析</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GBDT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LightGBM</title>
      <link href="/LightGBM/"/>
      <url>/LightGBM/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h2><p>在之前我介绍过XGBoost，这次想跟大家分享一下LightGBM，它是一款常用的GBDT工具包，由微软亚洲研究院（MSRA）进行开发。LightGBM论文的标题为A <strong>Highly Efficient</strong> Gradient Boosting Decision Tree。这说明LightGBM它是对于XGB提升性能的版本。而LightGBM相对于其他GBM来说具有相近的准确率而且是其训练速度20倍。</p><h2 id="2-Comparse-with-XGB"><a href="#2-Comparse-with-XGB" class="headerlink" title="2. Comparse with XGB"></a>2. Comparse with XGB</h2><p>LightGBM主要的对比对象就是XGB，所以我们先说一下XGB有什么优缺点先。</p><p><strong>优点：</strong></p><ul><li>XGB利用了二阶梯度来对节点进行划分，相对其他GBM来说，精度更加高。</li><li>利用局部近似算法对分裂节点的贪心算法优化，取适当的eps时，可以保持算法的性能且提高算法的运算速度。</li><li>在损失函数中加入了L1/L2项，控制模型的复杂度，提高模型的鲁棒性。</li><li>提供并行计算能力，主要是在树节点求不同的候选的分裂点的Gain Infomation（分裂后，损失函数的差值）</li><li>Tree Shrinkage，column subsampling等不同的处理细节。</li></ul><p><strong>缺点：</strong></p><ul><li>需要pre-sorted，这个会耗掉很多的内存空间（2 <em> #data </em> # features）</li><li>数据分割点上，由于XGB对不同的数据特征使用pre-sorted算法而不同特征其排序顺序是不同的，所以分裂时需要对每个特征单独做依次分割，遍历次数为#data * #features来将数据分裂到左右子节点上。</li><li>尽管使用了局部近似计算，但是处理粒度还是太细了</li><li>由于pre-sorted处理数据，在寻找特征分裂点时（level-wise），会产生大量的cache随机访问。</li></ul><blockquote><p>因此LightGBM针对这些缺点进行了相应的改进。</p></blockquote><ol><li>LightGBM基于histogram算法代替pre-sorted所构建的数据结构，利用histogram后，会有很多有用的tricks。例如histogram做差，提高了cache命中率（主要是因为使用了leaf-wise）。</li><li>在机器学习当中，我们面对大数据量时候都会使用采样的方式（根据样本权值）来提高训练速度。又或者在训练的时候赋予样本权值来关于于某一类样本（如Adaboost）。LightGBM利用了GOSS来做采样算法。</li><li>由于histogram算法对稀疏数据的处理时间复杂度没有pre-sorted好。因为histogram并不管特征值是否为0。因此我们采用了EFB来预处理稀疏数据。</li></ol><p>下来我们针对这些改进来说明一下。</p><h2 id="3-Histogram算法"><a href="#3-Histogram算法" class="headerlink" title="3 Histogram算法"></a>3 Histogram算法</h2><p>直方图算法的基本思想：先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。遍历数据时，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p><p>LightGBM里默认的训练决策树时使用直方图算法，XGBoost里现在也提供了这一选项，不过默认的方法是对特征预排序，直方图算法是一种牺牲了一定的切分准确性而换取训练速度以及节省内存空间消耗的算法</p><ul><li>在训练决策树计算切分点的增益时，预排序需要对每个样本的切分位置计算，所以时间复杂度是<script type="math/tex">O(\#data)</script>而LightGBM则是计算将样本离散化为直方图后的直方图切割位置的增益即可，时间复杂度为<script type="math/tex">O(\#bins)</script>，时间效率上大大提高了(初始构造直方图是需要一次<script type="math/tex">O(\#data)</script>的时间复杂度，不过这里只涉及到加和操作)</li><li>直方图做差进一步提高效率，计算某一节点的叶节点的直方图可以通过将该节点的直方图与另一子节点的直方图做差得到，所以每次分裂只需计算分裂后样本数较少的子节点的直方图然后通过做差的方式获得另一个子节点的直方图，进一步提高效率。</li><li>节省内存<ul><li>将连续数据离散化为直方图的形式，对于数据量较小的情形可以使用小型的数据类型来保存训练数据</li><li>不必像预排序一样保留额外的对特征值进行预排序的信息</li></ul></li><li>减少了并行训练的通信代价</li></ul><p>现在来看看直方图优化是如何优化的，当然这个优化也是在处理节点分裂的时候。在处理连续特征的时候，如果你想要快速找到最佳的分裂节点要么像之前说到的那样对特征值采用预排序的方式来快速得到最佳的分裂特征值，在这里直方图就是先将特征值先做装箱处理，装箱处理是特征工程中常见的处理方式之一了，下面给个例子说明特征装箱操作。</p><p>[0,0.3)—&gt;0</p><p>[0.3,0.7)—-&gt;1</p><p>就是将某个区间的数据映射到离散的数据值。</p><p>说完了装箱操作现在看一下微软论文中提到的直方图优化的流程图：</p><p><img alt="在这里插入图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126164828201.jpg"></p><p>最外面的 for 循环表示的意思是对当前模型下所有的叶子节点处理，gbdt 会训练多个树模型，这个举例可能是其中任何一个模型吧。</p><p>第二个 for 循环开始要对某个叶子分裂处理处理，这一步就开始遍历所有的特征了，你选取的样本可能有 50、100 或者 1000 维等特征，为了找出的最佳的特征作为分裂的依据，那么这一个 for 循环就是干这件事情。</p><p>依次往下看，对于当前这个特征新建一个直方图，现在又碰到一个 for 循环了 ，这个 for 循环干的事情就是遍历所有的样本来构建直方图，哈哈，此时就用到了之前所描述的装箱操作了，直方图的每个 bin 中包含了一定的样本，在此计算每个 bin 中的样本的梯度之和并对 bin 中的样本记数。</p><blockquote><p>其中<code>f.bins[i]</code>为特征<code>f</code>在样本<code>i</code>的对应bin；<code>H[f.bins[i]]</code>则表示对bin进行累加，该bin就是特征<code>f</code>在样本<code>i</code>的对应bin。</p></blockquote><p>下面就是最后一个 for 循环了，这个开始遍历所有的 bin，找到适合分裂的最佳 bin，解释一下这其中涉及到达变量定义</p><p>$S_L$是当前分裂 bin 左边所有 bin 的集合，对比理解$S_R$，那么$S_P$其中的 P 就是 parent 的意思，就是父节点，传统的决策树会有分裂前后信息增益的计算，典型的 ID3 或者 C45 之类，在这里我们也会计算，但是 $S_R$ 中所有 bin 的梯度之和不需要在额外计算了，直接使用父节点的减去左边的就得到了，是不是觉得很厉害的样子。反正我觉得这点是真的很神奇的地方，虽然看起来很简单，但是也是一个小魔法。</p><p>公式的中 loss 就是来衡量分裂的好坏的，在遍历完所有的特征之后根据 loss，理论上 loss 最小的特征会被选中作为最佳的分裂节点。</p><p>这样的化这个这个直方图优化处理的流程应该就说明白的，基本上都是按照论文中的流程来一步一步解释。下面就来看看这种直方图优化的优缺点吧！</p><p><strong>直方图算法小结：</strong></p><p>优点：</p><ul><li><p>首先，最明显就是内存消耗的降低，因为pre-sorted算法需要保存起来每一个特征的排序结构，所以其需要的内存大小是2 * #data * #feature * 4Bytes（<strong>不仅需要保持每个样本对应的排序存储索引，还要保存每个样本对应每个特征的梯度值，即行为样本，列为特征，中间表格内容为各个样本对应在该特征的值，用float_32保存特征值；但进行split finding时候，需要对每列值进行从小到大排序，故而需要每行样本不仅要保存对应特征下的特征值，还需保存对应特征的排序索引，这个排序索引值用int_32保存</strong>，而histogram只需保存离散值bin value（EFB会谈到bin）而且我们不需要原始的feature value，所以占用的内存大小为：data * # feature * 1Byte，因为离散值bin value使用uint8_t已经足够了，内存消耗可以降低为原来的 1/8。（<strong>bin value本身就是按照大小进行分箱的结果，而histogram更多是将样本特征值映射到直方图上，也正是因为这一特性，故而连排序也省了，再加上分箱的粗粒度操作，最后只需保存bin value即可，用uint_8保存bin value，总体内存消耗降为原来的 1/8。此外也正是这一特性，直方图在内存空间连续存储，这也进一步有助于提高缓存命中率，因为它访问梯度是连续的（直方图）；</strong>）</p><blockquote><p>比如离散为256个Bin时，只需要用8位整形就可以保存一个样本被映射为哪个Bin(这个bin可以说就是转换后的特征)，对比预排序的Exact greedy算法来说（用int_32来存储索引+ 用float_32保存特征值），可以节省7/8的空间。</p></blockquote></li><li><p>计算效率也得到提高，预排序的Exact greedy对每个特征都需要遍历一遍数据，并计算增益，复杂度为O(#feature×#data)。而直方图算法在建立完直方图后，只需要对每个特征遍历直方图即可，复杂度为O(#feature×#bins)。</p></li><li><p>提高缓存命中率，因为它访问梯度是连续的（直方图）。</p></li><li><p>此外，在数据并行的时候，直方图算法可以<strong>大幅降低通信代价。</strong>（数据并行、特征并行在本文后面讲解）</p></li></ul><p>缺点：</p><ul><li>当然，Histogram算法并不是完美的。由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；较粗的分割点<strong>也有正则化的效果</strong>，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在梯度提升（Gradient Boosting）的框架下没有太大的影响。</li><li>预处理能够忽略零值特征，减少训练代价；而直方图不能对稀疏进行优化，只是计算累加值（累加梯度和样本数）。但是，LightGBM 对稀疏进行了优化：只用非零特征构建直方图。</li></ul><p><strong>LightGBM 为何使用直方图这种比较粗的分割节点方法，还能达到比较好的效果？</strong></p><p>虽然分割的精度变差了，但是对最后结果的影响不是很大，主要由于决策树是弱模型， 分割点是不是精确并不是太重要 ；较粗的分割点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在梯度提升（Gradient Boosting）的框架下没有太大的影响。</p><h2 id="4-直方图算法改进"><a href="#4-直方图算法改进" class="headerlink" title="4. 直方图算法改进"></a>4. 直方图算法改进</h2><p>直方图算法仍有优化的空间，建立直方图的复杂度为O(#feature×#data)，如果能<strong>降低特征数</strong>或者<strong>降低样本数</strong>，训练的时间会大大减少。以往的降低样本数的方法中，要么不能直接用在GBDT上，要么会损失精度。而降低特征数的直接想法是去除弱的特征（通常用PCA完成），然而，这些方法往往都假设特征是有冗余的，然而通常特征是精心设计的，去除它们中的任何一个可能会影响训练精度。因此LightGBM提出了GOSS算法和EFB算法。</p><h3 id="4-1-Gradient-based-One-Side-Sampling（GOSS）——用于减少训练样本数（行）"><a href="#4-1-Gradient-based-One-Side-Sampling（GOSS）——用于减少训练样本数（行）" class="headerlink" title="4.1 Gradient-based One-Side Sampling（GOSS）——用于减少训练样本数（行）"></a>4.1 Gradient-based One-Side Sampling（GOSS）——用于减少训练样本数（行）</h3><p>在AdaBoost中，权重向量w很好的反应了样本的重要性。而在GBDT中，则没有这样的直接权重来反应样本的重要程度。但是梯度是一个很好的指标，<strong>如果一个样本的梯度很小，说明该样本的训练误差很小</strong>，或者说该<strong>样本已经得到了很好的训练(well-trained)</strong>。</p><p>要减少样本数，一个直接的想法是抛弃那些梯度很小的样本，但是这样训练集的分布会被改变，可能会使得模型准确率下降。LightGBM提出 Gradient-based One-Side Sampling (GOSS)来解决这个问题。</p><p>GOSS的做法伪代码描述如下：</p><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126164905512.png"></div><p>算法分析：</p><ol><li>根据<strong>梯度的绝对值</strong>将样本进行<strong>降序</strong>排序</li><li>选择前a×100%的样本，这些样本称为A</li><li>剩下的数据(1−a)×100% 的数据中，随机抽取b×100%的数据，这些样本称为B</li><li>在计算增益的时候，放大样本B中的梯度(1−a)/b 倍</li><li>关于g，在具体的实现中是一阶梯度和二阶梯度的乘积，见Github的实现（ LightGBM/src/boosting/goss.hpp）</li></ol><p>使用GOSS进行采样，使得训练算法更加的关注没有充分训练(under-trained)的样本，并且只会稍微的改变原有的数据分布。</p><p>原有的在特征 j 值为 d 处分数据带来的增益可以定义为：</p><script type="math/tex; mode=display">V_{j|O}(d) = \frac{1}{n_O}\left(\frac{(\sum_{x_i\in O:x_{ij} \le d}g_i)^2}{n_{l|O}^j(d)} + \frac{(\sum_{x_i\in O:x_{ij} \gt d}g_i)^2}{n_{r|O}^j(d)} \right)</script><p>其中：</p><ul><li>O为在决策树待分裂节点的训练集</li><li><script type="math/tex; mode=display">n_o = \sum I(x_i \in O)</script></li><li><script type="math/tex; mode=display">n_{l|O}^j(d) = \sum I[x_i \in O: x_{ij} \le d]\ and\ n_{r|O}^j(d) = \sum I[x_i \in O: x_{ij} \gt d]</script></li></ul><p>而使用GOSS后，增益定义为：</p><script type="math/tex; mode=display">V_{j|O}(d) = \frac{1}{n_O}\left(\frac{(\sum_{x_i\in A_l} g_i + \frac{1-a}{b} \sum_{x_i\in B_l} g_i)^2 }{n_{l}^j(d)} + \frac{(\sum_{x_i\in A_r} g_i + \frac{1-a}{b} \sum_{x_i\in B_l} g_r)^2 }{n_{r}^j(d)} \right)</script><p>  其中：</p><ul><li><script type="math/tex; mode=display">A_l = \{x_i \in A: x_{ij} \le d\}, A_r = \{x_i \in A: x_{ij} \gt d\}</script></li><li><script type="math/tex; mode=display">B_l = \{x_i \in B: x_{ij} \le d\}, B_r = \{x_i \in B: x_{ij} \gt d\}</script></li></ul><h3 id="4-2-Exclusive-Feature-Bundling（EFB）——用于减少训练特征（列）"><a href="#4-2-Exclusive-Feature-Bundling（EFB）——用于减少训练特征（列）" class="headerlink" title="4.2 Exclusive Feature Bundling（EFB）——用于减少训练特征（列）"></a>4.2 Exclusive Feature Bundling（EFB）——用于减少训练特征（列）</h3><p>一个有高维特征空间的数据往往是稀疏的，而稀疏的特征空间中，许多特征是互斥的。所谓互斥就是他们从来不会同时具有非0值（一个典型的例子是进行One-hot编码后的类别特征）。</p><p>LightGBM利用这一点提出Exclusive Feature Bundling（EFB）算法<strong>来进行互斥特征的合并，从而减少特征的数目</strong>。做法是先确定哪些互斥的特征可以合并（可以合并的特征放在一起，称为bundle），然后将各个bundle合并为一个特征。</p><p>这样建立直方图的时间将从O(#feature×#data)变为O(#bundle×#data)，而#bundle&lt;&lt;#feature，这样GBDT能在精度不损失的情况下进一步提高训练速度。</p><p>那么，问题来了：</p><ol><li>如何判断哪些特征应该放在一个Bundle中？</li><li>如何将bundle中的特征合并为一个新的特征？</li></ol><h4 id="4-2-1-Greedy-bundle"><a href="#4-2-1-Greedy-bundle" class="headerlink" title="4.2.1 Greedy bundle"></a>4.2.1 Greedy bundle</h4><p>对于第1个问题，将特征划分为最少数量的互斥的bundle是NP问题（可以根据图着色问题来证明）。</p><p>因此，同样采用近似算法。我们可以构建一张图，图上的顶点代表特征，若两个特征<strong>不互斥</strong>，则在他们之间连一条边。</p><p>更进一步的，通常有少量的特征，它们之间并非完全的独立，但是绝大多数情况下，并不会同时取非0值。若构建Bundle的算法允许小的冲突，就能得到更少数的bundle，进一步提高效率。可以证明，随机的污染一部分特征则最多影响精度$O([1-\gamma]n)^{-2/3}$, $\gamma$ 为最大的特征冲突率，也是在速度和精度之间达到平衡的有效手段。</p><p>因此，LightGBM的构建bundle算法描述如下（算法3）：</p><div align="center"><img width="40%" height="40%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126164934564.png"></div><p>即：</p><ol><li>构造带权图G，边的权重代表两个feature之间冲突的数量</li><li>对特征按度降序排序</li><li><p>按顺序对排好序的特征进行遍历，对于当前特征i，查看是否能加入已有的bundle（冲突要小），若不行，则新建一个bundle</p><p>上述的算法复杂度为O(#$feature^2$)，当特征数很大的时候，仍然效率不高。</p></li></ol><p>算法3可以进一步优化：不建立图，<strong>直接按特征的非0值的个数进行排序</strong>。（这也是一种贪心，非0值越多，越可能冲突）。</p><h4 id="4-2-2-Merge-Exclusive-Features"><a href="#4-2-2-Merge-Exclusive-Features" class="headerlink" title="4.2.2 Merge Exclusive Features"></a>4.2.2 Merge Exclusive Features</h4><p>现在来回答第2个问题，我们已经有了一个个的bundle，如何将bundle中的特征合并为一个新的特征呢？</p><p>回想起在直方图算法中，我们将连续的特征变为一个个离散的bins值，这是以特征为粒度的，即一个特征一张直方图。而合并后，一个很关键的点是<strong>合并后原本不同特征的值要有所体现</strong>，这样在新的特征中遍历直方图才能相当于遍历原来好几个直方图，从而找到切分点。</p><p>这可以通过<strong>对原始特征的值添加偏移来实现</strong>，从而将互斥的特征放在不同的bins中。例如，一个Bundle中有两个特征A和B，$A \in [0,10),\ B \in [0,20)$，可以给特征B添加偏移量10，使得B的值域范围变为 $B \in [10,30)$，然后，A和B就可以合并成值域为[0,30]新特征。这就是Merge Exclusive Features（MEF）算法。</p><p>伪代码描述如下：</p><div align="center"><img width="40%" height="40%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126165007914.png"></div><p>通过MEF算法，将许多互斥的稀疏特征转化为稠密的特征，降低了特征的数量，提高了建直方图的效率。</p><h2 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h2><h3 id="5-1-树的生成策略"><a href="#5-1-树的生成策略" class="headerlink" title="5.1 树的生成策略"></a>5.1 树的生成策略</h3><p>在XGBoost中，树是按层生长的，称为<strong>Level</strong>-wise tree growth，同一层的所有节点都做分裂，最后剪枝，如下图所示：</p><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126165050390.png"></div><p>Level-wise过一次数据可以同时分裂同一层的叶子，<strong>容易进行多线程优化</strong>，也好控制模型复杂度，不容易过拟合。<strong>但实际上Level-wise是一种低效的算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。</strong></p><p>而LightGBM采用的是<strong>Leaf</strong>-wise tree growth：</p><blockquote><p>Leaf-wise则是一种更为高效的策略，每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。Leaf-wise的缺点是可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</p></blockquote><p>注：当采用相同叶子节点时候，leaf-wise tree growth 策略比level-wise tree growth 策略，模型准确率更高。</p><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126165309340.png"></div><h3 id="5-2-LightGBM具体优化"><a href="#5-2-LightGBM具体优化" class="headerlink" title="5.2 LightGBM具体优化"></a>5.2 LightGBM具体优化</h3><h4 id="5-2-1-Histogram-optimization"><a href="#5-2-1-Histogram-optimization" class="headerlink" title="5.2.1 Histogram optimization"></a>5.2.1 Histogram optimization</h4><div align="center"><img width="70%" height="70%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126165335641.png"></div><p>一个区间的范围内作为一个bin，简化为以分桶为粒度的直方图来做，这样一来，数据的表示更加简化，减少了内存的适用，而且直方图带来了一定的正则化的效果，使得我们训练出的模型不容易over-fitting到training-data上面，从而具备更好的推广性。</p><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126165939298.png"></div><p>上图是做过直方图优化之后的求解直方图的算法细节。这是按照bin来索引histogram的，所以不需要按照每个feature来排序，也不需要一一地对比不同feature的值，大大地减少了运算量。</p><h4 id="5-2-2-Memory-usage-optimization"><a href="#5-2-2-Memory-usage-optimization" class="headerlink" title="5.2.2 Memory usage optimization"></a>5.2.2 Memory usage optimization</h4><div align="center"><img width="80%" height="80%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126170048718.png"></div><p>当我们用feature的bin来描述数据的特征的时候，带来的变化，首先是我们不需要像预排序算法那样去存储每一个feature排序后对应的data的序列，也就是上图最左边的灰色方块。</p><p>其二是我们使用bin来表示feature，一般bin的个数都是控制在比较小的范围内，这样我们可以使用更少的Byte来存储，如上图，使用Byte来存，而原先的feature value可能是float，需要用4个Bytes来存储。</p><p>所以总体上来说，LightGBM内存的使用量往往会降到XGBoost对应sorted策略的八分之一，</p><h4 id="5-2-3-Leaf-wise-with-max-depth-limitation"><a href="#5-2-3-Leaf-wise-with-max-depth-limitation" class="headerlink" title="5.2.3 Leaf-wise with max depth limitation"></a>5.2.3 Leaf-wise with max depth limitation</h4><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126170109848.png"></div><p>LightGBM使用了带有深度性质的leaf-wise长树的方法，来提高模型的精度；leaf-wise是一种比较level-wise更高效的长树的方法，在叶子数量一样的时候，leaf-wise可以降到更多的训练误差，带来更好的精度。</p><p>但单纯地使用leaf-wise的生长，可能会长出比较深的树，在小数据集上可能会造成过拟合，因此，我们在leaf-wise的基础之上，多加了深度的限制。</p><h4 id="5-2-4-Histogram-subtraction"><a href="#5-2-4-Histogram-subtraction" class="headerlink" title="5.2.4 Histogram subtraction"></a>5.2.4 Histogram subtraction</h4><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126170131803.png"></div><p>LIghtGBM还使用了直方图做差的优化，达到了两倍的加速。</p><p>可以观察到：一个叶子节点的直方图，可以由它的父亲节点的直方图减去它的兄弟节点的直方图得到。</p><p>根据这一点，我们可以构造出来计算 数据量比较小的叶子节点上的直方图，然后用直方图做差，得到数据量较大的叶子节点上的直方图，达到加速的效果。</p><h4 id="5-2-5-Increase-cache-hit-chance"><a href="#5-2-5-Increase-cache-hit-chance" class="headerlink" title="5.2.5 Increase cache hit chance"></a>5.2.5 Increase cache hit chance</h4><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126170158451.png"></div><p>Pre-sorted 的算法当中，有两个操作频繁的地方，会造成cache-miss。</p><ul><li><p>对梯度的访问，在计算gain的时候，需要利用梯度，但不同的feature访问梯度顺序都是不一样的，而且是随机的。</p></li><li><p>对于索引表的访问，pre-sorted使用一个行号和叶子节点号的索引表，防止数据切分的时候，对所有的feature进行切分。对访问梯度一样，所有的feature都要通过访问这个索引表，所以，都是随机的访问，这个时候，会带了非常大的系统性能的下降。</p></li></ul><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126170217435.png"></div><p>LightGBM使用直方图算法则是天然的cache friendly，首先，对梯度的访问，因为不需要对feature进行排序，同时，所有的feature都采用同样的方式进行访问，所以只需要对梯度访问的顺序进行一个重新的排序，所有的feature都能连续地访问梯度。</p><p>此外，直方图算法不需要数据id到叶子id的一个索引表，没有这样一个cache-miss的问题。事实上，在cache-miss这样一个方面，对速度的影响是很大的，尤其在数据量很大的时候，MRSA研究人员进行过测试，在数据量很多的时候，相比于随机访问，顺序访问的速度可以快4倍以上，这其中速度的差异基本上就是由cache-miss而带来的。</p><h4 id="5-2-6-Categorical-feature-support"><a href="#5-2-6-Categorical-feature-support" class="headerlink" title="5.2.6 Categorical feature support"></a>5.2.6 Categorical feature support</h4><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126170238801.png"></div><p>传统的机器学习工具一般，不能直接输入类别特征，需要预先做离散化，抓换为很多，多维的0,1特征，这样的做法无论在时间上还是空间上，效率都不高。</p><p>LightGBM通过更改决策树算法的决策规则，直接原生支持类别特征，不需要额外的离散化。并且通过一些实验，MRSA研究人员验证了直接使用离散特征可以比使用0-1离散化后的特征，速度快到8倍以上 。</p><h4 id="5-2-7-Parallel-Learning-Support"><a href="#5-2-7-Parallel-Learning-Support" class="headerlink" title="5.2.7 Parallel Learning Support"></a>5.2.7 Parallel Learning Support</h4><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2018112617025697.png"></div><p>LightGBM原生支持多种并行算法：</p><ul><li>其中Feature Parallelizaton通常适用于小数据且feature比较多的场景；</li><li>Data Parallelization则适用于数据量比较大，但feature比较少的场景；</li><li>Voting Parallelization则适用于数据量比较大，feature也比较多的场景；</li></ul><p>具体论述看5.3小节。</p><h3 id="5-3-并行计算"><a href="#5-3-并行计算" class="headerlink" title="5.3 并行计算"></a>5.3 并行计算</h3><p>本小节主要根据<a href="https://lightgbm.readthedocs.io/en/latest/Features.html#optimization-in-network-communication" target="_blank" rel="noopener">LightGBM的官方文档</a>中提到的并行计算优化进行讲解。</p><p>在本小节中，<strong>工作的节点称为worker</strong></p><h4 id="5-2-1-特征并行"><a href="#5-2-1-特征并行" class="headerlink" title="5.2.1 特征并行"></a>5.2.1 特征并行</h4><p>特征并行主要是并行化决策树中寻找最优划分点(“Find Best Split”)的过程，因为这部分最为耗时。</p><p><strong>传统算法：</strong></p><p>传统算法的做法如下：</p><ol><li>垂直划分数据（<strong>对特征划分</strong>），不同的worker有<strong>不同的特征集</strong></li><li>每个workers找到局部最佳的切分点{feature, threshold}</li><li>workers使用点对点通信，找到全局最佳切分点</li><li>具有全局最佳切分点的worker进行节点分裂，然后广播切分后的结果（左右子树的instance indices）</li><li>其它worker根据收到的instance indices也进行划分</li></ol><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/LightGBM-feature-parallelization.png"></p><p>传统算法的缺点是：</p><ol><li>无法加速split的过程，该过程复杂度为O(#data)，当数据量大的时候效率不高</li><li>需要广播划分的结果（左右子树的instance indices），1条数据1bit的话，大约需要花费O(#data/8)</li></ol><p><strong>LightGBM中的特征并行</strong></p><p>每个worker<strong>保存所有的数据集</strong>，这样找到全局最佳切分点后各个worker都可以自行划分，就不用进行广播划分结果，减小了网络通信量。过程如下：</p><ol><li>每个workers找到局部最佳的切分点{feature, threshold}</li><li>workers使用点对点通信，找到全局最佳切分点</li><li>每个worker根据全局全局最佳切分点进行节点分裂</li></ol><p>但是这样仍然有缺点：</p><ol><li>split过程的复杂度仍是O(#data)，当数据量大的时候效率不高</li><li>每个worker保存所有数据，存储代价高</li></ol><h4 id="5-2-2-数据并行"><a href="#5-2-2-数据并行" class="headerlink" title="5.2.2 数据并行"></a>5.2.2 数据并行</h4><p><strong>传统算法</strong></p><p>数据并行目标是并行化整个决策学习的过程：</p><ol><li>水平切分数据，不同的worker拥有部分数据</li><li>每个worker根据本地数据构建局部直方图</li><li>合并所有的局部直方图得到全部直方图</li><li>根据全局直方图找到最优切分点并进行分裂</li></ol><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/LightGBM-data-parallelization.png"></p><p>在第3步中，有两种合并的方式：</p><ul><li>采用点对点方式(point-to-point communication algorithm)进行通讯，每个worker通讯量为O(#machine∗#feature∗#bin)</li><li>采用collective communication algorithm(如“<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-collective.html" target="_blank" rel="noopener">All Reduce</a>”)进行通讯（相当于有一个中心节点，通讯后在返回结果），每个worker的通讯量为O(2∗#feature∗#bin)</li></ul><p>可以看出通信的代价是很高的，这也是数据并行的缺点。</p><p><strong>LightGBM中的数据并行</strong></p><ol><li>使用“Reduce Scatter”将不同worker的不同特征的直方图合并，然后workers在局部合并的直方图中找到局部最优划分，最后同步全局最优划分。</li><li>前面提到过，可以通过直方图作差法得到兄弟节点的直方图，因此只需要通信一个节点的直方图。</li></ol><p>通过上述两点做法，通信开销降为O(0.5∗#feature∗#bin)</p><h4 id="5-2-3-Voting-Parallel"><a href="#5-2-3-Voting-Parallel" class="headerlink" title="5.2.3 Voting Parallel"></a>5.2.3 Voting Parallel</h4><p>LightGBM采用一种称为<strong>PV-Tree</strong>的算法进行投票并行(Voting Parallel)，其实这本质上也是一种<strong>数据并行</strong>。</p><p>PV-Tree和普通的决策树差不多，只是在寻找最优切分点上有所不同。</p><p>其算法伪代码描述如下：</p><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/LightGBM-pv-tree.png"></p><ol><li>水平切分数据，不同的worker拥有部分数据。</li><li>Local voting: 每个worker构建直方图，找到top-k个最优的本地划分特征</li><li>Global voting: 中心节点聚合得到最优的top-2k个全局划分特征（top-2k是看对各个worker选择特征的个数进行计数，取最多的2k个）</li><li>Best Attribute Identification： 中心节点向worker收集这top-2k个特征的直方图，并进行合并，然后计算得到全局的最优划分</li><li>中心节点将全局最优划分广播给所有的worker，worker进行本地划分。</li></ol><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/LightGBM-voting-parallelization.png"></p><p>可以看出，PV-tree将原本需要#feature×#bin 变为了2k×#bin，通信开销得到降低。此外，可以证明，当每个worker的数据足够多的时候，top-2k个中包含全局最佳切分点的概率非常高。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>LightGBM 和 XGBoost对比如下：</p><div align="center"><img width="60%" height="60%" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/LightGBM-VS-XGBoost.png"></div><h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol><li><p>引入bundles之后，将互斥（近似互斥）的特征放在一起，原来是每个特征对应一个直方图，意味着每个bundle对应着多个直方图（对应bundle有几个特征，则对应几个直方图），现在通过引入偏移，将bundles里的互斥特征引入到一个直方图中，这样，就将每个bundle中互斥（不同时出现非零值）的稀疏特征转换为稠密的单特征（每个bundle对应一个特征），大大降低了计算量。</p></li><li><p>在Greedy Bunding中，判断是否将一个特征加入现在有的bundles中的判定方法是</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt  = ConflictCnt(bundles[j], F[i])</span><br><span class="line">if cnt + bundlesConflict &lt;= K then</span><br><span class="line">bundles[j].add(F[i]), needNew = False</span><br></pre></td></tr></tbody></table></figure><p>即不仅考虑了当前特征与bundle的冲突数（即当前特征与bundle中任意特征同时存在的个数），也考虑了bundle内部累积的冲突数。</p></li><li><p>AdaBoost与Gradient Boosting区别：</p><p><img alt="在这里插入图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2018112617035394.png"></p><ul><li><p>Adaboost：<strong>Emphases error by changing the distribution of samples.</strong></p></li><li><p>Gradient Boosting: <strong>Emphases error by changing training targets.</strong></p><p>Adaboost主要是根据当前的loss来改变样本的权重，也就是说这个样本，在当前的学习过程中误差比较大，那么在下一轮，会给他分配一个比较大的权重，反之，如果当前轮该样本的loss比较小，在下一轮训练中就会给样本赋予一个更小的权重；从而控制了接下来子模型的产生。</p><p>Gradient boosting则是直接去修改样本的label，实际上新的样本的label将会变成原来的label与集成中模型预测值之间的残差。</p><p>从直观上来看，Gradient Boosting似乎更加针对降低训练误差的角度去完成算法设计。</p></li></ul></li><li><p>Gradient Boosting</p></li></ol><p><img alt="在这里插入图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126170425907.png"></p><p>   对Gradient Boosting，完整的模型是由很多base learner组成的，学习过程当中，是一个个增加这些子模型，并在这个过程当中，希望loss能不断减小，如果我们把符合函数 f 当做自变量来看，我们希望能能够改变这个符合函数 f 使得loss下降，那么无疑沿着loss相对于 f 的梯度方向是一个合理的选择。换句话说，我们新加入的子模型，使得 f 沿着loss相对于f的梯度方向变了，那么我就得到了我们希望要的新一轮的子模型 f。</p><p>   当损失函数用平法损失时候，新加入的 f 沿着 loss的梯度方向进行拟合，其实质就是拟合残差 $\hat{y}<em>i = y_i - F</em>{m-1}(x_i)$</p><ol><li><p>AdaBoost, XGBoost, LightGBM三者联系与区别</p><p>Boosting是一个集成策略，其主要包含两种实现方式，一种是AdaBoost，一种是GBDT，其中：</p><ul><li><p>Adaboost：<strong>Emphases error by changing the distribution of samples.</strong></p></li><li><p>Gradient Boosting: <strong>Emphases error by changing training targets.</strong></p></li></ul></li></ol><pre><code> XGBoost与Lightgbm都是Gradient Boosting的实现框架（工具包，两篇论文都明确说明两者是"a gradient boosting framework"）（注：是Gradient Boosting的实现架构而非GBDT的实现架构，因此也常有面试官经常追问XGBoost与GBDT的区别），而GBDT也是Gradient Boosting的一种实现，只是限定比较多，如基学习器为cart树，损失函数虽然会依据分类或者回归需要进行选择，但都是在现有损失函数的基础上进行操作，不支持自定义损失函数功能，训练模型只是用梯度一阶导等。 而XGBoost则在GBDT的基础上进行了扩展，不再局限于基模型为树模型，同样也支持基模型为线性模型（包括线型回归与logistic回归），支持损失函数自定义，加入正则项等； 而LIghtgbm则是在XGBoost的基础上做了一些模型训练加速工作，具体见上文。 &gt; 注：XGBoost在GBDT的基础上又加入了正则项，并不是说GBDT不含正则项，事实上，GBDT支持L1，L2正则项，只是XGBoost在L1或L2的基础上进一步引入了正则项 $\gamma T$，其中$T$为叶子节点数。（同样用于限制过拟合）</code></pre><ol><li>XGBoost 两种树生成方案优劣：</li></ol><div align="center"><img width="60%" height="60%" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181126170451256.png"></div><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://papers.nips.cc/paper/6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree.pdf" target="_blank" rel="noopener">LightGBM: A Highly Efficient Gradient Boosting Decision Tree</a></li><li><a href="http://papers.nips.cc/paper/6380-a-communication-efficient-parallel-algorithm-for-decision-tree" target="_blank" rel="noopener">A Communication-Efficient Parallel Algorithm for Decision Tree</a></li><li><a href="https://www.deeplearn.me/2315.html" target="_blank" rel="noopener">LightGBM之直方图优化理解</a></li><li><a href="https://v.qq.com/x/page/k0362z6lqix.html" target="_blank" rel="noopener">如何玩转LightGBM</a></li><li><a href="https://www.hrwhisper.me/machine-learning-lightgbm/" target="_blank" rel="noopener">细语呢喃：集成学习（四）LightGBM</a></li><li><a href="https://github.com/duboya/CTR-Prediction/blob/master/LightGBM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93.ipynb" target="_blank" rel="noopener">LightGBM论文阅读总结.ipynb</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LightGBM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XGBoost</title>
      <link href="/XGBoost/"/>
      <url>/XGBoost/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>XGBoost的可扩展性(scalability)归因于一些重要的系统优化和算法优化。这些优化包括：</p><ul><li>一种新的tree-learning算法(a novel tree learning algorithm)：用于处理稀疏数据(sparse data)</li><li>一种理论正确的加权分位数略图过程（a theoretically justified weighted quantile sketch procedure）：用于处理在近似的tree-learning中实例权重</li></ul><p>由于XGBoost的<strong>并行化和分布式计算</strong>，使得learning过程比其它模型实现要快。更重要地，XGBoost实现了<strong>核外计算(out-of-core computation: 基于外存)</strong>，使得数据科学家们可以在pc机上处理上亿的训练实例。最终，会把这些技术结合起来实现一个end-to-end的系统，可以扩展到集群上。</p><p>主要内容：</p><ul><li>1.设计和建立了一个高度可扩展的<strong>end-to-end tree boosting系统</strong></li><li>2.提出了一种<strong>理论正确的加权分位数略图过程(theoretically justified weighted quantile sketch procedure)</strong>，用于高效地进行预计算</li><li>3.介绍了一种新的<strong>稀疏感知算法（sparsity-aware algorithm）</strong>，用于并行化tree learning</li><li>4.提出了一种高效的<strong>内存感知块结构（cache-aware block structure）</strong>，用于核外（out-of-core）tree learning</li></ul><h2 id="2-XGBoost-算法"><a href="#2-XGBoost-算法" class="headerlink" title="2. XGBoost 算法"></a>2. XGBoost 算法</h2><p>XGBoost的方法源自于Friedman的二阶方法。XGBoost在正则化目标函数上做了最小的改进。</p><h3 id="2-1-正则化目标函数"><a href="#2-1-正则化目标函数" class="headerlink" title="2.1 正则化目标函数"></a>2.1 正则化目标函数</h3><p>对于一个含<strong>n个训练样本，m个features</strong>的结定数据集：$D = {(x_i,y_i)} (|D|=n, x_i \in R^m, y_i \in R)$，所使用的tree ensemble model使用<strong>K次求和函数</strong>来预测输出：</p><script type="math/tex; mode=display">\hat{y_{i}} = \phi(x_i) = \sum_{k=1}^{K} f_k(x_i), f_k \in F  \tag 1</script><p>其中，$F = {f(x)=w_{q(x)}}，满足(q: R^m \rightarrow T, w \in R^T)$，是回归树(CART)的空间。<strong>q表示每棵树的结构</strong>，它会将一个训练样本实例映射到相对应的叶子索引上。<strong>T是树中的叶子数</strong>。<strong>每个$f_k$对应于一个独立的树结构q和叶子权重w</strong>。与决策树不同的是，每棵回归树包含了在每个叶子上的一个连续分值，<strong>我们使用$w_i$来表示第i个叶子上的分值</strong>。对于一个给定样本实例，我们会使用树上的决策规则(由q给定)来将它分类到叶子上，并通过将相应叶子上的分值(由w给定)做求和，计算最终的预测值。为了在该模型中学到这些函数集合，我们会对下面的正则化目标函数做最小化：</p><script type="math/tex; mode=display">L(\phi) = \sum_{i}l(\hat{y_i}, y_i) + \sum_{i}\Omega(f_k)  \tag 2</script><p>其中：$\Omega(f) = \gamma T + \frac{1}{2}\lambda||\omega||^2$</p><p>其中，$l$ 是一个可微凸loss函数（differentiable convex loss function），可以计算预测值 $\hat{y_i}$ 与目标值 $y_i$ 间的微分。第二项 $\Omega$ 会惩罚模型的复杂度。正则项可以对最终学到的权重进行平滑，避免overfitting。相类似的正则化技术也用在RGF模型(正则贪婪树)上。XGBoost的目标函数与相应的学习算法比RGF简单，更容易并行化。当正则参数设置为0时，目标函数就相当于传统的gradient tree boosting方法。</p><h3 id="2-2-Gradient-Tree-Boosting"><a href="#2-2-Gradient-Tree-Boosting" class="headerlink" title="2.2 Gradient Tree Boosting"></a>2.2 Gradient Tree Boosting</h3><p>等式（2）中的tree ensemble模型将函数作为参数，不能使用在欧拉空间中的传统优化方法进行优化。模型以一种叠加的方式进行训练。正式地，<strong>$\hat{y_i}^{(t)}$为第i个实例在第t次迭代时的预测</strong>，我们需要添加 $f_t$，然后最小化下面的目标函数：</p><script type="math/tex; mode=display">L^{(t)} = \sum_{i=1}^{n}l(y_i, \hat{y_i}^{(t-1)}+f_t(x_i)) + \Omega(f_t)</script><p>这意味着，我们贪婪地添加 $f_t$，根据等式(2)尽可能地提升模型。使用<strong>二阶近似</strong>可以快速优化目标函数。</p><script type="math/tex; mode=display">L^{(t)} \backsimeq \sum_{i=1}^{n} [l(y_i,\hat{y}^{(t-1)}) + g_i f_t(x_i) + \frac{1}{2} h_i f_t^{2}(x_i)] + \Omega(f_t)</script><p>其中，<script type="math/tex">g_i = \partial_{\hat{y}^{(t-1)}} l(y_i,\hat{y}^{(t-1)})</script>， <script type="math/tex">h_i = {\partial}_{\hat{y}^{(t-1)}}^{2} l(y_i, \hat{y}^{(t-1)})</script> 分别是loss function上的一阶梯度和二阶梯度。我们可以移除常数项，从而获得如下所示的<strong>在t次迭代时的简化版目标函数</strong>：</p><script type="math/tex; mode=display">L^{(t)} = \sum_{i=1}^{n} [g_i f_t(x_i) + \frac{1}{2} h_i f_t^{2}(x_i)] + \Omega(f_t) \tag 3</script><p>我们定义$I_j= { i | q(x_i)=j }$是叶子 j 的实例集合。将(3)式进行重写，并展开 $Ω$ 项：</p><script type="math/tex; mode=display">L^{(t)} = \sum_{i=1}^{n} [g_i f_t(x_i) + \frac{1}{2} h_i f_t^{2}(x_i)] + \gamma T + \frac{1}{2}\lambda\sum_{j=1}^{T}w_{j}^{2} \\= \sum_{j=1}^{T}[(\sum_{i \in I_j} g_i)w_j + \frac{1}{2}(\sum_{i \in I_j}h_i+\lambda)w_{j}^{2}]+\gamma T \tag 4</script><p>对于一个确定的结构q(x)，我们可以计算最优的权重 $w_j^{\ast}$：</p><script type="math/tex; mode=display">w_j^{\ast}=-\frac{\sum_{i \in I_j}g_i}{\sum_{i \in I_j}h_i+\lambda} \tag 5</script><p>代入(5)计算得到对应的loss最优解为：</p><script type="math/tex; mode=display">L^{(t)}(q)=-\frac{1}{2} \sum_{j=1}^{T}\frac{(\sum_{i \in I_j}g_i)^2}{\sum_{i \in I_j}h_i+\lambda} + \gamma T \tag 6</script><p><strong>等式(6)可以作为一个得分函数（scoring function）来衡量一棵树结构q的质量（quality）</strong>。该分值类似于决策树里的不纯度(impurity score)，只不过它从一个更宽范围的目标函数求导得到。图2展示了该分值是如何被计算的。</p><p>  <img alt="img" data-src="http://pic.yupoo.com/wangdren23/GuX11b5Q/medish.jpg"></p><p>图2:结构得分(structure score)计算。我们只需要在每个叶子上对梯度和二阶梯度统计求和，然后应用得分公式（scoring formula）来获得质量分（quality score）。</p><p>通常，<strong>不可能枚举所有可能的树结构q</strong>。而贪婪算法会从单个叶子出发，迭代添加分枝到树中。<strong>假设$I_L$和$I_R$是一次划分(split)后的左节点和右节点所对应的实例集合</strong>。$I=I_L \bigcup I_R$，接着，在split之后的loss reduction为：</p><script type="math/tex; mode=display">L_{split}=\frac{1}{2}[ \frac{(\sum_{i \in I_L}g_i)^2}{\sum_{i \in I_L}h_i+\lambda} + \frac{(\sum_{i \in I_R}g_i)^2}{\sum_{i \in I_R}h_i+\lambda} - \frac{(\sum_{i \in I}g_i)^2}{\sum_{i \in I}h_i+\lambda}] - \gamma \tag 7</script><p>该式通常在实际中用于评估split的候选（split candidates）。</p><h3 id="2-3-Shrinkage和列子抽样-column-subsampling"><a href="#2-3-Shrinkage和列子抽样-column-subsampling" class="headerlink" title="2.3 Shrinkage和列子抽样(column subsampling)"></a>2.3 Shrinkage和列子抽样(column subsampling)</h3><p>除了2.1节所提到的正则化目标函数外，还会使用两种额外的技术来进一步阻止overfitting。<strong>第一种技术是Friedman介绍的Shrinkage</strong>。Shrinkage会在每一步tree boosting时，<strong>会将新加入的weights通过一个因子$η$进行缩放</strong>。与随机优化中的learning rate相类似，对于用于提升模型的新增树(future trees)，shrinkage可以减少每棵单独的树、以及叶子空间（leaves space）的影响。<strong>第二个技术是列特征子抽样(column feature subsampling)</strong>。该技术也会在RandomForest中使用，在商业软件TreeNet中的gradient boosting也有实现，但开源包中没实现。根据用户的反馈，比起传统的行子抽样（row sub-sampling：同样也支持），使用列子抽样可以阻止overfitting。列子抽样的使用可以加速并行算法的计算(后面会描述)。</p><h2 id="3-SPLIT-FINDING-ALGORITHMS"><a href="#3-SPLIT-FINDING-ALGORITHMS" class="headerlink" title="3. SPLIT FINDING ALGORITHMS"></a>3. SPLIT FINDING ALGORITHMS</h2><h3 id="3-1-Basic-Exact-Greedy-Algorithm"><a href="#3-1-Basic-Exact-Greedy-Algorithm" class="headerlink" title="3.1 Basic Exact Greedy Algorithm"></a>3.1 Basic Exact Greedy Algorithm</h3><p>tree learning的其中一个关键问题是，找到等式(7)的最好划分(best split)。为了达到这个目标，<strong>split finding算法</strong>会在所有特征（features）上，枚举所有可能的划分（splits）。我们称它为“<strong>完全贪婪算法(exact greedy algorithm)</strong>”。许多单机版tree-boosting实现中，包括scikit-learn，R’s gbm以及单机版的XGBoost，都支持完全贪婪算法(exact greedy algorithm)。该算法如算法1所示。它会对连续型特征（continuous features）枚举所有可能的split。为了更高效，该算法必须首先根据特征值对数据进行排序，以有序的方式访问数据来枚举等式(7)中的结构得分（structure score）的梯度统计(gradient statistics)。</p><p><img alt="在这里插入图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181120132853309.png"><br>[算法1]</p><p>(1) for j in sorted(I, by $x_{jk}$)：表示对第m个特征，对叶子节点j，依据特征k进行对该节点内的所有实例进行从小到大的排序，依据下面Score公式计算该split下的Score。</p><p>(2) 算法总结：对每个叶子节点j，对叶子节点的每个特征k，依据k对实例进行排序，然后计算该特征下的Score，对该叶子节点，遍历所有特征后，得到该节点下对应的score及split进行输出（即最佳割特征下对应的最佳分割点）。</p><p>(3) However, it is impossible to efficiently do so when the data does notfit entirely into memory.</p><h3 id="3-2-Approximate-Algorithm"><a href="#3-2-Approximate-Algorithm" class="headerlink" title="3.2 Approximate Algorithm"></a>3.2 Approximate Algorithm</h3><p>前面提到过，XGBoost每一步选能使分裂后增益最大的分裂点进行分裂。而分裂点的选取之前是枚举所有分割点，这称为精确的贪心法（Exact Greedy Algorithm）.</p><p><strong>当数据量十分庞大，以致于不能全部放入内存时，Exact Greedy 算法就会很慢。</strong> 因此XGBoost引入了近似的算法。</p><p>我们总结了一个近似框架（approximate framework），重组了在文献[17,2,22]中提出的思想，如算法2所示。为了进行总结(summarize)，<strong>该算法会首先根据特征分布的百分位数(percentiles of feature distribution)，提出候选划分点(candidate splitting points)。接着，该算法将连续型特征映射到由这些候选点划分的分桶(buckets)中，聚合统计信息，基于该聚合统计找到在建议（proposal）间的最优解</strong>。</p><p>简单的说，就是根据特征 $k$ 的分布来确定 $l$ 个候选切分点 <script type="math/tex">S_k=\{s_{k1}, s_{k2}, \dots,s_{kl}\}</script>，然后根据这些候选切分点把相应的样本放入对应的<strong>桶</strong>中，对每个桶的G,H进行累加。最后在候选切分点集合上贪心查找，和Exact Greedy Algorithm类似。该算法描述如下：</p><p><img alt="在这里插入图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181120133022856.png"><br>[算法2]</p><blockquote><p><strong>算法讲解：</strong><br>第一个<code>for</code>循环做的工作：对特征<code>K</code>根据该特征分布的分位数找到切割点的候选集合 $S<em>k=s</em>{k1},s<em>{k2},…,s</em>{kl}$ ，这样做的目的是提取出部分的切分点不用遍历所有的切分点。其中获取某个特征<code>K</code>的候选切割点的方式叫<code>proposal</code>。主要有两种<code>proposal</code>方式：<code>global proposal</code>和<code>local proposal</code>。<br>第二个<code>for</code>循环的工作：将每个特征的取值映射到由这些该特征对应的候选点集划分的分桶(buckets)区间 <script type="math/tex">\{s_{k,v}≥x_{jk}>s_{k,v−1}\}</script> 中，对每个桶（区间）内的样本统计值 $G$, $H$ 进行累加统计，最后在这些累计的统计量上寻找最佳分裂点。这样做的主要目的是获取每个特征的候选分割点的 $G$, $H$ 量。</p></blockquote><p>给定了候选切分点后，一个例子为：</p><p><img alt="在这里插入图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181120133105821.png"></p><p>分桶当然是越多越好，但越多意味计算量也就更大，极端情况下就是一个数据一个桶，但这违背了分桶的初衷。所有，需要综合balance考虑。</p><p>那么，现在有两个问题：</p><ol><li>如何选取候选切分点 <script type="math/tex">S_k=\{s_{k1}, s_{k2}, \dots,s_{kl}\}</script> 呢？</li><li>什么时候进行候选切分点的选取？</li></ol><p>第1个问题在下一小节说明，先回答第2个问题。</p><p>还有一种近似的方法，就是不逐一过样本，而是对于当前特征，选择几个分位点，利用这些分位点来将连续特征值映射成独立的分桶，然后用这些聚合后的信息来进行后续的分裂。</p><h4 id="分界点选取时机"><a href="#分界点选取时机" class="headerlink" title="分界点选取时机"></a>分界点选取时机</h4><p>对于问题2，XGBoost具体实施时，有两者方式：global variant 和local variant ，前者是在每棵树开始之前就分好，后续不再改变；而后者是在每个节点上都具体情况具体分析的考虑。</p><ul><li>Global： <strong>学习每棵树前</strong>， 提出候选切分点</li><li>Local： <strong>每次分裂前</strong>， 重新提出候选切分点</li></ul><p>由于global variant后续不再改变，因此往往需要更多的候选点。（However, usually more candidate points are needed for the global proposal because candidates are not refined after each split.）</p><p>当然，后者更好，但带来的复杂度也更大。通常情况下，都会优先选用global的形式。</p><p>可以预见到的是，local不用像global方式那样设定分桶分的很细，因为它是有针对性的设置，可以在很粗粒度上就达到相同的效果。</p><p>对比如下：<br><img alt="在这里插入图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2018112013333025.png"></p><p>从实验结果可以看到：</p><p>（1） 在全局分桶分的很细时，和exact greedy效果几乎完全相同。（紫色，蓝色）</p><p>（2） 当local较大时，几乎可以达到global较小值一样的效果。（紫色，绿色）</p><p>（3） 当global设置过大时，整体效果就很差了。（蓝色，红色）</p><p>此外，桶的个数等于 1 / eps， 不难得出结论:</p><ul><li>全局切分点的个数够多的时候，和Exact greedy算法性能相当。</li><li>局部切分点个数不需要那么多，因为每一次分裂都重新进行了选择。</li></ul><h3 id="3-3-Weighted-Quantile-Sketch-加权分位数略图"><a href="#3-3-Weighted-Quantile-Sketch-加权分位数略图" class="headerlink" title="3.3 Weighted Quantile Sketch(加权分位数略图)"></a>3.3 Weighted Quantile Sketch(加权分位数略图)</h3><p>对于问题1，可以采用分位数，也可以直接构造梯度统计的近似直方图等。</p><p>先补充一下分位数相关知识：</p><h4 id="3-3-1-分位点及分位数补充介绍"><a href="#3-3-1-分位点及分位数补充介绍" class="headerlink" title="3.3.1 分位点及分位数补充介绍"></a>3.3.1 <strong>分位点及分位数补充介绍</strong></h4><p><strong>分位点 (quantile) 介绍：</strong></p><p><strong>举例子说明</strong>，一般来说对于一个数据列表有：</p><blockquote><p>input：14, 19, 3, 15, 4, 6, 1, 13, 13, 7, 11, 8, 4, 5, 15, 2<br>sort： 1, 2, 3, 4, 4, 5, 6, 7, 8, 11, 13, 13, 14, 15, 15, 19<br>rank： 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16</p></blockquote><p><code>ϕ−quantile</code>表示 <code>rank= ϕ−quantile × N</code>的元素。我们需要取出<code>0.25-quantile</code>（0.25分位点的数），即取出 rank 为 $0.25 \times N$ 的数。</p><p><strong>加权分位点 (Weighted quantile) 介绍：</strong></p><p><strong>举例子说明</strong>，一般来说对于一个数据列表有：</p><blockquote><p>input： 1, 2, <strong>3</strong>, 4, 5<br>weight：0.1, 0.2, 0.2, 0.3, 0.5<br>rank： 0.1, 0.3, <strong>0.5</strong>, 0.8, 1.3</p></blockquote><p>取元素的方法为：指定 rank（大于0 小于1）即可，如 0.5 分位点的元素为3。</p><p><strong>分位数缩略图 (Quantile Sketch)</strong></p><p><strong>原因：</strong> 当一个序列无法全部加载到内存时，常常采用分位数缩略图近似的计算分位点，以近似获取特定的查询。</p><p><strong>方式：</strong><br>使用随机映射 (Random projections) 将数据流投射在一个小的存储空间内作为整个数据流的概要，这个小空间存储的概要数据称为略图，可用于近似回答特定的查询。<strong>需要保留原序列中的最小值和最大值。</strong></p><p><strong>近似算法中的分位数缩略图 (Weighted Quantile Sketch)</strong></p><p>如何根据特征分布的分位数挑选出候选点集？</p><p>通常一个特征的百分位数可以被用来让候选在数据上进行均匀地分布。<strong>创建</strong>一个 <strong>multi-set</strong>：<script type="math/tex">D_k=\left\{ \left( x_{1k},h_1 \right),\left( x_{2k},h_2 \right),...,\left( x_{nk},h_n \right) \right\}</script>， $n$ 是样本个数。</p><blockquote><p>$D_k$表示第 $k$ 个特征$feature_k$ 与二阶偏导 $H$ 之间的集合【每个训练实例的第 $k$ 个特征值以及它的二阶梯度值统计。其中 $h_i$ 表示 $i$  个实例的第 $k$ 个特征值对应的二阶梯度值统计，可看作 $i$ 个实例的第 $k$ 个特征值的权重。】</p></blockquote><p>一般来说对于加权分位数缩略图的取值是根据 Rank 值进行的，Rank 计算公式如下：</p><p><strong>定义序列函数</strong> <script type="math/tex">r_k$：$r_k(z) = \frac{\sum_{(x,h) \in D_k, x<z}{h}}{\sum_{(x,h) \in D_k}{h}}</script></p><blockquote><p>该<code>Rank</code>函数，输入为某个特征值<code>z</code>，计算的是该特征所有可取值中小于<code>z</code>的特征值的总权重 占总的所有可取值的总权重和的比例，输出为一个比例值。</p></blockquote><p>于是就使用下面这个不等式<strong>寻找候选分割点</strong>  <script type="math/tex">\left\{ s_{k1}, s_{k2}, ..., s_{kl} \right\}</script></p><script type="math/tex; mode=display">|r_k(s_{k,j}) - r_k(s_{k,j+1})| < \epsilon , \ \ s_{k1}=\min_i x_{ik} , s_{kl} =\ max_i {x}_{ik}</script><blockquote><p>其中： <script type="math/tex">s_{k1}</script> 是特征 $k$ 的取值中最小的值 <script type="math/tex">{x}_{ik}</script>, <script type="math/tex">s_{kl}</script> 是特征 $k$ 的取值中最大的值 <script type="math/tex">{x}_{ik}</script>，这是分位数缩略图的要求 <strong>需要保留原序列中的最小值和最大值</strong> 。<script type="math/tex">\epsilon</script>  是一个近似比例，或者说是扫描步幅。可以理解为在特征 $k$ 的取值范围上，按照步幅，挑选出特征 $\epsilon$ 的取值候选点，组成候选点集。起初是从 <script type="math/tex">s_{k1}</script> 起，每次增加 <script type="math/tex">ϵ \times (s_{kl}−s_{k1})</script> 作为候选点，加入到候选集中。如此计算的话，这意味着大约是 <script type="math/tex">1/ϵ</script>个候选点。</p></blockquote><p>此时特征 $k$ 的取值中 <script type="math/tex">\min_i {x}_{ik} , \max_i {x}_{ik}</script> 来自 <strong>multi-set</strong> $D_k$，对于 $D_k$ 的数据集有两种定义：</p><blockquote><p>(1) 一开始选好，然后每次树切分都不变，也就是说是在总体样本里选 $\min<em>i {x}</em>{ik} , \max<em>i {x}</em>{ik}$，这就是我们之前定义的<code>global proposal</code>；<br>(2) 是树每次确定好切分点的分割后样本也需要进行分割，$\min<em>i {x}</em>{ik} , \max<em>i {x}</em>{ik}$来自子树的样本集 $D_k$ ，这就是<code>local proposal</code>。</p></blockquote><p>关于 <code>global &amp; local</code>来自 <a href="http://link.zhihu.com/?target=http%3A//d0evi1.com/xgboost/" target="_blank" rel="noopener">解析XGBoost</a> 的解读：</p><blockquote><p><strong>全局变种（global variant）</strong> 会在树构建的初始阶段，建议所有的候选划分，并在所有的层级（level）上使用相同的建议。<strong>局部变种（local variant）</strong>则在每次划分后重新建议（re-proposes）。比起局部法，全局法需要更少的建议步骤。然而，对于全局建议，通常需要更多的候选点，因为在每次划分之后，不需要重新定义候选。局部建议会在每次划分后重新定义候选，对于更深的树更合适。原文图3展示了在Higgs boson数据集上不同算法的比较。发现局部建议确实需要更少的候选。如果两者的候选一样多，全局建议比局部建议会更精确。</p><p>注：global variant 与 local variant 的差别主要体现在候选点建议上，global variant 想要一劳永逸，在树构建的初始阶段，直接提出所有的候选可能切分点，以后进行进行split finding 就直接在这些候选点中进行增益计算，进而得到每个节点下的最佳切分特征及最佳切分点；而local variant 则是采用每次进行节点split finding 时，重新确认候选可能切分点，重新确认候选的过程与global variant 一样，但由于各个节点覆盖的样本不一样了，故而其重新确定候选可以带来更精确的候选划分，带也大大提升了计算量。</p></blockquote><p>而XGBoost不单单是采用简单的分位数的方法，而是<strong>对分位数进行加权（使用二阶梯度h</strong>），称为：Weighted Quantile Sketch。PS:上面的那个例子采用的是没有使用二阶导加权的分位数。</p><p>对特征 $k$ 构造multi-set 的数据集：<script type="math/tex">D_k= {(x_{1k}, h_1) , (x_{2k},h_2) , …,(x_{nk},h_n) }</script>, 其中 <script type="math/tex">x_{ik}</script>表示样本 $i$ 的特征 $k$ 的取值，而 <script type="math/tex">h_i</script> 则为对应的二阶梯度。</p><p>可以定义一个rank function为：</p><script type="math/tex; mode=display">% <![CDATA[r_{k}(z)=\frac{1}{\sum_{(x,h) \in D_k} h} \sum_{(x,k) \in D_k,x<z}^{} h %]]></script><p>它表示<strong>相应第k个特征上的输入值小于z的实例的占比</strong>。和之前的分位数挺相似，不过这里是按照二阶梯度进行累计。而候选切分点 <script type="math/tex">\{s_{k1}, s_{k2}, …, s_{kl}\}</script>要求：</p><script type="math/tex; mode=display">|r_k(s_{k,j})-r_k(s_{k,j+1})|<\varepsilon,\hspace{5ex} s_{k1}= \min_i x_{ik}, \ s_{kl}=\max_i x_{ik}</script><p>用大白话说就是让相邻两个候选分裂点相差不超过某个值 $\epsilon$。因此，总共会得到 $\frac{1}{\epsilon}$​ 个切分点。</p><p>一个例子如下：</p><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/XGBoost-approximate-algorithm-for-split-finding-example-with-second-gradient-weighted.png"></p><p>其中 $\epsilon$ 是近似因子（approximation factor）。直觉上，这意味着大约是 $\frac{1}{\epsilon}$ 个候选点。这里，<strong>每个数据点通过 $h_i$ 加权</strong>。为什么$h_i$可以表示权重呢？我们可以重写(3)式：</p><p>要切分为3个，总和为1.8，因此第1个在0.6处，第2个在1.2处。</p><p>那么，<strong>为什么要用二阶梯度加权</strong>？将前面我们泰勒二阶展开后的目标函数2-4进行配方：</p><script type="math/tex; mode=display">\sum_{i=1}^N\left(g_if_t({\bf x_i}) + \frac{1}{2}h_if_t^2({\bf x_i})\right) + \Omega(f_t)\\= \sum_{i=1}^N\frac{1}{2}h_i\left(2\frac{g_i}{h_i}f_t({\bf x_i}) + f_t^2({\bf x_i})\right) + \Omega(f_t) \\=\sum_{i=1}^N \frac{1}{2}h_i\left(\frac{g_i^2}{h_i^2} +2\frac{g_i}{h_i}f_t({\bf x_i}) + f_t^2({\bf x_i})\right) + \Omega(f_t) \\=\sum_{i=1}^N \frac{1}{2}{\color{red}h_i}\left( f_t({\bf x_i}) – ({\color{red}- \frac{g_i}{h_i}})\right)^2 + \Omega(f_t) \tag{8}</script><p>推导第三行可以加入 $\frac{g_i^2}{h_i^2}$ 是因为 $g_i$ 和 $h_i$ 是上一轮的损失函数求导，是常量。</p><p>从式8可以看出，<strong>就像是标签为 $-g_i/h_i$，权重为 $h_i$ 的平方损失，因此用 $h_i$ 加权。</strong></p><p>PS: 原论文的$g_i /h_i$符号错了，我推导的时候觉得很奇怪，查了很多介绍XGBoost的资料，都没有说明如何推导，直接把原公式一贴，这是很不好的。最后看到了Stack Exchange上的回答：</p><blockquote><p>The second equation should have its <strong>sign reversed</strong>, as in:</p><script type="math/tex; mode=display">\sum_{i=1}^N\frac{1}{2}h_i[f_t(x_i) – (-g_i/h_i)]^2 + constant\\= \sum_{i=1}^N\frac{1}{2}h_i[f_t^2(x_i) + 2\frac{f_t(x_i)g_i}{h_i} + (g_i/h_i)^2]\\= \sum_{i=1}^N[g_if_t(x_i) + \frac{1}{2}h_if_t^2(x_i) + \frac{gi^2}{2h_i}]</script><p>The last term is indeed constant: remember that the $g_i$ and $h_i$ are determined by the previous iteration, so they’re constant when trying to set $f_t$.</p><p>So, now we can claim “this is exactly weighted squared loss with labels $−g_i/h_i$ and weights $h_i$</p><p>Credit goes to Yaron and Avi from my team for explaining me this.</p><p>—–from <a href="https://datascience.stackexchange.com/questions/10997/need-help-understanding-xgboosts-approximate-split-points-proposal" target="_blank" rel="noopener">Need help understanding xgboost’s approximate split points proposal</a></p></blockquote><p>为了解决该问题，XGBoost引入了一种新的分布式加权分位数略图算法（distributed weighted quantile sketch algorithm），使用一种可推导证明的有理论保证的方式，来处理加权数据。<strong>总的思想是，提出了一个数据结构，它支持merge和prune操作，每个操作证明是可维持在一个固定的准确度级别</strong>。算法的详细描述在 <strong><a href="https://homes.cs.washington.edu/~tqchen/pdf/xgboost-supp.pdf" target="_blank" rel="noopener">这里</a></strong>。</p><h3 id="3-4-Sparsity-aware-Split-Finding"><a href="#3-4-Sparsity-aware-Split-Finding" class="headerlink" title="3.4 Sparsity-aware Split Finding"></a>3.4 Sparsity-aware Split Finding</h3><p>在许多现实问题中，输入x是稀疏的。有多种可能的情况造成稀疏：</p><ul><li>数据中的missing values</li><li>统计中常见的0条目</li><li>特征工程：比如one-hot encoding</li></ul><p><img alt="图4: 带缺省方向的树结构。当在split时相应的feature缺失时，一个样本可以被归类到缺省方向上" data-src="http://pic.yupoo.com/wangdren23/GuX6iIMd/medish.jpg"></p><p>图4: 带缺省方向的树结构。当在split时相应的feature缺失时，一个样本可以被归类到缺省方向上</p><p>让算法意识到数据中的稀疏模式很重要。为了这么做，我们提出了在每个树节点上增加一个 <strong>缺省的方向（default direction）</strong>，如图4所示。当稀疏矩阵x中的值缺失时，样本实例被归类到缺省方向上。在每个分枝上，缺省方向有两种选择，<strong>最优的缺省方向可以从数据中学到。</strong></p><p><strong>如算法3所示</strong>。关键的改进点是：<strong>只访问非缺失的条目</strong> $I_k$ 。上述算法会将未出现值（non-presence）当成是一个missing value，学到最好的方向来处理 missing values。</p><p>XGBoost能对缺失值自动进行处理，其思想是<strong>对于缺失值自动学习出它该被划分的方向</strong>（左子树or右子树）<br><img alt="在这里插入图片描述" data-src="20181120134436182.png"></p><p>注意，<strong>上述的算法只遍历非缺失值</strong>。划分的方向怎么学呢？很naive但是很有效的方法：</p><ol><li>让特征k的所有缺失值的都到右子树，然后和之前的一样，枚举划分点，计算最大的gain</li><li>让特征k的所有缺失值的都到左子树，然后和之前的一样，枚举划分点，计算最大的gain</li></ol><p>这样最后求出最大增益的同时，也知道了缺失值的样本应该往左边还是往右边。使用了该方法，相当于比传统方法多遍历了一次，但是它只在非缺失值的样本上进行迭代，因此其复杂度与非缺失值的样本成线性关系。在Allstate-10k数据集上，比传统方法快了50倍:</p><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/XGBoost-sparsity-aware-split-finding-vs-basic-algorithm.png"></p><h2 id="4-SYSTEM-DESIGN"><a href="#4-SYSTEM-DESIGN" class="headerlink" title="4. SYSTEM DESIGN"></a>4. SYSTEM DESIGN</h2><h3 id="4-1-Column-Block-for-Parallel-Learning-用于并行学习的Column-Block"><a href="#4-1-Column-Block-for-Parallel-Learning-用于并行学习的Column-Block" class="headerlink" title="4.1 Column Block for Parallel Learning(用于并行学习的Column Block)"></a>4.1 Column Block for Parallel Learning(用于并行学习的Column Block)</h3><p>在建树的过程中，最耗时是找最优的切分点，而这个过程中，最耗时的部分是将数据排序。为了减少排序的时间，提出Block结构存储数据。</p><ul><li>Block中的数据以稀疏格式<strong>CSC</strong>进行存储</li><li>Block中的<strong>特征进行排序</strong>（不对缺失值排序）</li><li>Block 中特征还需存储指向样本的<strong>索引</strong>，这样才能根据特征的值来取梯度。</li><li>一个Block中存储一个或多个特征的值</li></ul><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/XGBoost-column-block.png"></p><p>可以看出，<strong>只需在建树前排序一次</strong>，后面节点分裂时可以直接根据索引得到梯度信息。</p><p><strong>时间复杂度分析</strong></p><p>d为树的最大深度，K为树的总树目。对于exact greedy algorithm，原始的稀疏感知算法的时间复杂度：</p><script type="math/tex; mode=display">O(K d |x|_{0}logn)</script><blockquote><p>这里，我们使用 $|x|_{0}$ 来表示在训练数据中未缺失条目（non-missing entries）的数目。其中$|x|_0 log n$是特征排序时间复杂度，而 $Kd$ 则是 $数的总数目 * 树的深度 = counts\ of\ split\ finding$，当不做任何优化时，对每棵树，每层，每个节点进行split finding时，对每个节点的所有特征对应的样本进行该特征下的大小排序，故而总的时间复杂度为上述步骤连乘。</p><p>而 $Kd|x|_0$ 则是进行split finding 的时间复杂度开销，最多进行 $Kd|x|_0$ 次查找（对应每个样本为一个节点）。</p></blockquote><p>另一方面，块结构上的tree boosting的开销为：</p><script type="math/tex; mode=display">O(Kd {|x|} _0 + {|x|}_{0}logn)</script><p>这里， $O( {|x|}_{0}log n)$ 是一次预处理开销(one time preprocessing cost)(即排序开销)，可以分期(be amortized)。</p><blockquote><p>因为采用了block structure之后，对于exact greedy algorithm 就是采用的是先对所有特征进行列排序，然后每次进行split finding时候，直接在block spliting 中进行查找线型遍历，得到各节点所有特征所有划分的对应增益，选择最大增益对应的特征及划分即为所求。</p><p>而 $Kd|x|_0$ 则是进行split finding 的时间复杂度开销，最多进行 $Kd|x|_0$ 次查找（对应每个样本为一个节点）。</p></blockquote><p>该分析展示了块结构可以帮助节省一个额外的$logn$因子，其中当n非常大时就很大。</p><p>对于近似算法，使用二分查找的原始算法时间复杂度为：</p><script type="math/tex; mode=display">O(K d {|x|}_{0} log q)</script><p>这里的q是在数据集中建议候选的数目。其中，q通常为32~100之间，log因子仍会引入间接开销。使用块结构，我们可以将时间减小到：</p><script type="math/tex; mode=display">O(K d{|x|}_{0} + {|x|}_{0} logB)</script><p>其中B是在每个块中的行的最大数。同样的，我们可以在计算中节约额外的log q因子。</p><blockquote><p>解释同上，只是采用了近似算法后，采用了本论文提出的 Weighted Quantile Sketch 进行样本点候选筛选，这样即将原始样本点 n 降到候选点 q。</p></blockquote><ul><li>在Exact greedy算法中，将整个数据集存放在一个Block中。这样，复杂度从原来的$O(H d||x||_0\log n)$ 降为 $O(Hd||x||_0+||x||_0\log n)$，其中$||x||_0$为训练集中非缺失值的个数。这样，Exact greedy算法就省去了每一步中的排序开销。</li><li>在近似算法中，使用多个Block，每个Block对应原来数据的子集。不同的Block可以在不同的机器上计算。该方法对Local策略尤其有效，因为Local策略每次分支都重新生成候选切分点。</li></ul><p>Block结构还有其它好处，数据按列存储，可以同时访问所有的列，很容易实现并行的寻找分裂点算法。此外也可以方便实现之后要讲的out-of score计算。</p><p>缺点是空间消耗大了一倍。</p><blockquote><p>利用列块进行并行计算：在我们训练过程中我们主要是做分支处理，分支处理就要对每一列（特征）找出适合的分裂点。通常来说，我们更青睐使用csc存储，这样我们就方便取出来。再者我们在分支的时候都会预先对数据按照其特征值进行排序。所以我们将数据按照列存储成一个数据块方便我们在分支的时候并行处理。<strong>所以我们要知道XGB的并行计算的粒度不在树上，而是在特征上，尤其是不同分支节点上（leaf-wise）。</strong>当然这也成为XGB的一个问题所在，需要额外的空间存储pre-sort的数据。而且每次分支后，我们都要找处落在下一个子节点上的样本，并组织好它。<strong>后来就有了LightGBM，下次我再将其整理出来</strong>。</p></blockquote><h3 id="4-2-Cache-aware-Access"><a href="#4-2-Cache-aware-Access" class="headerlink" title="4.2 Cache-aware Access"></a>4.2 Cache-aware Access</h3><p>使用Block结构的一个缺点是取梯度的时候，是通过索引来获取的，而这些梯度的获取顺序是按照特征的大小顺序的。这将导致<strong>非连续</strong>的内存访问，可能使得CPU cache缓存命中率低，从而影响算法效率。</p><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/XGBoost-cache-missing.png"></p><p>图8: 短范围内的数据依赖模式，由于cache miss，可引起停转（stall）</p><p>因此，对于exact greedy算法中, 使用<strong>缓存预取</strong>。具体来说，对每个线程分配一个连续的buffer，读取梯度信息并存入Buffer中（这样就实现了非连续到连续的转化），然后再统计梯度信息。该方式在训练样本数大的时候特别有用，见下图：</p><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/XGBoost-cache-aware-access-exact-greedy.png"></p><p>图7: 在exact greedy algorithm中，cache-aware prefetching的影响。我们发现，cache-miss会在大数据集（1000w实例）上影响性能。使用cache-aware prefetching，可以提升数据集很大时的性能。</p><p>在approximate 算法中，对Block的大小进行了合理的设置。定义Block的大小为Block中最多的样本数。选择一个过小的block size会导致每个thread会小负载（small workload）运行，并引起低效的并行化(inefficient parallelization)。在另一方面，过大的block size会导致cache miss，梯度统计将不能装载到CPU cache中。block size的好的选择会平衡两者。设置合适的大小是很重要的，设置过大则容易导致命中率低，过小则容易导致并行化效率不高。经过实验，发现2^16比较好。</p><p><img alt="img" data-src="https://www.hrwhisper.me/wp-content/uploads/2018/07/XGBoost-cache-aware-access-approximate-algorithm.png"></p><p>图9: 在近似算法中，block size的影响。我们发现，过小的块会引起并行化很低效，过大的块由于cache miss会让训练慢下来</p><blockquote><p>缓存处理能力：对于有大量数据或者说分布式系统来说，我们不可能将所有的数据都放进内存里面。因此我们都需要将其放在外存上或者分布式存储。但是这有一个问题，这样做每次都要从外存上读取数据到内存，这将会是十分耗时的操作。<strong>因此我们使用预读取（prefetching）将下一块将要读取的数据预先放进内存里面。</strong>其实就是多开一个线程，该线程与训练的线程独立并负责数据读取。此外，我还要考虑block的大小问题。如果我们设置最大的block来存储所有样本在k特征上的值和梯度的话，cache未必能一次性处理如此多的梯度做统计。如果我们设置过少block size，这样不能充分利用的多线程的优势，也就是训练线程已经训练完数据，但是prefetching thread还没把数据放入内存或者cache中。经过测试，作者发现block size设置为2^16个examples最好：</p></blockquote><h3 id="4-3-Blocks-for-Out-of-core-Computation"><a href="#4-3-Blocks-for-Out-of-core-Computation" class="headerlink" title="4.3 Blocks for Out-of-core Computation"></a>4.3 Blocks for Out-of-core Computation</h3><p>当数据量太大不能全部放入主内存的时候，为了使得<a href="https://en.wikipedia.org/wiki/External_memory_algorithm" target="_blank" rel="noopener">out-of-core</a>计算称为可能，将数据划分为多个Block并存放在磁盘上。</p><ul><li>计算的时候，使用独立的线程预先将Block放入主内存，因此可以在计算的同时读取磁盘</li><li>Block压缩，貌似采用的是近些年性能出色的LZ4 压缩算法，按列进行压缩，读取的时候用另外的线程解压。对于行索引，只保存第一个索引值，然后用16位的整数保存与该block第一个索引的差值。</li><li>Block Sharding， 将数据划分到不同硬盘上，提高磁盘吞吐率</li></ul><p><strong>块压缩（Block Compression）</strong> 块通过列(column)进行压缩，当加载进主存时可以由一个独立的线程即时解压(decompressed on the fly)。它会使用磁盘读开销来获得一些解压时的计算。我们使用一个通用目的的压缩算法来计算特征值。对于行索引（row index），我们从块的起始索引处开始抽取行索引，使用一个16bit的整数来存储每个偏移(offset)。<strong>这需要每个块有216216个训练样本，这证明是一个好的设置</strong>。在我们测试的大多数数据集中，我们达到大约26% ~ 29%的压缩率。</p><p><strong>块分片（Block Sharding）</strong> 第二个技术是，在多个磁盘上以一种可选的方式共享数据。一个pre-fetcher thread被分配到每个磁盘上，取到数据，并装载进一个in-memory buffer中。训练线程（training thread）接着从每个bufer中选择性读取数据。当提供多个磁盘时，这可以帮助增加磁盘读(disk reading)的吞吐量。</p><blockquote><p> 数据块以外的计算力提高：对于超大型的数据，我们不可能都放入放入内存，因此大部分都放入外存上。假如我们将数据存于外存上将给我们带来读写速度受限的问题。文中有两种方法，<strong>一种是对数据进行压缩存于外存中，到内存中需要训练时再解压</strong>，这样来增加系统的吞吐率，尽管消耗了一些时间来做编码和解码但还是值得的。<strong>另一种就是多外存存储，其实本质上就是分布式存储。</strong>这样说有多个线程对分布式结构管理，吞吐率自然高啦。</p></blockquote><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>下面总结几个问题：</p><h3 id="5-1-XGBoost为什么快"><a href="#5-1-XGBoost为什么快" class="headerlink" title="5.1 XGBoost为什么快"></a>5.1 XGBoost为什么快</h3><ul><li>当数据集大的时候使用近似算法</li><li>Block与并行</li><li>CPU cache 命中优化</li><li>Block预取、Block压缩、Block Sharding等</li></ul><h3 id="5-2-XGBoost与传统GBDT的不同"><a href="#5-2-XGBoost与传统GBDT的不同" class="headerlink" title="5.2 XGBoost与传统GBDT的不同"></a>5.2 XGBoost与传统GBDT的不同</h3><p>这里主要参考weapon的回答，答案在：<a href="https://www.zhihu.com/question/41354392/answer/98658997" target="_blank" rel="noopener">机器学习算法中GBDT和XGBOOST的区别有哪些？</a></p><ol><li><p>传统GBDT以CART作为基分类器，XGBoost还支持线性分类器，这个时候XGBoost相当于带L1和L2正则化项的Logistic回归（分类问题）或者线性回归（回归问题）。</p><blockquote><p>注：Boosting 模型本质还是加性模型，而XGBoost做为boosting算法的一种并行实现，除了对传统的GBDT进行了很多改进之外，又增加了其扩展性，其中一个就是支持不同的基分类器，不再局限于CART回归树；</p><p>因为XGBoost可以自己设定损失函数，只需要满足该设定损失函数一阶、二阶可导，而损失函数旨在计算真实值与分类器预测值之间的差异。故而，当采用线型模型（包括线型回归和Logistic Regression）采用线性加和的方式进行预测 <script type="math/tex">\hat{y}_i=\sum_j{w_jx_{ij}}</script>，这里的预测值 $y$ 可以由不同的解释，比如我们可以把它作为回归目标的输出，或者进行 sigmoid 变换得到概率（即用 <script type="math/tex">\frac{1}{1+e^{-\hat{y}_i}}</script> 来预测正例的概率），或者作为排序的指标等。此时，基模型即采用的线型模型。</p><p>此时，XGBoost的正则项 <script type="math/tex">\Omega(f_t) = \gamma T + \frac{1}{2} \gamma \sum_{j=1}^{T}w_j^2</script>，此时 $T$ 用于限制线型分类器个数，而 <script type="math/tex">w_j^2</script> 则是用于限制线型分类器预测分数（相较于传统的L2正则化，多了一项基分类器的个数正则项）</p></blockquote></li><li><p>传统的GBDT只用了一阶导数信息（使用牛顿法的除外），而XGBoost对损失函数做了二阶泰勒展开。并且XGBoost支持自定义损失函数，只要损失函数一阶、二阶可导。</p></li><li><p>XGBoost的目标函数多了正则项， 相当于<strong>预剪枝</strong>，使得学习出来的模型更加不容易过拟合。</p></li><li><p>XGBoost还有<strong>列抽样</strong>，进一步防止过拟合。</p></li><li><p>对缺失值的处理。对于特征的值有缺失的样本，XGBoost可以自动学习出它的分裂方向。</p></li><li><p>XGBoost工具支持并行。当然这个并行是在特征的粒度上，而非tree粒度，因为本质还是boosting算法。</p></li></ol><blockquote><p>xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</p></blockquote><h3 id="5-4-XGBoost-与-线性回归的区别"><a href="#5-4-XGBoost-与-线性回归的区别" class="headerlink" title="5.4 XGBoost 与 线性回归的区别"></a>5.4 XGBoost 与 线性回归的区别</h3><ol><li><p>线性回归模型的解释性是决策树、随机森林、xgboost无法比拟的，也无法取代。</p></li><li><p>线性回归可以建立线性模型，而xgboost是不可以的。举个例子，即使是简单的 $y=x+1$ 的线性关系，xgboost也无法做到。</p></li><li><p>线性模型计算简单，适用于快速部署。</p></li><li><p>决策树/森林回归是把数据空间非线性地分成 $N$ 份（N为叶节点数），相当于做N 聚类。然后再每个叶节点上求平均，其实是一种条件期望（conditional mean），$y^=E(y|c)$，$c$ 是聚类标签，可以看做是内插（interpolation）。所以预测点周围需要被训练点包围，这样才会有好的效果。</p></li><li><p>线性模型回归是用线/平面去拟合所有训练数据。当引入 $x^2$ 等高维变量后，在原有 x 空间是非线性曲线/曲面。线性模型回归可以作内插（interpolation，预测点曾经见过），也可以做外插（extrapolation，预测点从没见过，比如 $y=x+1$）。</p></li><li><p>决策树优点：决策树用垂直线段去拟合曲线，不用显示的写出曲线的表达式。而线性模型会尝试写出曲线的表达式。所以线性模型更难去拟合复杂的曲线。</p></li><li><p>决策树缺点：决策树是基于数据，而线性模型是基于模型。决策树需要大量数据去尽量覆盖所有可能的输入，适合于大数据。所谓的“大”是指训练样本的覆盖面要大。线性模型可以处理训练样本小的情况。</p></li><li><p>决策树和线性模型的组合。在每个叶节点上，单纯的决策树回归是用一个点代表所有值。此时可以再用线性模型，用一条线去拟合子空间的数据。</p></li></ol><h3 id="5-3-XGBoost-Scalable的体现"><a href="#5-3-XGBoost-Scalable的体现" class="headerlink" title="5.3 XGBoost Scalable的体现"></a>5.3 XGBoost Scalable的体现</h3><p>XGBoost的paper在KKD上发表，名为：《Xgboost: A scalable tree boosting system》，那么scalable体现在哪?</p><p>参考知乎上<a href="https://www.zhihu.com/question/41354392/answer/154686456" target="_blank" rel="noopener">王浩的回答</a>，修改如下：</p><ul><li>模型的scalability：弱分类器可以支持cart也可以支持lr和linear， 但其实这是Boosting算法做的事情，XGBoost只是实现了而已。</li><li>目标函数的scalability： 支持不同的loss function, 支持自定义loss function，只要一、二阶可导。有这个特性是因为泰勒二阶展开，得到通用的目标函数形式。</li><li>学习方法的scalability：Block结构支持并行化，支持 Out-of-core计算（这点和王浩的看法不一样，他写的是优化的trick）</li></ul><h3 id="5-4-XGBoost-防止过拟合的方法"><a href="#5-4-XGBoost-防止过拟合的方法" class="headerlink" title="5.4 XGBoost 防止过拟合的方法"></a>5.4 XGBoost 防止过拟合的方法</h3><ul><li>目标函数的正则项， 叶子节点数+叶子节点数输出分数的平方和 <script type="math/tex">Ω(ft)=γT+12λ∑Tj=1w2j</script></li><li>行抽样和列抽样：训练的时候只用一部分样本和一部分特征</li><li>可以设置树的最大深度</li><li>η: 可以叫学习率、步长或者shrinkage</li><li>Early stopping：使用的模型不一定是最终的ensemble，可以根据测试集的测试情况，选择使用前若干棵树</li></ul><h3 id="5-5-xgboost使用经验总结"><a href="#5-5-xgboost使用经验总结" class="headerlink" title="5.5 xgboost使用经验总结"></a>5.5 xgboost使用经验总结</h3><ul><li>多类别分类时，类别需要从0开始编码</li><li>Watchlist不会影响模型训练。</li><li>类别特征必须编码，因为xgboost把特征默认都当成数值型的</li><li>调参：<a href="https://github.com/dmlc/xgboost/blob/master/doc/param_tuning.md" target="_blank" rel="noopener">Notes on Parameter Tuning</a> 以及 <a href="http://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/" target="_blank" rel="noopener">Complete Guide to Parameter Tuning in XGBoost (with codes in Python)</a></li><li>训练的时候，为了结果可复现，记得设置随机数种子。</li><li>XGBoost的特征重要性是如何得到的？某个特征的重要性（feature score），等于它被选中为树节点分裂特征的次数的和，比如特征A在第一次迭代中（即第一棵树）被选中了1次去分裂树节点，在第二次迭代被选中2次…..那么最终特征A的feature score就是 1+2+….</li></ul><h3 id="5-6-类别特征必须编码"><a href="#5-6-类别特征必须编码" class="headerlink" title="5.6 类别特征必须编码"></a>5.6 类别特征必须编码</h3><p>无论是XGBoost还是其他的Boosting Tree，使用的Tree都是cart回归树，这也就意味着该类提升树算法只接受数值特征输入，不直接支持类别特征，事实上，对于类别特征的处理，参考XGBoost PPT如下（XGBoost accepts only numeric features）：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20181120142201723.png"></p><p>而XGBoost具有支持稀疏数据的优势，对one-hot并不抗拒。</p><blockquote><p>xgboost是不支持category特征的，在训练模型之前，需要我们进行预处理，可以根据特征的具体形式 来选择one-hot encoding（无序）还是label encoding（有序）。<br>当category的特征值非常多时，one-hot encoding会非常稀疏。这时候one-hot encoding的效果可能不好，可以用NN训练一个该category的向量，或者用其他方式来编码。</p></blockquote><h3 id="5-7-XGBoost并行计算理解"><a href="#5-7-XGBoost并行计算理解" class="headerlink" title="5.7 XGBoost并行计算理解"></a>5.7 XGBoost并行计算理解</h3><p>   初始学习XGBoost，一个很容易困惑的点就是XGBoost的并行计算，毕竟其采用的加法模型架构，怎么看都是一种串行计算；事实上，XGBoost的并行不是在计算各轮添加的回归树上，而是体现在上述<code>Split Finding</code>中的排序上，即并行对各个样本，依据其所有m个特征值进行m轮从小到大排序，然后计算各个特征下各样本从左到右做划分对应的<code>score</code>。这才是并行计算的实质所在，由于XGBoost主要的计算量都击中在找<code>Split Finding</code>上，故而对这一步的并行计算大大加速了XGBoost的模型运算速度。</p><h3 id="关于XGBoost的one-hot编码的一点思考与总结"><a href="#关于XGBoost的one-hot编码的一点思考与总结" class="headerlink" title="关于XGBoost的one-hot编码的一点思考与总结"></a>关于XGBoost的one-hot编码的一点思考与总结</h3><p>个人在阅读XGBoost相关文献及问题时候发现关于XGBoost到底是否应该大规模使用one-hot编码存在异议，网上答案也是议论纷纷，个人在这里总结一下结合其他各位答主看法后的自身理解：</p><blockquote><p>机器学习中的许多模型中，对类别型变量，常作的处理是，将它们编码成one-hot。但是对于树模型来说，将类别型变量编码成one-hot，这样作是否有意义呢？像一些机器学习工具包（比如：spark gbm实现），你可以指定为类别型变量，内部自己去做one-hot实现。而像xgboost，则将输入全认为是数值型特征去处理。</p></blockquote><p>&gt;</p><blockquote><p>这在机器学习界也有争论。理论上，树模型如果够深，也能将关键的类别型特型切出来。<br>关于这个，xgboost的作者tqchen在某个[issues]&gt;(<a href="https://github.com/dmlc/xgboost/issues/95)有提到过：" target="_blank" rel="noopener">https://github.com/dmlc/xgboost/issues/95)有提到过：</a><br>I do not know what you mean by vector. xgboost treat every input feature as numerical, with support for missing values and sparsity. The decision is at the user<br>So if you want ordered variables, you can transform the variables into numerical levels(say age). Or if you prefer treat it as categorical variable, do one hot encoding.<br>在另一个<a href="https://github.com/szilard/benchm-ml/issues/1" target="_blank" rel="noopener">issues</a>上也提到过（tqchen commented on 8 May 2015）：<br>One-hot encoding could be helpful when the number of categories are small( in level of 10 to 100). In such case one-hot encoding can discover interesting interactions like (gender=male) AND (job = teacher).<br>While ordering them makes it harder to be discovered(need two split on job). However, indeed there is not a unified way handling categorical features in trees, and usually what tree was really good at was ordered continuous features anyway..</p></blockquote><p>个人总结：</p><ol><li>对于类别有序的类别型变量，比如age等，当成数值型变量处理可以的。对于非类别有序的类别型变量，依据类别特征维度选择是做one-hot还是先one-hot再embeding。（one-hot会增加内存开销以及训练时间开销）</li><li>类别型变量在范围较小时（tqchen给出的是[10,100]范围内）推荐使用one-hot编码；</li><li>对于类别变量范围比较大时，把类别特征转成one-hot coding扔到NN里训练个embedding；比如对于用户的ID，一个大的数据集里面可能有数亿个用户ID，对于这些ID我们可以都映射到一个64维的空间中。模型训练实际上就是更新这个用户ID，在64维的空间中对应的Embedding向量。这样每个用户ID可能包含的信息，都被包含在这个64维的实数向量中了。（比如对于用户的ID，一个大的数据集里面可能有数亿个用户ID，对于这些ID我们可以都映射到一个64维的空间中。模型训练实际上就是更新这个用户ID，在64维的空间中对应的Embedding向量。这样每个用户ID可能包含的信息，都被包含在这个64维的实数向量中了。）<blockquote><p>此处的embedding：即用nn训练一个categorical feature到label的映射，或直接对类别特征做autoencoder，然后把隐层拿出来直接当特征。<br>知乎上有一篇对此分析地很好的帖子：<a href="https://www.zhihu.com/question/266195966/answer/306104444，" target="_blank" rel="noopener">https://www.zhihu.com/question/266195966/answer/306104444，</a> 可借鉴参考。</p></blockquote></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/38297689" target="_blank" rel="noopener">Newton Boosting Tree 算法原理：详解 XGBoost</a></li><li><a href="https://zhuanlan.zhihu.com/p/36794802" target="_blank" rel="noopener">XGBoost论文阅读及其原理</a></li><li><a href="http://d0evi1.com/xgboost/" target="_blank" rel="noopener">xgboost code insight-1</a></li><li><a href="https://www.hrwhisper.me/machine-learning-xgboost/" target="_blank" rel="noopener">『我爱机器学习』集成学习（三）XGBoost</a></li><li><a href="https://www.zhihu.com/appview/p/25871869" target="_blank" rel="noopener">《XGBoost: A Scalable Tree Boosting System》</a></li><li><a href="https://www.zhihu.com/question/266195966/answer/306104444" target="_blank" rel="noopener">关于sklearn中的决策树是否应该用one-hot编码？</a></li><li><a href="http://d0evi1.com/onehot/" target="_blank" rel="noopener">类别型变量onehot编码的那些事</a></li><li><a href="https://github.com/duboya/CTR-Prediction/blob/master/XGBoost%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93.ipynb" target="_blank" rel="noopener">XGBoost 论文阅读总结.ipynb</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XGBoost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用command笔记</title>
      <link href="/Linux-basic-command/"/>
      <url>/Linux-basic-command/</url>
      
        <content type="html"><![CDATA[<p>Linux是目前应用最广泛的服务器操作系统，基于Unix，开源免费，由于系统的稳定性和安全性，市场占有率很高，几乎成为程序代码运行的最佳系统环境。linux不仅可以长时间的运行我们编写的程序代码，还可以安装在各种计算机硬件设备中，如手机Android、路由器OpenWRT等，最底层就是运行在linux系统上的。<br>我安装的Linux发行版本是Ubuntu 16.04和Ubuntu 18.04<br>下面记录一些使用过程中遇到的Linux命令：</p><p><a href="https://github.com/jaywcjlove/linux-command" target="_blank" rel="noopener"><img data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/linux-command.svg?sanitize=true"></a></p><a id="more"></a><h1 id="linux的目录结构"><a href="#linux的目录结构" class="headerlink" title="linux的目录结构"></a>linux的目录结构</h1><p><img alt="/ 下级目录结构" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/proxy"></p><ul><li>bin (binaries)存放二进制可执行文件</li><li>sbin (super user binaries)存放二进制可执行文件，只有root才能访问</li><li>etc (etcetera)存放系统配置文件</li><li>usr (unix shared resources)用于存放共享的系统资源</li><li>home 存放用户文件的根目录</li><li>root 超级用户目录</li><li>dev (devices)用于存放设备文件</li><li>lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块</li><li>mnt (mount)系统管理员安装临时文件系统的安装点</li><li>boot 存放用于系统引导时使用的各种文件</li><li>tmp (temporary)用于存放各种临时文件</li><li>var (variable)用于存放运行时需要改变数据的文件</li></ul><h1 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h1><h3 id="ls-list"><a href="#ls-list" class="headerlink" title="ls: list"></a>ls: list</h3><p>ls -l: a long listing format<br>ls -lh: human readable long listing format<br>ls -lSh: sorted by size and then by the exist time</p><h3 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd: change directory"></a>cd: change directory</h3><h3 id="pwd-print-name-of-current-working-directory"><a href="#pwd-print-name-of-current-working-directory" class="headerlink" title="pwd: print name of current/working directory"></a>pwd: print name of current/working directory</h3><h3 id="删除软件"><a href="#删除软件" class="headerlink" title="删除软件"></a>删除软件</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove &lt;application_name&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge &lt;package-name&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="解压-tar-xz文件"><a href="#解压-tar-xz文件" class="headerlink" title="解压*.tar.xz文件"></a>解压*.tar.xz文件</h3><p>-c: 建立压缩档案<br>-x：解压 —extract<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><p>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出</p><p>下面的参数-f是必须的</p><p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接filename。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf file.tar //解压 tar包</span><br><span class="line">tar -xzvf file.tar.gz //解压tar.gz</span><br><span class="line">tar -xjvf file.tar.bz2   //解压 tar.bz2</span><br><span class="line">tar -xZvf file.tar.Z   //解压tar.Z</span><br><span class="line">unrar e file.rar //解压rar</span><br><span class="line">unzip file.zip //解压zip</span><br><span class="line">`tar -xf file.tar.xz`</span><br></pre></td></tr></tbody></table></figure><p></p><p><a href="https://www.cnblogs.com/nhdlb/p/11568991.html" target="_blank" rel="noopener">https://www.cnblogs.com/nhdlb/p/11568991.html</a><br><a href="https://scottlinux.com/2014/01/07/extracting-or-uncompressing-tar-xz-files-in-linux/" target="_blank" rel="noopener">https://scottlinux.com/2014/01/07/extracting-or-uncompressing-tar-xz-files-in-linux/</a></p><h4 id="压缩文件成-tar-xz"><a href="#压缩文件成-tar-xz" class="headerlink" title="压缩文件成*.tar.xz"></a>压缩文件成*.tar.xz</h4><p><code>tar -zcvf archive-name.tar.gz directory-name</code></p><h3 id="删除目录或文件"><a href="#删除目录或文件" class="headerlink" title="删除目录或文件"></a>删除目录或文件</h3><p>删除空文件夹：<code>rmdir directoryname</code><br>Remove a directory with files and subdirectories (non-empty directory)：<code>rm -r directoryname</code><br>Remove a single file：<code>rm file.txt</code></p><h3 id="mv移动或重命名文件或目录"><a href="#mv移动或重命名文件或目录" class="headerlink" title="mv移动或重命名文件或目录"></a><code>mv</code>移动或重命名文件或目录</h3><p><code>mv</code> can do two jobs.</p><ol><li>It can move files or directories</li><li>It can rename files or directories</li></ol><p>To just rename a file or directory type this in Terminal:</p><blockquote><p>mv old_name new_name</p></blockquote><p>with space between the old and new names.</p><p>To move a file or directory type this in Terminal.</p><blockquote><p>mv file_name ~/Desktop</p></blockquote><p>it will move the file to the desktop.</p><p>If is a directory you should add <code>-R</code> before the directory name:</p><blockquote><p>mv -R directory_name ~/Desktop</p><h3 id="wget下载命令"><a href="#wget下载命令" class="headerlink" title="wget下载命令"></a><code>wget</code>下载命令</h3><p><a href="https://www.cnblogs.com/wuheng1991/p/5332764.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuheng1991/p/5332764.html</a><br>wget <a href="http://cn.wordpress.org/wordpress-3.1-zh_CN.zip" target="_blank" rel="noopener">http://cn.wordpress.org/wordpress-3.1-zh_CN.zip</a></p><h3 id="cp复制命令"><a href="#cp复制命令" class="headerlink" title="cp复制命令"></a><code>cp</code>复制命令</h3><p>cp filename direction<br>cp folder direction</p></blockquote><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><blockquote><p>vi filename     :打开或新建文件，并将光标置于第一行首</p></blockquote><p>查看显卡型号：<code>lspci |grep VGA</code> （lspci是linux查看硬件信息的命令），屏幕会打印出主机的集显几独显信息<br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2018071513101933"></p><p>查看nvidia芯片信息：<code>lspci |grep -i nvidia</code>，会打印出nvidia系列的硬件信息，如果主机安装了没有视频输出的GPU（如tesla系列），这个命令会很有用<br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180715131139920"></p><h3 id="du-DiskUsage"><a href="#du-DiskUsage" class="headerlink" title="du: DiskUsage"></a>du: DiskUsage</h3><p>查看硬盘使用情况<br><code>df -hl</code> 查看磁盘剩余空间<br><code>df -h</code> 查看每个根路径的分区大小;<code>-h</code>:human readable<br><code>du -sh</code> [目录名] ：<strong>D</strong>isk <strong>U</strong>sage返回该目录的大小<br><code>du -sm</code> [文件夹] 返回该文件夹总M数<br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180718110351393"></p><h3 id="df-Disk-space-being-used-by-File-ystem"><a href="#df-Disk-space-being-used-by-File-ystem" class="headerlink" title="df: Disk space being used by File ystem"></a>df: Disk space being used by File ystem</h3><p>df -h: human readable</p><h3 id="man-view-the-system’s-reference-MANuals"><a href="#man-view-the-system’s-reference-MANuals" class="headerlink" title="man: view the system’s reference MANuals"></a>man: view the system’s reference MANuals</h3><p>man pwd: get the manual for PWD command</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h3><p>查看CPU使用情况<br><code>top</code><br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180718150831127"><br><code>top</code> <code>1</code><br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180718150928345"></p><h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a><code>tail</code> 命令</h3><p><a href="https://www.cnblogs.com/mfryf/p/3336804.html" target="_blank" rel="noopener">https://www.cnblogs.com/mfryf/p/3336804.html</a><br><code>tail -f filename</code>：监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。</p><p><code>tail -n 20 filename</code>：显示filename最后20行。</p><p><code>tail -r -n 10 filename</code>：逆序显示filename最后10行。</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><code>pwd</code></h3><p>print working directory</p><p><a href="http://linux.51yip.com/search/awk" target="_blank" rel="noopener">http://linux.51yip.com/search/awk</a></p><h3 id="md5sum-MD5算法一般用于检查文件完整性，不同的文件内容生成相同的报文摘要的概率是极其小的。"><a href="#md5sum-MD5算法一般用于检查文件完整性，不同的文件内容生成相同的报文摘要的概率是极其小的。" class="headerlink" title="md5sum : MD5算法一般用于检查文件完整性，不同的文件内容生成相同的报文摘要的概率是极其小的。"></a><code>md5sum</code> : MD5算法一般用于检查文件完整性，不同的文件内容生成相同的报文摘要的概率是极其小的。</h3><p><code>md5sum filename</code><br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180809174303523"></p><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a><code>scp</code></h3><p>secure copy，远程拷贝文件</p><ol><li><strong>将本地文件上传到服务器上</strong><br><code>scp -P 2222 /home/lnmp0.4.tar.gz root@www.vpser.net:/root/lnmp0.4.tar.gz</code><br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180809180429836"></li></ol><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a><code>unzip</code></h3><p>解压zip文件<br><code>unzip file.zip</code><br><code>unzip file.zip -d destination_folder</code></p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a><code>diff</code></h3><p>比较文件不同<br><code>diff file1 file2</code></p><h3 id="taskset"><a href="#taskset" class="headerlink" title="taskset"></a><code>taskset</code></h3><p>指定job在哪几块CPU上运行<br><code>taskset -c 0-7</code>：指定job在1-8号CPU上运行</p><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a><code>nohup</code></h3><p>allows to run job in the background after you log out from a shell<br><a href="https://linuxhint.com/nohup_command_linux/" target="_blank" rel="noopener">Nohup Command in Linux</a></p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h3><p><strong>cat</strong>enate 命令用于连接文件并打印到标准输出设备上<br><code>cat file.txt</code>：将<em>file.txt</em>的内容打印在屏幕上<br><a href="https://www.tecmint.com/13-basic-cat-command-examples-in-linux/" target="_blank" rel="noopener">13 Basic Cat Command Examples in Linux</a></p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a><code>touch</code></h3><p>创建空文件，或者改变文件的时间戳属性<br><code>touch file.txt</code>：创建一个新的空文件<em>file.txt</em></p><h3 id="查看NVIDIA显卡信息"><a href="#查看NVIDIA显卡信息" class="headerlink" title="查看NVIDIA显卡信息"></a>查看NVIDIA显卡信息</h3><p>由于我已经切换到ＮＶＩＤＩＡ专有驱动：<code>nvidia-smi</code><br><img alt="驱动" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20171228211613210"></p><p><img alt="nvidia-smi" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20171228211819829"></p><p><code>watch -n 5 nvidia-smi</code>:每隔5秒更新一下显卡使用情况, <code>ctrl+c</code>退出</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a><code>more</code></h3><p>more 允许你向前查看文本文件。<br><code>more file.txt</code>：创建一个新的空文件<em>file.txt</em><br>使用<kbd>Enter</kbd>可以向下翻页，输入 <kbd>q</kbd> 可以退出，输入 <kbd>/</kbd> 字符并在其后加上你想要查找的文字(<strong>区分大小写</strong>)可以搜索。例如你要查看的字段是 “terminal”，只需输入：<code>/terminal</code></p><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符<kbd>|</kbd></h3><p>将管道符<kbd>|</kbd>左边命令的输出输入给右边的命令<br><code>ls | more</code>：有很多文件的目录，可以组合 <code>more</code> 跟 <code>ls</code> 命令完整查看这个目录当中的内容<br><code>grep ‘productivity’ core.md Dict.md lctt2014.md lctt2016.md lctt2018.md README.md | more</code> ：组合 more 和 grep 命令，实现在多个文件中找到指定的文本 “productivity”<br><code>ps -u Hailin | more</code>：列出你用户下(Hailin)正在运行的进程</p><h3 id="查看Linux系统的发行版（Ubuntu还是CentOS）"><a href="#查看Linux系统的发行版（Ubuntu还是CentOS）" class="headerlink" title="查看Linux系统的发行版（Ubuntu还是CentOS）"></a>查看Linux系统的发行版（Ubuntu还是CentOS）</h3><p>$ <code>cat /etc/os-release</code><br>$ <code>uname -a</code>：显示全部的版本信息</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a><code>find</code></h3><p>$ <code>find ~ -name '*jpg'</code>：在主目录中找到所有的 JPEG 文件。 -name 参数允许你将结果限制为与给定模式匹配的文件<br>$ <code>find ~ -iname '*jpg'</code>：-iname 就像 -name，但是不区分大小写。<br>$ <code>find ~ ( -iname 'jpeg' -o -iname 'jpg' )</code>：用“或”（表示为 -o）来组合。在主目录中找到所有的 JPEG或JPG 文件<br>$ <code>find ~ \( -iname '*jpeg' -o -iname '*jpg' \) -type f</code>：指定查找类型为file文件<br>$ <code>find ~ \( -iname '*jpeg' -o -iname '*jpg' \) -type d</code>：指定查找类型为directory目录<br>$ <code>find ~ \( -iname '*jpeg' -o -iname '*jpg' \) -type f -mtime -7</code>：指定修改日期在7天以内的file<br>你可以根据文件状态更改时间 （ctime）、修改时间 （mtime） 或访问时间 （atime） 来执行时间过滤。 这些是在几天内，所以如果你想要更细粒度的控制，你可以表示为在几分钟内（分别是 cmin、mmin 和 amin）。 除非你确切地知道你想要的时间，否则你可能会在 + （大于）或 - （小于）的后面加上数字。<br>$ <code>find /var/log -size +1G</code>：在 log 目录下找到所有“大于 1GB”的文件<br>$ <code>find /data -owner hailin</code>：在 /data 中找到 hailin 拥有的所有文件<br>$ <code>find ~ -perm -o=r</code>：在主目录中找到对所有人可读的文件<br><a href="https://opensource.com/article/18/4/how-use-find-linux" target="_blank" rel="noopener">How to use FIND in Linux</a></p><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a><code>awk</code></h3><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理，数据可以来自标准输入、一个或多个文件。其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母。<br>$ <code>awk '!seen[$9]++ { print $4,$5,$9 }' part-00000 part*</code>：输出文件的第4，5，9列，并按第九列内容去重<br><a href="http://man.linuxde.net/awk" target="_blank" rel="noopener">awk命令详解</a></p><h3 id="sed-Stream-EDitor"><a href="#sed-Stream-EDitor" class="headerlink" title="sed: Stream EDitor"></a><code>sed</code>: Stream EDitor</h3><p>$<code>sed -i -e 's/abc/ABC/g' feature_list.csv</code>: 将文件中的<code>abc</code>全局替换为<code>ABC</code><br>$<code>sed -e 's/$/hello/' -i feature_list.csv</code>: 为每一行末尾append <code>hello</code><br>$<code>sed -i '/#/d' feature_list.csv</code>: remove包含<code>#</code>的每一行<br><a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">Linux sed 命令</a></p><h3 id="设置开机自启动程序"><a href="#设置开机自启动程序" class="headerlink" title="设置开机自启动程序"></a>设置开机自启动程序</h3><ol><li>Run this command：<code>sudo vim /etc/systemd/system/YOUR_SERVICE_NAME.service</code></li><li><p>输入以下的配置：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Description=GIVE_YOUR_SERVICE_A_DESCRIPTION</span><br><span class="line"></span><br><span class="line">Wants=network.target</span><br><span class="line">After=syslog.target network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=YOUR_COMMAND_HERE</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=10</span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure></li><li><p>重启服务：<code>sudo systemctl daemon-reload</code></p></li><li>启用服务：<code>sudo systemctl enable YOUR_SERVICE_NAME</code></li><li>开始服务：<code>sudo systemctl start YOUR_SERVICE_NAME</code></li><li>检查服务状态：<code>systemctl status YOUR_SERVICE_NAME</code></li><li>尝试重启设备检查服务有没有重新开始运行</li></ol><hr><p><img alt="BASIC LINUX COMMAND" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/isnefnt32wn21.jpg"><br><a href="Linux-Cheat-Sheet-David-Relyea.pdf">Linux Cheat Sheet David Relyea | PDF</a><br><a href="https://www.youtube.com/playlist?list=PLdfA2CrAqQ5kB8iSbm5FB1ADVdBeOzVqZ" target="_blank" rel="noopener">Introduction to Linux Commands/Shell Scripting for Data Scientists | YouTube</a><br><a href="https://mlog.club/article/28876" target="_blank" rel="noopener">Linux 下的这些高效指令，是你快速入门运维的神器</a><br><a href="https://mlog.club/article/31049" target="_blank" rel="noopener">Linux最常用命令：简单易学，但能解决95%以上的问题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】Coin Change</title>
      <link href="/LeetCode322-Coin-Change/"/>
      <url>/LeetCode322-Coin-Change/</url>
      
        <content type="html"><![CDATA[<h1 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br><a id="more"></a><br>示例 1:</p><pre><code>输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1</code></pre><p>示例 2:</p><pre><code>输入: coins = [2], amount = 3输出: -1</code></pre><p>说明:<br>你可以认为每种硬币的数量是无限的。</p><h2 id="Approach-1-Brute-force-Time-Limit-Exceeded"><a href="#Approach-1-Brute-force-Time-Limit-Exceeded" class="headerlink" title="Approach #1 (Brute force) [Time Limit Exceeded]"></a>Approach #1 (Brute force) [Time Limit Exceeded]</h2><p>上面的问题可以建模成如下的最优化问题：</p><script type="math/tex; mode=display">\min_{x}\sum_{i=0}^{n-1} {x_{i}} ,{ \text { subject to } \sum_{i=0}^{n-1} {x_{i}\ast c_{i}}}</script><p>其中$S$是总额，$c<em>{i}$是第$i$种硬币，$x</em>{i}$是第$i$种硬币$c<em>{i}$在找零$S$的数量。很容易得出判断$x</em>{i} = [0,\frac{S}{c_{i}}]$.<br>贪心算法每次会选取可能的最大面值来实现硬币总数最少。（并不能保证找出最优解。）</p><h2 id="Approach-2-Dynamic-programming-Top-down-Accepted"><a href="#Approach-2-Dynamic-programming-Top-down-Accepted" class="headerlink" title="Approach #2 (Dynamic programming - Top down) [Accepted]"></a>Approach #2 (Dynamic programming - Top down) [Accepted]</h2><p>假设$F(S)$表示找零$S$元需要的最少硬币数</p><h2 id="Approach-3-Dynamic-programming-Bottom-up-Accepted"><a href="#Approach-3-Dynamic-programming-Bottom-up-Accepted" class="headerlink" title="Approach #3 (Dynamic programming - Bottom up) [Accepted]"></a>Approach #3 (Dynamic programming - Bottom up) [Accepted]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span> || coins.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, MAX_Integer);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> coin : coins)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((i - coin) == <span class="number">0</span>)</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((i - coin) &gt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://forum.letstalkalgorithms.com/t/coin-change-leetcode/394" target="_blank" rel="noopener">https://forum.letstalkalgorithms.com/t/coin-change-leetcode/394</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】House Robber</title>
      <link href="/LeetCode198-House-Robber/"/>
      <url>/LeetCode198-House-Robber/</url>
      
        <content type="html"><![CDATA[<h1 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p>示例 2:</p><pre><code>输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><p>这是一题典型的动态规划问题，有点类似于背包问题。动态规划问题大多数可以按照以下的步骤来一步步优化：</p><ol><li>Find recursive relation</li><li>Recursive (top-down)</li><li>Recursive + memo (top-down)</li><li>Iterative + memo (bottom-up)</li><li>Iterative + N variables (bottom-up)</li></ol><h2 id="Step-1-找出-recursive-关系"><a href="#Step-1-找出-recursive-关系" class="headerlink" title="Step 1. 找出 recursive 关系."></a>Step 1. 找出 recursive 关系.</h2><p>以上面的题为例，Robber有两个选项：a)要么打劫当前的房屋<code>i</code>，b)要么不打劫<code>i</code>。<br>如果选择a)那意味着他不能打劫邻居<code>i-1</code>但是可以选择<code>i-2</code>；<br>如果选择b)，Robber可以选择打劫邻居<code>i-1</code>和接下来的所有房屋。<br>所以劫匪为了所得最大化可以归结为考虑比较以下两种形式：</p><ul><li>当前的房屋<code>i</code>的所得 + 之前所得</li><li>之前所得</li></ul><p><code>rob(i) = max( rob(i - 2) + currentHouseValue, rob(i - 1) )</code></p><h2 id="Step-2-Recursive-top-down"><a href="#Step-2-Recursive-top-down" class="headerlink" title="Step 2. Recursive (top-down)"></a>Step 2. Recursive (top-down)</h2><p>将上面的关系转换为下面的C++代码：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="keyword">return</span> rob_brute_force(nums, nums.size() - <span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">rob_brute_force</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> max(rob_brute_force(nums, i - <span class="number">2</span>) + nums[i], rob_brute_force(nums, i - <span class="number">1</span>));</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p></p><p>但是这个算法将处理同一个<code>i</code>多次，具有重叠子问题，可以被优化。</p><h2 id="Step-3-Recursive-memo-top-down"><a href="#Step-3-Recursive-memo-top-down" class="headerlink" title="Step 3. Recursive + memo (top-down)."></a>Step 3. Recursive + memo (top-down).</h2><p>用空间换时间的方法来优化重叠子问题，就是用一个“备忘录”将子问题<code>i</code>的结果记录下来。<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">      memo = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size() + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">return</span> rob(nums, nums.size() - <span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (memo[i] &gt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> memo[i];</span><br><span class="line">      <span class="keyword">int</span> result = max(rob(nums, i - <span class="number">2</span>) + nums[i], rob(nums, i - <span class="number">1</span>));</span><br><span class="line">      memo[i] = result;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Step-4-Iterative-memo-bottom-up"><a href="#Step-4-Iterative-memo-bottom-up" class="headerlink" title="Step 4. Iterative + memo (bottom-up)"></a>Step 4. Iterative + memo (bottom-up)</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size() + <span class="number">1</span>);</span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memo[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> val = nums[i];</span><br><span class="line">        memo[i + <span class="number">1</span>] = max(memo[i], memo[i - <span class="number">1</span>] + val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> memo[nums.size()];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Step-5-Iterative-2-variables-bottom-up"><a href="#Step-5-Iterative-2-variables-bottom-up" class="headerlink" title="Step 5. Iterative + 2 variables (bottom-up)"></a>Step 5. Iterative + 2 variables (bottom-up)</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prev1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prev2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> tmp = prev1;</span><br><span class="line">        prev1 = max(prev2 + num, prev1);</span><br><span class="line">        prev2 = tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> prev1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213.House Robber II"></a>213.House Robber II</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>这个题唯一变化的一点就是房子不再是一排，而是一圈。</p><p>House Robber II可以被分解成两个简单的House Robber问题：</p><ol><li>Rob houses 0 to n - 2;</li><li>Rob houses 1 to n - 1.</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Error C2678: no operator found which takes a left-hand operand of type &#39;const_ty&#39;</title>
      <link href="/C-Error-C2678-no-operator-found-which-takes-a-left-hand-operand-of-type-const-ty/"/>
      <url>/C-Error-C2678-no-operator-found-which-takes-a-left-hand-operand-of-type-const-ty/</url>
      
        <content type="html"><![CDATA[<p>今天在Windows平台下面用Visual Studio编写C++程序时遇到了一个这样的错误：</p><blockquote><p>Severity    Code    Description    Project    File    Line    Suppression State<br>Error    C2678    binary ‘&lt;’: no operator found which takes a left-hand operand of type ‘const _Ty’ (or there is no acceptable conversion)</p></blockquote><a id="more"></a><p>error的定位指向了<br><code>c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef</code>文件的<code>141</code>行。<br>起初看这个错误很奇怪，不知道是哪里代码有问题，后来一行一行测试代码，定位到这是包含自定义<code>struct</code>的<code>set</code>初始化时出错！于是我大概就明白了。</p><p>这里我构造了一个简单的例子来复现这个error, 尝试将struct <code>Edge</code>放入set中：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> src, dest;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Edge edge = { <span class="number">0</span>,<span class="number">1</span> };</span><br><span class="line"><span class="built_in">set</span>&lt;Edge&gt; edges = { edge };</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>C++ STL 中的<code>set</code>容器的特点是：</p><ol><li>set集合中不存在重复元素；</li><li>set集合中的元素都为有序排列，不管插入的顺序如何；</li><li>set不支持下标的操作。</li></ol><p>所以插入set中元素需是可排序类型，上面我们定义的struct <code>Edge</code> CPP的比较运算<code>&lt;</code>无法直接处理。解决办法就是<strong>通过重载 <code>&lt;</code> 运算符来支持对我们自定义的struct的比较</strong>：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> src, dest;</span><br><span class="line"><span class="comment">// compare for order.</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge&amp; pt) <span class="keyword">const</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> (src &lt; pt.src) || ((!(pt.src &lt; src)) &amp;&amp; (dest &lt; pt.dest));</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Edge edge = { <span class="number">0</span>,<span class="number">1</span> };</span><br><span class="line"><span class="built_in">set</span>&lt;Edge&gt; edges = { edge };</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>References:</p><ol><li><a href="https://stackoverflow.com/questions/41648480/how-to-create-stdset-of-structures?rq=1" target="_blank" rel="noopener">How to create std::set of structures</a></li><li><a href="https://stackoverflow.com/questions/5816658/how-to-have-a-set-of-structs-in-c" target="_blank" rel="noopener">How to have a set of structs in C++</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++中结构体的定义以及实例化</title>
      <link href="/C-CPP-Structer/"/>
      <url>/C-CPP-Structer/</url>
      
        <content type="html"><![CDATA[<h1 id="Difference-between-C-structures-and-C-structures"><a href="#Difference-between-C-structures-and-C-structures" class="headerlink" title="Difference between C structures and C++ structures"></a>Difference between C structures and C++ structures</h1><p>在C++中，struct和class基本上是一个东西，除了struct默认是public权限，class默认是private权限。<br>在C和C++结构体之间还有重要的区别：</p><ol><li>结构体中的成员函数：在C的结构体中不能有成员函数，在C++的结构体中可以有成员函数和数据成员。</li><li>直接初始化：在C中不能直接初始化结构体的数据成员，但是在C++中可以。<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C program to demonstrate that direct member initialization is not possible in C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">7</span>;  # Compiler Error</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Record</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, s.x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to initialize data member in c++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">7</span>;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Record s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>使用struct关键字：在C中，必须使用struct关键字声明一个结构体变量；在C++中，struct关键字并不是必须的。</li><li>静态成员：C中不能有静态成员，但C++中是可以的。<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C program with structure static member</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> {</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">};</span><br><span class="line"><span class="comment">/* 6:5: error: expected specifier-qualifier-list</span></span><br><span class="line"><span class="comment">   before 'static'</span></span><br><span class="line"><span class="comment">     static int x;</span></span><br><span class="line"><span class="comment">     ^*/</span></span><br></pre></td></tr></tbody></table></figure></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program with structure static member</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> {</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ol><li>结构体中的Constructor creation：在C的结构体中不能有constructor，但是C++ 中可以有。</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to initialize data member in c++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">    <span class="keyword">int</span> roll;</span><br><span class="line">    Student(<span class="keyword">int</span> x)</span><br><span class="line">    {</span><br><span class="line">        roll = x;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// Driver Program</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">struct Student <span class="title">s</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.roll;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>sizeof操作：在C中对一个空的结构体执行<code>sizeof</code>将返回<strong>0</strong>，在C++中则是<strong>1</strong>.</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> {</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ol><li>数据隐藏: C中的结构体不允许数据隐藏的概念，但是C++中却允许；因为C++是一个面向对象的语言而C并不是。</li><li><p>访问修饰符Access Modifiers：C结构体不支持访问修饰符, C++语言中内置了结构体对访问修饰符的支持。</p><h1 id="typedef-struct-VS-struct-definitions"><a href="#typedef-struct-VS-struct-definitions" class="headerlink" title="typedef struct VS struct definitions"></a>typedef struct VS struct definitions</h1><p>1.如果使用typedef来定义结构体时：型如typedef struct aaa { ..}bbb;<br>其中aaa是可以省略的，那么用bbb（如果有的话）来定义一个结构体变量时，可以直接用bbb xxx;就行。但用aaa来定义一个结构体变量时，则需要使用struct aaa xxx;<br>2.不使用typedef来定义结构体时，声明该类型变量都需要加上struct，即struct aaa xxx;</p></li></ol><h1 id="结构体的实例化malloc-vs-new"><a href="#结构体的实例化malloc-vs-new" class="headerlink" title="结构体的实例化malloc() vs new"></a>结构体的实例化malloc() vs new</h1><p>为了更方便地理解我们以单链表节点为例定义一个结构体：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">variable</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">      <span class="keyword">int</span> data;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">variable</span> *<span class="title">next</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><p>当声明一个结构体的指针时：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">variable</span> *<span class="title">ptr</span>;</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>结构体被定义，内存被分配(在32位机中4字节的内存分配给了这个指针)。而且<code>ptr</code>是一个automatic变量，也就是说它所在的内存位于栈区并且它的初始值为<code>garbage</code>(无效地址)。假设<code>ptr</code>目前的值是<code>0x1000</code>，如果你尝试<strong>de-reference</strong>间接引用这个指针，执行以下的操作会发生什么？<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;data = <span class="number">30</span>; <span class="comment">//(access to 0x1000)</span></span><br><span class="line">ptr-&gt;next = <span class="literal">NULL</span>; <span class="comment">//(access to 0x1004</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>CPU会尝试根据虚拟地址来访问物理内存地址，而在cache中又没有找到这个地址时，CPU会继续向操作系统请求这个地址。</p><p>但是上述的进程不见得在地址<code>0x1000</code>或<code>0x1004</code>有一个有效的(虚拟的)内存。所以操作系统经过检查然后告诉进程这是一个无效的内存访问。于是<strong>Segmentation Fault</strong>错误发生，操作系统杀掉了这个无效的内存访问。</p><p>为了使上述这个指针有用，我们应该把它指向一个有效的内存地址。在C语言中使用<strong>malloc</strong>函数是为指针指向一个有效地址的合理方法：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = (struct variable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct variable));</span><br></pre></td></tr></tbody></table></figure><p></p><p>而在C++中我们可以根据C++特有的动态内存分配来实例化一个对象：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable *ptr = <span class="keyword">new</span> variable();</span><br></pre></td></tr></tbody></table></figure><p></p><ol><li>new/delete是C++操作符，malloc/free是C/C++函数。</li><li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的大小。</li><li>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构，而malloc只负责分配空间。</li><li>new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void <em> ，需要通过强制类型转换将 void</em> 指针转换成我们需要的类型。</li><li>效率上：malloc的效率高一点，因为只分配了空间。</li><li>operator new /operator delete 可以被重载，而 malloc/free 并不允许重载。</li></ol><p>Reference：</p><ol><li><a href="https://www.quora.com/Is-it-necessary-to-use-malloc-for-creating-a-structure-pointer-variable-What-happens-if-I-just-declare-struct-variable-*ptr-instead-of-struct-variable-*ptr-struct-variable-*-malloc-sizeof-struct-variable-and-try-to-access-the-structure-members" target="_blank" rel="noopener"></a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Difference between the dot(.) and the arrow(-&gt;) operator in C++?</title>
      <link href="/Difference-between-the-dot-and-the-arrow-operator-in-C/"/>
      <url>/Difference-between-the-dot-and-the-arrow-operator-in-C/</url>
      
        <content type="html"><![CDATA[<p>structure.attribute<br>pointer-&gt;method<br>Use <code>-&gt;</code> when you have pointer. Use <code>.</code> when you have structure (class).<br><a id="more"></a><br>C++语言将箭头操作符（<code>-&gt;</code>）定义为间接引用(dereference)指针(pointer)的同义词，然后在该地址上使用(<code>.</code>)运算符。<br>例如：<br>如果你有一个对象<code>anObject</code>，和一个指针<code>aPointer</code>:<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SomeClass anObject = <span class="keyword">new</span> SomeClass();</span><br><span class="line">SomeClass *aPointer = &amp;anObject;</span><br></pre></td></tr></tbody></table></figure><p></p><p>为了使用其中一个对象方法，您可以dereference指针并对该地址执行方法调用：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*aPointer).method();</span><br></pre></td></tr></tbody></table></figure><p></p><p>也可以用箭头操作符写成如下的形式：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPointer-&gt;method();</span><br></pre></td></tr></tbody></table></figure><p></p><p>箭头操作符存在的主要原因是它缩短了一个非常常见的指针方法调用的拼写，因为你很容易忘记指针dereference周围的括号。<br>如果你忘记了括号，<code>(*aPointer).method();</code>就等价成了<code>*(aPointer.method());</code>，这肯定不是我们的目的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】38.count-and-say</title>
      <link href="/LeetCode38-count-and-say/"/>
      <url>/LeetCode38-count-and-say/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><pre><code>1.     12.     113.     214.     12115.     111221</code></pre><p>1 is read off as <code>"one 1"</code> or 11.<br>11 is read off as <code>"two 1s"</code> or 21.<br>21 is read off as <code>"one 2, then one 1"</code> or 1211.</p><p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>1：“1”<br>2：一个“1”-&gt;”11”<br>3: 两个“1”-&gt;”21”<br>4: 一个“2”，一个“1”-&gt;”1211”<br>5: 一个“1”，一个“2”，两个“1”-&gt;”111221”<br>6: 3个“1”，两个“2”，一个“1”-&gt;”312211”<br>。。。<br>思路就是每个数字把前一个数字的表达式数出来</p><h1 id><a href="#" class="headerlink" title="#"></a>#</h1><p>因为Python对字符串的处理比较方便，这里先实现了Python的递归方法：<br></p><figure class="highlight py"><figcaption><span>38.count-and-say.py</span><a href="https://github.com/fuhailin/show-me-python-code/blob/master/leetcode/38.count-and-say.py" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = <span class="string">"1"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            result = self.getNext(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self, last)</span>:</span></span><br><span class="line">        result = str()</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(last):</span><br><span class="line">            <span class="comment"># for i in range(len(last), 1):</span></span><br><span class="line">            <span class="keyword">if</span> i == (len(last)<span class="number">-1</span>):</span><br><span class="line">                result = result+str(count)+last[i]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> last[i] == last[i+<span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> == len(last)):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            result = result+str(count)+last[i]</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Solution().countAndSay(<span class="number">2</span>)</span><br><span class="line">print(test)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p><p>C++的实现：</p><figure class="highlight cpp"><figcaption><span>38.count-and-say.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/LeetCode/38.count-and-say.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        {</span><br><span class="line">            res = getNext(res);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// int myint = stoi();</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> last)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last.size(); i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (i == last.length() - <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                result.append(to_string(count)) += last.at(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (last.at(i) == last.at(i + <span class="number">1</span>))</span><br><span class="line">            {</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == last.length())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            result.append(to_string(count)) += last.at(i);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">string</span> res = solu.countAndSay(test);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>不过最终有意思的是，同样的思路，Python花费64ms，C++花费了4ms。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Git操作清单</title>
      <link href="/Git-command/"/>
      <url>/Git-command/</url>
      
        <content type="html"><![CDATA[<p> <strong>欢迎使用Git工具进行项目管理, 下面是我整理的常用 Git 操作清单。</strong></p><a id="more"></a><p>几个专用名词的译名如下。</p><blockquote><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p></blockquote><h1 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h1><blockquote><p><code>git init</code>: 在当前目录新建一个Git代码库<br><code>git init [project-name]</code>: 新建一个目录，将其初始化为Git代码库<br><code>git clone [url]</code>: 下载一个项目和它的整个代码历史</p></blockquote><h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p>Git的设置文件为 .gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><blockquote><p><code>git config --list</code> : 显示当前的Git配置<br><code>git config -e [--global]</code> : 编辑Git配置文件</p></blockquote><p><strong>git命令行下面显示中文字符</strong>:</p><blockquote><p><code>git config --global core.quotepath false</code>: 由于Git默认引用非ASCII 字符，disable它的引用行为可以用这个命令<br> 设置提交代码时的用户信息<br><code>git config [--global] user.name "Your Name"</code><br><code>git config [--global] user.email you@example.com</code></p></blockquote><h1 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h1><p><strong>git add</strong>: 把文件加入暂存区</p><blockquote><p><code>git add -A</code> : stages All<br><code>git add .</code> : stages new and modified, without deleted<br><code>git add -u</code> ： stages modified and deleted, without new<br>所以<code>git add -A</code> 等于  <code>git add .; git add -u</code><br><code>git add [file1] [file2] ...</code>: 添加指定文件到暂存区staging area<br><code>git add [dir]</code>: 添加指定目录到暂存区，包括子目录<br><code>git add -p</code>: 添加每个变化前，都会要求确认; 对于同一个文件的多处变化，可以实现分次提交</p></blockquote><p> 删除工作区文件：</p><blockquote><p><code>git rm [file1] [file2] ...</code>: 删除工作区文件，并且将这次删除放入暂存区<br><code>git rm --cached [file]</code>: 停止追踪指定文件，但该文件会保留在工作区<br><code>git mv [file-original] [file-renamed]</code>: 改名文件，并且将这个改名放入暂存区</p></blockquote><h1 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h1><p> <strong>git commit</strong>: To save t    he changes in the staging area.</p><blockquote><p><code>git commit -m "write your log message here."</code> : to save the changes in the staging area with your log message.<br><code>git commit [file1] [file2] ... -m [message]</code>: 提交暂存区的指定文件到仓库区</p></blockquote><p> If you use a command <code>git commit</code> without message ,you will open a log editors.<br> <strong>【Tip】</strong>:To save what you have written, type <kbd>Ctrl</kbd>+<kbd>O </kbd>to write the file out, then<kbd> Enter </kbd>to confirm the filename, then <kbd>Ctrl</kbd>+<kbd>X</kbd> and <kbd>Enter</kbd> to exit the editor.</p><blockquote><p><code>git commit -a</code>：—all       提交工作区自上次commit之后的变化，直接到仓库区<br>  Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.<br><code>git commit -v</code>：提交时显示所有diff信息<br><code>git commit --amend -m [message]</code>: 使用一次新的commit，替代上一次提交;如果代码没有任何新变化，则用来改写上一次commit的提交信息<br><code>git commit --amend [file1] [file2] ...</code>: 重做上一次commit，并包括指定文件的新变化</p></blockquote><h1 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h1><blockquote><p><code>git branch</code>: 列出所有本地分支<br><code>git branch -r</code>: 列出所有远程分支<br><code>git branch -a</code>: 列出所有本地分支和远程分支<br><code>git branch [branch-name]</code>: 新建一个分支，但依然停留在当前分支<br><code>git checkout -b [branch]</code>: 新建一个分支，并切换到该分支<br><code>git branch [branch] [commit]</code>: 新建一个分支，指向指定commit<br><code>git branch --track [branch] [remote-branch]</code>: 新建一个分支，与指定的远程分支建立追踪关系<br><code>git checkout [branch-name]</code>: 切换到指定分支，并更新工作区<br><code>git checkout -</code>: 切换到上一个分支<br><code>git branch --set-upstream [branch] [remote-branch]</code>: 建立追踪关系，在现有分支与指定的远程分支之间<br><code>git checkout -b Hailin/leetcode：</code> : 新建一个在“Hailin”目录下的“leetcode”分支，并切换到其上<br>  <img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180312111635714.png"></p><p><code>git merge [branch]</code>: 合并指定分支到当前分支<br><code>git cherry-pick [commit]</code>: 选择一个commit，合并进当前分支<br><code>git branch -d [branch-name]</code>: 删除分支<br> 删除远程分支:<br><code>git push origin --delete [branch-name]</code><br><code>git branch -dr [remote/branch]</code></p></blockquote><p> <img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180312111754710.png"></p><h1 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h1><blockquote><p><code>git tag</code>: 列出所有tag<br><code>git tag [tag]</code> # 新建一个tag在当前commit<br><code>git tag [tag] [commit]</code> # 新建一个tag在指定commit<br><code>git tag -d [tag]</code> # 删除本地tag<br><code>git push origin :refs/tags/[tagName]</code>  # 删除远程tag<br><code>git show [tag]</code> # 查看tag信息<br><code>git push [remote] [tag]</code> # 提交指定tag<br><code>git push [remote] --tags</code> # 提交所有tag<br><code>git checkout -b [branch] [tag]</code>  # 新建一个分支，指向某个tag</p></blockquote><h1 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h1><blockquote><p><code>git status</code> # 显示有变更的文件 Which displays a list of the files that have been modified since the last time changes were saved.</p></blockquote><p><strong>git log</strong>: 显示当前分支的版本历史 To view the log of the project’s history. When you run <code>git log</code>, Git automatically uses a pager to show one screen of output at a time. Press the <kbd>space </kbd>bar to go down a page or the<kbd> q </kbd>key to quit.</p><blockquote><p><code>git log path"</code> : to inspect only the changes to particular files or directories.where <code>path</code> is the path to a specific file or directory. The log for a file shows changes made to that file; the log for a directory shows when files were added or deleted in that directory, rather than when the contents of the directory’s files were changed.<br><code>git log --stat</code> # 显示commit历史，以及每次commit发生变更的文件<br><code>git log -S [keyword]</code> # 搜索提交历史，根据关键词<br><code>git log [tag] HEAD --pretty=format:%s</code> # 显示某个commit之后的所有变动，每个commit占据一行<br><code>git log [tag] HEAD --grep feature</code> # 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p></blockquote><p> 显示某个文件的版本历史，包括文件改名:</p><blockquote><p>git log —follow [file]<br><code>git whatchanged [file]</code></p><p><code>git log -p [file]</code> # 显示指定文件相关的每一次diff<br><code>git log -5 --pretty --oneline</code> # 显示过去5次提交<br><code>git shortlog -sn</code> # 显示所有提交过的用户，按提交次数排序<br><code>git blame [file]</code> # 显示指定文件是什么人在什么时间修改过</p></blockquote><p> <strong>git diff</strong>: 显示暂存区和工作区的差异 Without any filenames will show you all the changes in your repository</p><blockquote><p><code>git diff --cached [file]</code> # 显示暂存区和上一个commit的差异<br><code>git diff HEAD</code> # 显示工作区与当前分支最新commit之间的差异<br><code>git diff [first-branch]...[second-branch]</code> # 显示两次提交之间的差异<br><code>git diff --shortstat "@{0 day ago}"</code> # 显示今天你写了多少行代码<br><code>git diff filename</code> : to compare the file as it currently is to what you last saved<br><code>git diff directory</code>: will show you the changes to the files in some directory.<br><code>git diff -r HEAD path/to/file</code>: To compare a file’s current state to the changes in the staging area.  The<code>-r</code>flag means “compare to a particular revision”, <code>HEAD</code> is a shortcut meaning “the most recent commit”<br><code>git diff -r HEAD~1</code>: The label <code>HEAD~1</code> then refers to the commit before it, while <code>HEAD~2</code> refers to the commit before that, and so on.</p></blockquote><p>  <strong>git show</strong>: To view the details of a specific commit.</p><blockquote><p><code>git show 77d3</code> : you can use the command <code>git show</code> with the first few characters of the commit’s hash.<br><code>git show [commit]</code> # 显示某次提交的元数据和内容变化<br><code>git show --name-only [commit]</code> # 显示某次提交发生变化的文件<br><code>git show [commit]:[filename]</code> # 显示某次提交时，某个文件的内容<br><code>git reflog</code> # 显示当前分支的最近几次提交</p></blockquote><h1 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h1><blockquote><p><code>git fetch [remote]</code> # 下载远程仓库的所有变动<br><code>git remote -v</code> # 显示所有远程仓库<br><code>git remote show [remote]</code> # 显示某个远程仓库的信息<br><code>git remote add [shortname] [url]</code> # 增加一个新的远程仓库，并命名<br><code>git pull [remote] [branch]</code> # 取回远程仓库的变化，并与本地分支合并<br><code>git push [remote] [branch]</code> # 上传本地指定分支到远程仓库<br><code>git push [remote] --force</code> # 强行推送当前分支到远程仓库，即使有冲突<br><code>git push [remote] --all</code> # 推送所有分支到远程仓库</p></blockquote><h1 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h1><blockquote><p><code>git checkout [file]</code> # 恢复暂存区的指定文件到工作区<br><code>git checkout [commit] [file]</code> # 恢复某个commit的指定文件到暂存区和工作区<br><code>git checkout .</code> # 恢复暂存区的所有文件到工作区<br><code>git reset [file]</code> # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br><code>git reset --hard</code> # 重置暂存区与工作区，与上一次commit保持一致<br><code>git reset [commit]</code> # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset --hard [commit]</code> # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br><code>git reset --keep [commit]</code> # 重置当前HEAD为指定commit，但保持暂存区和工作区不变<br>  新建一个commit，用来撤销指定commit<br> 后者的所有变化都将被前者抵消，并且应用到当前分支:<br><code>git revert [commit]</code></p></blockquote><p><strong>git stash</strong>: 暂时将未提交的变化移除,保存当前工作进度，会把暂存区和工作区的改动保存起来</p><blockquote><p><code>git stash save 'message...'</code> : 可以添加一些注释<br><code>git stash list</code> : 显示保存进度的列表。也就意味着，git stash命令可以多次执行。<br><code>git stash pop</code>  :恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。<br><code>git stash pop --index</code> : 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）<br><code>git stash pop stash@{1}</code> : 恢复指定的进度到工作区。stash_id是通过git stash list命令得到的<br> 通过 <code>git stash pop</code> 命令恢复进度后，会删除当前进度。<br><code>git stash drop [stash_id]</code> : 删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度<br><code>git stash clear</code>: 删除所有存储的进度。<br><code>git stash apply [–index] [stash_id]</code> :  除了不删除恢复的进度之外，其余和git stash pop 命令一样。</p></blockquote><h1 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h1><blockquote><p><code>git archive</code> # 生成一个可供发布的压缩包</p></blockquote><h1 id="十一、中国大陆地区下载Github源代码速度慢的解决办法"><a href="#十一、中国大陆地区下载Github源代码速度慢的解决办法" class="headerlink" title="十一、中国大陆地区下载Github源代码速度慢的解决办法"></a>十一、中国大陆地区下载Github源代码速度慢的解决办法</h1><p>这里记录在Windows系统下clone github代码速度太慢的解决办法，亲测有效！</p><p>由于网络环境的限制，clone github代码速度只有4kb/s，实在是太慢了挂了VPN也一样。通过添加DNS可以解除一些网络限制：</p><ol><li>查询网站的IP地址，进入( <a href="http://tool.chinaz.com/dns" target="_blank" rel="noopener">http://tool.chinaz.com/dns</a> )，输入 github.com，结果如下所示：<img alt data-src="http://www.pianshen.com/images/926/09c9ece225c2cde531d00373dfc6a72e.JPEG"> 得到github.com对应两个IP地址，使用<code>ping</code>命令测试两个地址，选择一个TTL值较小的IP地址。</li><li>接着，我们打开电脑的 <code>C:\Windows\System32\drivers\etc</code> 目录，找到hosts文件; Linux系统下在<code>/etc/hosts</code></li><li>在文件末追加<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">151.101.197.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></tbody></table></figure></li></ol><p>保存后刷新DNS缓存。重新clone github， 速度得到明显提升，从4kb/s到300kb/s.</p><h1 id="十二、Sync-Git-Fork-to-the-Original-Repo"><a href="#十二、Sync-Git-Fork-to-the-Original-Repo" class="headerlink" title="十二、Sync Git Fork to the Original Repo"></a>十二、Sync Git Fork to the Original Repo</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add upstream https://github.com/[Original Owner Username]/[Original Repository].git</span><br><span class="line">$ git fetch upstream</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge upstream/master</span><br><span class="line">$ git push</span><br></pre></td></tr></tbody></table></figure><p><a href="https://digitaldrummerj.me/git-syncing-fork-with-original-repo/" target="_blank" rel="noopener">Sync your Git Fork to the Original Repo</a></p><h1 id="十三、Git-submodules"><a href="#十三、Git-submodules" class="headerlink" title="十三、Git submodules"></a>十三、Git submodules</h1><p>git submodules子模块功能允许你将其他的git 项目包含在你的项目当中，它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p><blockquote><p><code>git submodule add [url]</code> ： 为当前项目添加子模块<br><code>cat .gitmodules</code> : submodules 存储在 <code>.gitmodules</code>项目配置文件中:<br>  <img alt data-src="2019-02-17-123643.png"></p><p><code>git submodule add [url]</code> ： 为当前项目添加子模块</p></blockquote><h2 id="Project-workflow-with-submodules："><a href="#Project-workflow-with-submodules：" class="headerlink" title="Project workflow with submodules："></a>Project workflow with submodules：</h2>  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [parent_url]</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></tbody></table></figure><h2 id="如何删除submodules："><a href="#如何删除submodules：" class="headerlink" title="如何删除submodules："></a>如何删除submodules：</h2><ol><li>Delete the relevant line from the .gitmodules file.</li><li>Delete the relevant section from .git/config.</li><li>Run git rm –cached path_to_submodule (no trailing slash).</li><li>Commit and delete the now untracked submodule files.<br><a href="http://stackoverflow.com/questions/1260748/how-do-i-remove-a-git-submodule" target="_blank" rel="noopener">(Stack Overflow reference)</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu、macOS必备软件配置记录帖</title>
      <link href="/Essential-Apps/"/>
      <url>/Essential-Apps/</url>
      
        <content type="html"><![CDATA[<h1 id="For-Ubuntu"><a href="#For-Ubuntu" class="headerlink" title="For Ubuntu"></a>For Ubuntu</h1><h2 id="安装编辑器-amp-编译器"><a href="#安装编辑器-amp-编译器" class="headerlink" title="安装编辑器&amp;编译器"></a>安装编辑器&amp;编译器</h2><h3 id="1、安装Sublime-Text-3："><a href="#1、安装Sublime-Text-3：" class="headerlink" title="1、安装Sublime Text 3："></a>1、安装Sublime Text 3：</h3><p><a href="https://www.sublimetext.com/docs/3/linux_repositories.html" target="_blank" rel="noopener">https://www.sublimetext.com/docs/3/linux_repositories.html</a><br>apt Install the GPG key:</p><blockquote><p>wget -qO - <a href="https://download.sublimetext.com/sublimehq-pub.gpg" target="_blank" rel="noopener">https://download.sublimetext.com/sublimehq-pub.gpg</a> | sudo apt-key add -</p></blockquote><p>Ensure apt is set up to work with https sources:<br>sudo apt-get install apt-transport-https</p><blockquote><p>echo “deb <a href="https://download.sublimetext.com/" target="_blank" rel="noopener">https://download.sublimetext.com/</a> apt/stable/“ | sudo tee /etc/apt/sources.list.d/sublime-text.list<br>sudo apt-get update<br>sudo apt-get install sublime-text</p></blockquote><p>终端使用Sublime，输入: subl</p><h3 id="2、安装Atom："><a href="#2、安装Atom：" class="headerlink" title="2、安装Atom："></a>2、安装Atom：</h3><p>We can download the <a href="https://atom.io/download/deb" target="_blank" rel="noopener">Atom .deb package</a> and install it directly:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install Atom</span></span><br><span class="line">sudo dpkg -i atom-amd64.deb</span><br><span class="line"><span class="comment"># Install Atom's dependencies if they are missing</span></span><br><span class="line">sudo apt-get -f install</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="3、安装PyCharm："><a href="#3、安装PyCharm：" class="headerlink" title="3、安装PyCharm："></a>3、安装PyCharm：</h3><ul><li>Copy the <strong>pycharm-2017.3.3.tar.gz</strong> to the desired installation location<br>(make sure you have rw permissions for that directory)</li><li><p>Unpack the <strong>pycharm-2017.3.3.tar.gz</strong> using the following command:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf pycharm-2017.3.3.tar.gz</span><br></pre></td></tr></tbody></table></figure></li><li><p>Remove the <strong>pycharm-2017.3.3.tar.gz</strong> to save disk space (optional)</p></li><li>Run pycharm.sh from the bin subdirectory<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pycharm.sh</span><br></pre></td></tr></tbody></table></figure></li></ul><p>【Tip】: Pycharm的快捷启动方式<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo subl /usr/share/applications/Pycharm.desktop</span><br></pre></td></tr></tbody></table></figure><p></p><p>然后输入以下内容，注意Exec和Icon需要找到正确的路径</p><blockquote><p>[Desktop Entry]<br>Type=Application<br>Name=Pycharm<br>GenericName=Pycharm3<br>Comment=Pycharm3:The Python IDE<br>Exec=”/XXX/pycharm-community-3.4.1/bin/pycharm.sh” %f<br>Icon=/XXX/pycharm-community-3.4.1/bin/pycharm.png<br>Terminal=pycharm<br>Categories=Pycharm;</p><h3 id="Shadowsock"><a href="#Shadowsock" class="headerlink" title="Shadowsock"></a>Shadowsock</h3><h4 id="安装Shadowsock-server"><a href="#安装Shadowsock-server" class="headerlink" title="安装Shadowsock-server"></a>安装Shadowsock-server</h4><p>VPS ：<a href="https://my.vultr.com/" target="_blank" rel="noopener">https://my.vultr.com/</a><br>Setting：<a href="https://medium.com/@zoomyale/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E7%BB%88%E6%9E%81%E5%A7%BF%E5%8A%BF-%E5%9C%A8-vultr-vps-%E4%B8%8A%E6%90%AD%E5%BB%BA-shadowsocks-fd57c807d97e" target="_blank" rel="noopener">https://medium.com/@zoomyale/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E7%BB%88%E6%9E%81%E5%A7%BF%E5%8A%BF-%E5%9C%A8-vultr-vps-%E4%B8%8A%E6%90%AD%E5%BB%BA-shadowsocks-fd57c807d97e</a><br>Shadowsocks Python版一键安装脚本： <a href="https://teddysun.com/342.html" target="_blank" rel="noopener">https://teddysun.com/342.html</a></p></blockquote><h4 id="安装Shadowsock-qt5"><a href="#安装Shadowsock-qt5" class="headerlink" title="安装Shadowsock-qt5"></a>安装Shadowsock-qt5</h4><p><del>$ sudo add-apt-repository ppa:hzwhuang/ss-qt5</del><br><del>$ sudo apt-get update</del><br><del>$ apt-get install shadowsocks-qt5</del></p><p>下载<a href="https://github.com/shadowsocks/shadowsocks-qt5/releases" target="_blank" rel="noopener">Shadowsocks-Qt5-3.0.1-x86_64.AppImage</a><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$chmod</span> a+x Shadowsocks-Qt5-x86_64.AppImage</span><br><span class="line">$./Shadowsocks-Qt5-x86_64.AppImage</span><br></pre></td></tr></tbody></table></figure><p></p><p>全局pac配置：<br><code>pip install genpac</code></p><p><code>genpac --format=pac --pac-proxy="SOCKS5 127.0.0.1:1080" --output="autoproxy.pac"</code></p><p>genpac 的详细使用说明见 GitHub - Wiki：<br><a href="https://github.com/JinnLynn/GenPAC" target="_blank" rel="noopener">https://github.com/JinnLynn/GenPAC</a></p><p>设置全局代理<br>点击：System settings &gt; Network &gt; Network Proxy，选择 Method 为 Automatic，设置 Configuration URL 为 autoproxy.pac 文件的路径，点击 Apply System Wide。<br>格式如：file:///home/{user}/Downloads/shadowsocks/autoproxy.pac</p><p><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/screenshot_from_2019-01-14_20-28-26.png"></p><h3 id="5、安装Anaconda："><a href="#5、安装Anaconda：" class="headerlink" title="5、安装Anaconda："></a>5、安装Anaconda：</h3><p>download the <a href="http://anaconda.com/downloads.html" target="_blank" rel="noopener">Anaconda installer for Linux</a> and install it:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ~/Downloads/Anaconda3-5.0.1-Linux-x86_64.sh</span><br></pre></td></tr></tbody></table></figure><p></p><p>配置环境变量：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subl ~/.profile</span><br></pre></td></tr></tbody></table></figure><p></p><p>在最后加入：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Anaconda</span></span><br><span class="line"><span class="built_in">export</span> <span class="string">"PATH=/home/vincent/anaconda3/bin:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>保存后更新环境变量即可使用<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="6、安装NodeJS："><a href="#6、安装NodeJS：" class="headerlink" title="6、安装NodeJS："></a>6、安装NodeJS：</h3><p><a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions" target="_blank" rel="noopener">https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions</a></p><p>download the <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node-v8.9.4-linux-x64.tar.xz</a> and extra it to right directory:<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf node-v8<span class="number">.9</span><span class="number">.4</span>-linux-x64.tar.xz ~/Programs/nodejs <span class="comment">#解压文件到指定路径</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>配置环境变量：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></tbody></table></figure><p></p><p>在最后加入：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#NODEJS</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/home/vincent/Programs/node-v8.10.0-linux-x64/bin:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p><del>#NODEJS<br>export NODEJS_HOME=/home/vincent/Programs/nodejs/node-v8.9.4-linux-x64<br>export $NODEJS_HOME/bin:$PATH</del></p><p>保存后更新环境变量即可使用<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br><span class="line">v10.15.0</span><br><span class="line">npm --version</span><br><span class="line">6.4.1</span><br></pre></td></tr></tbody></table></figure><h3 id="7、安装Git："><a href="#7、安装Git：" class="headerlink" title="7、安装Git："></a>7、安装Git：</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></tbody></table></figure><h3 id="8、安装tmux："><a href="#8、安装tmux：" class="headerlink" title="8、安装tmux："></a>8、安装tmux：</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure><h2 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h2><h3 id="安装MySQL："><a href="#安装MySQL：" class="headerlink" title="安装MySQL："></a>安装MySQL：</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mysql-server</span><br><span class="line">mysql_secure_installation</span><br></pre></td></tr></tbody></table></figure><h3 id="安装MS-SQL-Server："><a href="#安装MS-SQL-Server：" class="headerlink" title="安装MS SQL Server："></a>安装MS SQL Server：</h3><p><a href="https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-ubuntu" target="_blank" rel="noopener">Quickstart: Install SQL Server and create a database on Ubuntu</a><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository <span class="string">"<span class="variable">$(wget -qO- https://packages.microsoft.com/config/ubuntu/16.04/mssql-server-2017.list)</span>"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y mssql-server</span><br><span class="line">sudo /opt/mssql/bin/mssql-conf setup</span><br><span class="line">systemctl status mssql-server</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你过去安装过 docker，先删掉</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common</span><br><span class="line"><span class="comment"># 信任 Docker 的 GPG 公钥</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 对于 amd64 架构的计算机，添加软件仓库:</span></span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04" target="_blank" rel="noopener">How To Install and Use Docker on Ubuntu 16.04</a><br><img alt="这里写图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180319151255921"></p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/docker-ce/" target="_blank" rel="noopener">Docker Community Edition 镜像使用帮助</a></p><hr><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install default-jre default-jdk</span><br></pre></td></tr></tbody></table></figure><p>vim ~/.bashrc: <code>export JAVA_HOME=/usr/lib/jvm/default-java</code><br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc    # 使变量设置生效</span><br><span class="line">echo $JAVA_HOME     # 检验变量值</span><br><span class="line">java -version</span><br><span class="line"><span class="meta">$</span><span class="bash">JAVA_HOME/bin/java -version  <span class="comment"># 与直接执行java -version一样</span></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>至此，就成功安装了Java环境<br>[Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04:第2种安装JDK方式]<a href="http://dblab.xmu.edu.cn/blog/install-hadoop/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/install-hadoop/</a></p><hr><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p>Hadoop3：<a href="https://fuhailin.github.io/Hadoop-Install/">https://fuhailin.github.io/Hadoop-Install/</a></p><hr><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><p><a href="http://www.cnblogs.com/wrencai/p/3867460.html" target="_blank" rel="noopener">http://www.cnblogs.com/wrencai/p/3867460.html</a></p><hr><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><p><a href="http://fuhailin.github.io/Spark-Tutorial/#Spark%E7%9A%84%E5%AE%89%E8%A3%85">http://fuhailin.github.io/Spark-Tutorial/#Spark%E7%9A%84%E5%AE%89%E8%A3%85</a></p><hr><h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y fcitx-bin</span><br><span class="line"><span class="comment"># google pinyin</span></span><br><span class="line">sudo apt install -y fcitx-googlepinyin</span><br><span class="line"><span class="comment"># sogou pinyin</span></span><br><span class="line">wget <span class="string">"http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb?st=qC_O2p5443g1a2TJR_rSdA&amp;e=1533163019&amp;fn=sogoupinyin_2.2.0.0108_amd64.deb"</span> -O sogoupinyin.deb &amp;&amp; \</span><br><span class="line">    yes | sudo gdebi sogoupinyin.deb &amp;&amp; \</span><br><span class="line">    rm sogoupinyin.deb</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="http://blog.zedyeung.com/2018/08/05/Ubuntu-18-04-fcitx-chinese-input-setup-google-and-sogou/input1.png"><br><strong>Reboot之后</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">第一步</th><th style="text-align:center">第二步</th><th style="text-align:center">第三步</th></tr></thead><tbody><tr><td style="text-align:center"><img alt data-src="http://blog.zedyeung.com/2018/08/05/Ubuntu-18-04-fcitx-chinese-input-setup-google-and-sogou/input2.png"></td><td style="text-align:center"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot_from_2019-01-15_10-55-12.png"></td><td style="text-align:center"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot_from_2019-01-15_10-55-36.png"> </td></tr></tbody></table></div><p> <kbd>Ctrl</kbd>+<kbd>Space</kbd>切换中英文输入</p><p><a href="http://blog.zedyeung.com/2018/08/05/Ubuntu-18-04-fcitx-chinese-input-setup-google-and-sogou/" target="_blank" rel="noopener">Ubuntu 18.04 fcitx chinese input setup(google and sogou)</a><br><a href="https://blog.csdn.net/f_c_g_/article/details/81265589" target="_blank" rel="noopener">ubuntu 18.04 英文环境安装搜狗输入法</a></p><hr><h2 id="升级16-04到18-04"><a href="#升级16-04到18-04" class="headerlink" title="升级16.04到18.04"></a>升级16.04到18.04</h2><p><a href="https://linuxconfig.org/how-to-upgrade-to-ubuntu-18-04-lts-bionic-beaver" target="_blank" rel="noopener">https://linuxconfig.org/how-to-upgrade-to-ubuntu-18-04-lts-bionic-beaver</a></p><hr><h2 id="其他专业软件"><a href="#其他专业软件" class="headerlink" title="其他专业软件"></a>其他专业软件</h2><h3 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h3><p>首先更换国内清华大学开源软件镜像站：<a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/</a></p><h4 id="Texlive"><a href="#Texlive" class="headerlink" title="Texlive"></a>Texlive</h4><p>LaTeX有很多发型版，TeX Live就是其中一种。TeX Live 是 TUG (TeX User Group) 维护和发布的 TeX 系统，可说是「官方」的 TeX 系统。TeX Live可以保持在跨操作系统平台、跨用户的一致性。而且TeX Live在Ubuntu18.04上的安装也比较方便。<br>Texlive需要的安装空间较大，需要在根目录预留4G的额外空间<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install texlive-full</span><br><span class="line"><span class="comment"># 安装XeLaTeX编译引擎</span></span><br><span class="line">sudo apt-get install texlive-xetex</span><br><span class="line"><span class="comment"># 安装中文支持包，使用的是xeCjK，中文处理技术也有很多，xeCJK是成熟且稳定的一种。</span></span><br><span class="line">sudo apt-get install texlive-lang-chinese</span><br></pre></td></tr></tbody></table></figure><p></p><div class="table-container"><table><thead><tr><th style="text-align:center">安装Texlive前</th><th style="text-align:center">安装Texlive后</th></tr></thead><tbody><tr><td style="text-align:center"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180718112621899"></td><td style="text-align:center"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180718112717961"></td></tr></tbody></table></div><p><a href="https://blog.csdn.net/qq_41814939/article/details/82288145" target="_blank" rel="noopener">Ubuntu18.04安装LaTeX并配置中文环境</a><br><a href="http://jun369.me/2018/10/22/latex/" target="_blank" rel="noopener">Ubuntu18 + VSCode + TexLive 配置中文Latex环境</a><br><a href="https://vanxnf.top/2018/09/15/Ubuntu-18-04-LTS-%E5%AE%89%E8%A3%85-Tex-Live/" target="_blank" rel="noopener">Ubuntu 18.04 LTS 安装 Tex Live</a></p><hr><h3 id="Nextcloud"><a href="#Nextcloud" class="headerlink" title="Nextcloud"></a>Nextcloud</h3><p>Nextcloud是一款开源的功能强大的私有云平台搭建框架，甚至还提供跨平台的各类终端。<br>命令行安装过程<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install snap</span><br><span class="line">sudo apt-get install snapd</span><br><span class="line">sudo snap install nextcloud</span><br></pre></td></tr></tbody></table></figure><p></p><p>安装完成通过IP地址直接访问</p><div class="table-container"><table><thead><tr><th style="text-align:center">Nextcloud Web界面</th><th style="text-align:center">Nextcloud iOS界面</th></tr></thead><tbody><tr><td style="text-align:center"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/netxcloud-web.png"></td><td style="text-align:center"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/nextcloud-mobile.png"></td></tr></tbody></table></div><p><a href="https://nextcloud.com/" target="_blank" rel="noopener">Nextcloud</a><br><a href="https://cloud.tencent.com/developer/labs/lab/10287" target="_blank" rel="noopener">基于 Ubuntu + nextCloud 搭建自己的私人网盘</a><br><a href="https://www.jianshu.com/p/9b2332a90337" target="_blank" rel="noopener">nextcloud打开链接Apache2 Ubuntu Default Page问题</a></p><hr><h3 id="navi-An-interactive-cheatsheet-tool-for-the-command-line"><a href="#navi-An-interactive-cheatsheet-tool-for-the-command-line" class="headerlink" title="navi: An interactive cheatsheet tool for the command-line"></a>navi: An interactive cheatsheet tool for the command-line</h3><p><a href="https://github.com/denisidoro/navi" target="_blank" rel="noopener">https://github.com/denisidoro/navi</a></p><h3 id="fzf-A-command-line-fuzzy-finder"><a href="#fzf-A-command-line-fuzzy-finder" class="headerlink" title="fzf: A command-line fuzzy finder"></a>fzf: A command-line fuzzy finder</h3><p><a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a></p><h3 id="Linuxbrew-Homebrew-on-Linux-un-installer"><a href="#Linuxbrew-Homebrew-on-Linux-un-installer" class="headerlink" title="Linuxbrew: Homebrew on Linux (un)installer"></a>Linuxbrew: Homebrew on Linux (un)installer</h3><p><a href="https://github.com/Linuxbrew/install" target="_blank" rel="noopener">https://github.com/Linuxbrew/install</a></p><h1 id="For-macOS"><a href="#For-macOS" class="headerlink" title="For macOS"></a>For macOS</h1><h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p><a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a><br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>Homebrew Cask</strong><br>HomeBrew是通过源码的方式来安装软件，但是有时候我们安装的软件是GUI程序应用宝(.dmg/.pkg)，这个时候我们就不能使用HomeBrew了，所以有了HomeBrew Cask的出现</p><p>brew cask 是在brew 的基础上一个增强的工具，用来安装Mac上的Gui程序应用包（.dmg/.pkg）, 比如qq、chrome等。它先下载解压到统一的目录中（/opt/homebrew-cask/Caskroom），省掉了自己去下载、解压、拖拽（安装）等步骤，同样，卸载相当容易与干净。然后再软链到~/Applications/目录下, 非常方便，而且还包含很多在 AppStore 里没有的常用软件。</p><p>brew cask的官网是：<a href="http://caskroom.io" target="_blank" rel="noopener">http://caskroom.io</a></p><p>github地址是：<a href="https://github.com/caskroom/homebrew-cask" target="_blank" rel="noopener">https://github.com/caskroom/homebrew-cask</a></p><h2 id="Htop"><a href="#Htop" class="headerlink" title="Htop"></a>Htop</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install htop</span><br></pre></td></tr></tbody></table></figure><h2 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h2><p><a href="https://www.iterm2.com/index.html" target="_blank" rel="noopener">https://www.iterm2.com/index.html</a><br><a href="https://gist.github.com/squarism/ae3613daf5c01a98ba3a" target="_blank" rel="noopener">iterm2 cheatsheet</a></p><h2 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></tbody></table></figure><p>vim ~/.zshrc<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_Profile</span><br></pre></td></tr></tbody></table></figure><p></p><p><a href="https://ohmyz.sh/" target="_blank" rel="noopener">https://ohmyz.sh/</a></p><p><strong>zsh-syntax-highlighting</strong>: 配置语法高亮<br><a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md</a></p><p><a href="https://tonyxu.io/zh/posts/2018/ultimate-way-to-beautify-mac-terminal-and-recommendations-for-plugins/" target="_blank" rel="noopener">https://tonyxu.io/zh/posts/2018/ultimate-way-to-beautify-mac-terminal-and-recommendations-for-plugins/</a></p><h2 id="Node-js-amp-NPM"><a href="#Node-js-amp-NPM" class="headerlink" title="Node.js &amp; NPM"></a>Node.js &amp; NPM</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></tbody></table></figure><h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install atom</span><br></pre></td></tr></tbody></table></figure><h2 id="Aria2"><a href="#Aria2" class="headerlink" title="Aria2"></a>Aria2</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For Ubuntu</span></span><br><span class="line">$ sudo apt install aria2</span><br><span class="line"><span class="comment"># For macOS</span></span><br><span class="line">$ brew install aria2</span><br></pre></td></tr></tbody></table></figure><h2 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h2><p><a href="https://docs.bazel.build/versions/master/install-os-x.html#install-on-mac-os-x-homebrew" target="_blank" rel="noopener">https://docs.bazel.build/versions/master/install-os-x.html#install-on-mac-os-x-homebrew</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Windows10+Ubuntu18.04双系统</title>
      <link href="/install-Windows10-Ubuntu18/"/>
      <url>/install-Windows10-Ubuntu18/</url>
      
        <content type="html"><![CDATA[<h3 id="Step-1-在硬盘上为Ubuntu在硬盘上创建一块空闲空间"><a href="#Step-1-在硬盘上为Ubuntu在硬盘上创建一块空闲空间" class="headerlink" title="Step:1 在硬盘上为Ubuntu在硬盘上创建一块空闲空间"></a>Step:1 在硬盘上为Ubuntu在硬盘上创建一块空闲空间</h3><p>登录Windows10系统，打开磁盘管理工具，我这里从D盘压缩出来了100G的空闲分区，保持此分区未分配；</p><h3 id="Step-2-制作Ubuntu安装镜像"><a href="#Step-2-制作Ubuntu安装镜像" class="headerlink" title="Step:2 制作Ubuntu安装镜像"></a>Step:2 制作Ubuntu安装镜像</h3><ol><li>下载Ubuntu18.04镜像文件</li><li>下载 Etcher 软件（用于制作一个可引导 Ubuntu 的 USB 驱动器）<br>Etcher用于为任何 Linux 发行版创建可启动的介质的工具，我推荐 Etcher。Etcher 可以在三大主流操作系统（Linux、MacOS 和 Windows）上运行且不会让你覆盖当前操作系统的分区。</li><li>一旦你下载完成并运行 Etcher，点击选择镜像并指向你在步骤 4 中下载的 Ubuntu ISO 镜像， 接下来，点击驱动器以选择你的闪存驱动器，然后点击 “Flash!” 开始将闪存驱动器转化为一个 Ubuntu 安装器的过程。 （如果你正使用一个 DVD-R，使用你电脑中的 DVD 烧录软件来完成此过程。）</li></ol><h3 id="Step-3-安装Ubuntu"><a href="#Step-3-安装Ubuntu" class="headerlink" title="Step:3 安装Ubuntu"></a>Step:3 安装Ubuntu</h3><p><strong>确保关闭了Windows系统的Secure Boot选项</strong>。Secure Boot：安全启动，只可以启动Win8及以上系统，不能启动其他系统（包括USB、Linux）等。<br>此处有第一个重要提醒：网上很多教程教你如何给Linux分区，其实完全没有必要，Ubuntu已经聪明到会使用空闲的磁盘区域，自动按照需求分区。<br>选择<code>USB启动</code><br>选择<code>Try Ubuntu</code>, 然后安装<br>选择<code>与现有系统共存</code>，<br><strong>此处有第一个重要提醒：网上很多教程教你如何给Linux分区，其实完全没有必要，Ubuntu已经聪明到会使用空闲的磁盘区域，自动按照需求分区。</strong><br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190114171716.jpg"><br>这里安装引导程序自动找到了刚刚创建的空闲分区</p><h3 id="Step-4-重新启动"><a href="#Step-4-重新启动" class="headerlink" title="Step:4 重新启动"></a>Step:4 重新启动</h3><p>选择你想进入的操作系统</p><hr><p>下面是在Windows10的磁盘管理工具下面看到的情况，Ubuntu已经自动使用了D盘下面100个G的空闲空间。<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190114165949.jpg"></p><p>Reference：</p><ol><li><a href="http://myviewsonfoss.blogspot.com/2018/05/this-article-willshow-you-how-you-can.html" target="_blank" rel="noopener">How to install Ubuntu 18.04 in dual boot alongside Windows 10</a></li><li><a href="https://weibo.com/ttarticle/p/show?id=2309404315285027958947#_0" target="_blank" rel="noopener">如何实现Linux+Windows双系统启动</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KDD China 2019</title>
      <link href="/KDD-China-2019/"/>
      <url>/KDD-China-2019/</url>
      
        <content type="html"><![CDATA[<p>2019 KDD China于2019年01月12日在深圳大学主办一场人工智能前沿技术峰会，我也报名参加啦~这是现场会议回忆笔记。</p><a id="more"></a><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112215438.jpg"></p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112215300.jpg"></p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112215226.jpg"></p><h1 id="周志华——机器学习的挑战"><a href="#周志华——机器学习的挑战" class="headerlink" title="周志华——机器学习的挑战"></a>周志华——机器学习的挑战</h1><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112223613.jpg"><br>非神经网络的深度模型——深度森林</p><h1 id="唐杰：网络表示学习理论与应用"><a href="#唐杰：网络表示学习理论与应用" class="headerlink" title="唐杰：网络表示学习理论与应用"></a>唐杰：网络表示学习理论与应用</h1><p>Node2Vec、DeepWalk</p><h1 id="Pearl-Pu-How-eople-Perceive-AI-Trust-and-Explanation"><a href="#Pearl-Pu-How-eople-Perceive-AI-Trust-and-Explanation" class="headerlink" title="Pearl Pu: How eople Perceive AI - Trust and Explanation"></a>Pearl Pu: How eople Perceive AI - Trust and Explanation</h1><p>算法的可解释性</p><h1 id="杨强-迁移学习和联邦学习"><a href="#杨强-迁移学习和联邦学习" class="headerlink" title="杨强: 迁移学习和联邦学习"></a>杨强: 迁移学习和联邦学习</h1><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112223948.jpg"><br>数据孤岛：分割的数据，不同业务部门、不同企业之间数据不连通<br>迁移学习：有大量的数据但是无标签的数据集A，有少量数据但是有标签的数据集B。在B上训练模型，迁移到A上</p><p>联邦学习：建立数据联盟，进行商业赋能。</p><h1 id="李航-Building-GlobalContent-Platform-Using-AI-Technologies"><a href="#李航-Building-GlobalContent-Platform-Using-AI-Technologies" class="headerlink" title="李航: Building GlobalContent Platform Using AI Technologies"></a>李航: Building GlobalContent Platform Using AI Technologies</h1><p>李航博士现任字节跳动公司人工智能实验室总监，主要介绍了字节跳动公司的工作，AI在字节跳动公司主要有三个商业目标：</p><ol><li>内容分发(信息流-今日头条，短视频-抖音 内容推荐)</li><li>内容审核(鉴黄，标题党识别)</li><li>内容创造(为广告主自动生成候选广告语、美颜P图、把跳舞美女的腿拉长、抖音变脸游戏、跳舞机)</li></ol><p>AI很强大，总之不要沉迷于抖音里的美女</p><h1 id="Fausto-Giunchiglia-Large-Scale-Privacy-Preserving-Data-Integration"><a href="#Fausto-Giunchiglia-Large-Scale-Privacy-Preserving-Data-Integration" class="headerlink" title="Fausto Giunchiglia: Large Scale Privacy Preserving Data Integration"></a>Fausto Giunchiglia: Large Scale Privacy Preserving Data Integration</h1><h1 id="王文博-多媒动态内容消费流信息的分析及应用：弹幕与在线视频赏析"><a href="#王文博-多媒动态内容消费流信息的分析及应用：弹幕与在线视频赏析" class="headerlink" title="王文博: 多媒动态内容消费流信息的分析及应用：弹幕与在线视频赏析"></a>王文博: 多媒动态内容消费流信息的分析及应用：弹幕与在线视频赏析</h1><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/4A781BD47ADB703043685FAF07834FA1.png"><br><!-- TIM图片20190112230026.jpg --><br>王文博教授的演讲最轻松了，比较接地气，集中了全场的幽默笑点。介绍了他们在弹幕方面的工作，通过弹幕理解视频内容，预测剧情发展，节目画像，在合理时机插入广告语</p><h1 id="谢幸-个性化推荐系统的未来"><a href="#谢幸-个性化推荐系统的未来" class="headerlink" title="谢幸: 个性化推荐系统的未来"></a>谢幸: 个性化推荐系统的未来</h1><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112222234.jpg"></p><p>首先回顾了推荐系统的历史和其中的经典模型<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112222357.jpg"></p><p>介绍了几项MSRA的工作，<br>开源项目DeepRec：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112223238.jpg"><br>深度学习(xDeepFM)做推荐(缺点-计算量挺大的)<br>知识图谱做推荐(RippleNek: 抽取实体关系建立无向有环图，根据领域关系把几跳范围之内的属性加入系统(类似波纹Ripple传播一圈一圈扩散)，实现推荐的多样性、解决冷启动、实现数据增广)<br>可解释性的推荐</p><p>现场提问环节：<br>有资深教授提问，许多学者在申请国基的时候需要填写自己最具有代表性的5篇工作，论文太多了填这些材料也很头疼，能否做一个工作自动根据关键字、作者、时间自动推荐代表作？<br>我觉得这完全可以用监督学习来做，学者网可以将这个作为一个研究点。</p><h1 id="王孝宇-Data-Mining：Online-to-Offline"><a href="#王孝宇-Data-Mining：Online-to-Offline" class="headerlink" title="王孝宇: Data Mining：Online to Offline"></a>王孝宇: Data Mining：Online to Offline</h1><h1 id="圆桌讨论"><a href="#圆桌讨论" class="headerlink" title="圆桌讨论"></a>圆桌讨论</h1><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20190112220622.jpg"><br>自由提问环节，</p><ol><li>首先观众提问了一个关于小数据的处理问题，大牛们纷纷给出了自己的见解。<br>观点一：Transfer Learning<br>观点二：从问题角度，小数据未必要用机器学习，专家系统，人肉解决<br>观点三： 引入额外数据，知识图谱，预训练</li><li>模型训练超参数如何确定？(AutoML)  正负样本比例悬殊？(采样问题)</li><li><p>测试集的特征与训练集特征不同或产生了变化怎么办？<br>尽量保证你的训练集和测试集特征一致不要产生变化</p><p>。。。</p><p>感悟：茶歇的抹茶千层真的好吃:)今年的研究热点在迁移学习、预训练BERT、强化学习、知识图谱、算法可解释性、深度图网络，这些是峰会高频词。</p><p>在会场偶遇师妹，附参会纪念照：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/wechat_20190112235147.jpg"></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hexo博客中插入图片的各种方式</title>
      <link href="/Hexo-images/"/>
      <url>/Hexo-images/</url>
      
        <content type="html"><![CDATA[<h2 id="在文章中插入图片"><a href="#在文章中插入图片" class="headerlink" title="在文章中插入图片"></a>在文章中插入图片</h2><p><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">Hexo博客搭建之在文章中插入图片</a></p><h3 id="绝对路径本地引用"><a href="#绝对路径本地引用" class="headerlink" title="绝对路径本地引用"></a>绝对路径本地引用</h3><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></tbody></table></figure><p></p><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h3 id="相对路径本地引用"><a href="#相对路径本地引用" class="headerlink" title="相对路径本地引用"></a>相对路径本地引用</h3><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过站点配置文件_config.yml来生成。<br><code>post_asset_folder: true</code><br>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></tbody></table></figure><h3 id="标签插件语法引用"><a href="#标签插件语法引用" class="headerlink" title="标签插件语法引用"></a>标签插件语法引用</h3><p>这种相对路径的图片显示方法在博文详情页面显示没有问题，但是在首页预览页面图片将显示不出来。如果希望<strong>图片在文章和首页中同时显示</strong>，可以使用标签插件语法。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 本地图片资源，不限制图片尺寸</span><br><span class="line">{% asset_img image.jpg This is an image %}</span><br><span class="line"># 网络图片资源，限制图片显示尺寸</span><br><span class="line">{% img http://www.viemu.com/vi-vim-cheat-sheet.gif 200 400 vi-vim-cheat-sheet %}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="HTML语法引用"><a href="#HTML语法引用" class="headerlink" title="HTML语法引用"></a>HTML语法引用</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"SpellCheck.png"</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"50%"</span> <span class="attr">title</span>=<span class="string">"拼写检查工具Grammarly."</span> <span class="attr">alt</span>=<span class="string">"拼写检查工具Grammarly."</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>直接将<code>![](image.jpg)</code>替换上面的语法即可。</p><h3 id="启用fancybox：点击查看图片大图"><a href="#启用fancybox：点击查看图片大图" class="headerlink" title="启用fancybox：点击查看图片大图"></a>启用fancybox：点击查看图片大图</h3><p>我这里使用的是Hexo的NexT主题，NexT主题中提供了fancybox的方便接口。</p><p>Usage：<a href="https://github.com/theme-next/theme-next-fancybox3" target="_blank" rel="noopener">https://github.com/theme-next/theme-next-fancybox3</a><br>markdown用法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% img http://www.viemu.com/vi-vim-cheat-sheet.gif 600 600 "点击查看大图:vi/vim-cheat-sheet" %}</span><br></pre></td></tr></tbody></table></figure><p><strong>Hexo部分图片禁用fancybox</strong></p><p>hexo在使用fancybox插件时，图片的效果还是很可观的，但是我们往往是不需要所有的图片都用fancybox；<br>例如：hexo next主题下，添加某些图片的时候，有些事不需要可点击的<br>修改<code>theme\next\source\js\src\utils.js</code> 红色字体部分；</p><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/source/js/src/utils.js b/source/js/src/utils.js</span><br><span class="line">index 0f3704e..8516665 100644</span><br><span class="line"><span class="comment">--- a/source/js/src/utils.js</span></span><br><span class="line"><span class="comment">+++ b/source/js/src/utils.js</span></span><br><span class="line">@@ -11,6 +11,7 @@ NexT.utils = NexT.$u = {</span><br><span class="line">       .not('.group-picture img, .post-gallery img')</span><br><span class="line">       .each(function() {</span><br><span class="line">         var $image = $(this);</span><br><span class="line"><span class="addition">+        if ($(this).hasClass('nofancybox')) return;</span></span><br><span class="line">         var imageTitle = $image.attr('title');</span><br><span class="line">         var $imageWrapLink = $image.parent('a');</span><br></pre></td></tr></tbody></table></figure><p>在img标签使用的时候加上class=”nofancybox”即可。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.viemu.com/vi-vim-cheat-sheet.gif"</span> <span class="attr">class</span>=<span class="string">"nofancybox"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim使用进阶手册</title>
      <link href="/vi-vim/"/>
      <url>/vi-vim/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3626706957,3136197828&amp;fm=58&amp;bpow=688&amp;bpoh=688"></p><p>Vim 是 Linux 系统上的最著名的文本/代码编辑器，也是早年的 Vi 编辑器的加强版。它的最大特色是完全使用键盘命令进行编辑，脱离了鼠标操作虽然使得入门变得困难，但上手之后键盘流的各种巧妙组合操作却能带来极为大幅的效率提升。另外，由于 Vim 的可配置性非常强，各种插件、语法高亮配色方案等多不胜数，无论作为代码编辑器或是文稿撰写工具都非常给力<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2712.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2712.png?v8">✒</span>.</p><a id="more"></a><h2 id="前言-vi-vim的区别"><a href="#前言-vi-vim的区别" class="headerlink" title="前言 vi/vim的区别"></a>前言 vi/vim的区别</h2><p>vim 是 vi 的升级版本，它不仅兼容vi的所有指令，还有新增了一些新的特性。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi filename</span><br><span class="line">vim filename</span><br><span class="line">// 两者同样的功能，能少敲一个字母，所以我们就用vi吧</span><br></pre></td></tr></tbody></table></figure><p>“工具总须多磨，方才用的趁手。”</p><p>终端键入 <code>vimtutor</code> 即可进入Vim入门教程，30分钟足以让你应对Vim日常操作。</p><p><strong>常规操作</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除光标下的字符</td></tr><tr><td>X</td><td>删除光标左边的字符</td></tr><tr><td>s</td><td>修改一个字符(与r的区别，修改后直接进入Insert模式)</td></tr><tr><td>i</td><td>光标前插入字符</td></tr><tr><td>a</td><td>光标后插入字符</td></tr><tr><td>A</td><td>行尾插入字符</td></tr><tr><td>o</td><td>光标下方新建一行并进入Insert模式</td></tr><tr><td>O (字母)</td><td>光标上方新建一行并进入Insert模式</td></tr><tr><td>r</td><td>替换字符(单个)</td></tr><tr><td>R</td><td>替换字符(多个)</td></tr><tr><td>cw</td><td>替换文本直到单词末尾(ce也可)</td></tr><tr><td>c$</td><td>替换文本直到行尾</td></tr><tr><td>dw</td><td>删除单词 (de, d2w)</td></tr><tr><td>d$</td><td>删除到行尾</td></tr><tr><td>D</td><td>删除到行尾</td></tr><tr><td>S</td><td>删除到行为，并进入Insert模式</td></tr><tr><td>dd</td><td>删除整行</td></tr><tr><td>y</td><td>复制</td></tr><tr><td>yy</td><td>复制整行 （yw, ye)</td></tr><tr><td>p</td><td>粘贴到光标之后</td></tr><tr><td>P</td><td>粘贴到光标之前</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>.</td><td>重复上一次操作</td></tr><tr><td>:!</td><td>执行外部名 (:!dir/:ls)</td></tr><tr><td>%</td><td>查找配对的括号 ), }, ]</td></tr><tr><td>v motion :w</td><td>选择性保存</td></tr><tr><td>Ctrl + D</td><td>查看可能的补全</td></tr></tbody></table></div><p><strong>光标移动</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右</td></tr><tr><td>k</td><td>上</td></tr><tr><td>j</td><td>下</td></tr><tr><td>0 (数字)</td><td>行首</td></tr><tr><td>$</td><td>行尾</td></tr><tr><td>w</td><td>下一个单词起始处</td></tr><tr><td>nw (2w)</td><td>n可为数字，表示移动两个单词</td></tr><tr><td>e</td><td>单词末尾（与w的区别）</td></tr><tr><td>gg</td><td>文件起始处</td></tr><tr><td>G</td><td>文件末尾处</td></tr></tbody></table></div><p><strong>退出</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>ZZ</td><td>保存并退出</td></tr><tr><td>:q!</td><td>丢弃修改并退出 (q退出，有修改的话q不能退出)</td></tr><tr><td>:e!</td><td>丢弃修改并打开原文件</td></tr></tbody></table></div><p><strong>查找并替换</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:s/old/new/g</code></td><td>查找old并替换为new，g代表整行匹配</td></tr><tr><td><code>:#, #s/old/new</code></td><td>#, #代表首尾行号</td></tr><tr><td><code>:%s/old/new/g</code></td><td>全文匹配替换</td></tr><tr><td><code>:%s/old/new/gc</code></td><td>全文匹配替换，并每次替换会弹出确认提示</td></tr></tbody></table></div><p>[注意]：如果你的字符串中包含<code>/</code>字符，为了防止命令冲突，你需要将你的<code>/</code>前加上转义符号，变成这样：<code>\/</code></p><p><strong>翻页</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + e</td><td>向下滚动一行</td></tr><tr><td>Ctrl + y</td><td>向上滚动一行</td></tr><tr><td>Ctrl + f</td><td>向下翻一页</td></tr><tr><td>Ctrl + b</td><td>向上翻一页</td></tr><tr><td>Ctrl + u</td><td>向上翻半页</td></tr><tr><td>Ctrl + d</td><td>向下翻半页</td></tr></tbody></table></div><p><strong>文件操作</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:e + filename</td><td>打开新文件</td></tr><tr><td>:r + filename</td><td>读取文件并插入到当前文件</td></tr></tbody></table></div><p><strong>选项设置</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:set ic</td><td>忽略大小写</td></tr><tr><td>:set is</td><td>部分匹配（like)</td></tr><tr><td>:set hls</td><td>高亮匹配</td></tr><tr><td>:set nu</td><td>显示行号</td></tr></tbody></table></div><p><strong>分屏启动vim</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>vim -on file1 file2…</td><td>水平分屏</td></tr><tr><td>vim -On file1 file2…</td><td>垂直分屏</td></tr></tbody></table></div><p><strong>关闭分屏</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + w  c</td><td>关闭当前窗口（如果是最后一个，无法关闭）</td></tr><tr><td>Ctrl + w q</td><td>关闭当前窗口（如果是最后一个，则退出vim)</td></tr></tbody></table></div><p><strong>分屏</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + w s</td><td>上下分屏</td></tr><tr><td>Ctrl + w v</td><td>左右分屏</td></tr><tr><td>:sp filename</td><td>左右分屏，且打开一个新的文件</td></tr><tr><td>:vsp filename</td><td>上下分屏，且打开一个新的文件</td></tr></tbody></table></div><p><strong>切换分屏（光标切换）</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + w l</td><td>右边</td></tr><tr><td>Ctrl + w h</td><td>左边</td></tr><tr><td>Ctrl + w j</td><td>上边</td></tr><tr><td>Ctrl + w k</td><td>下边</td></tr></tbody></table></div><p><strong>分屏尺寸调整</strong><br>TIPS: (上下分屏生效)</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + w =</td><td>所有屏一样高度</td></tr><tr><td>Ctrl + w +</td><td>增加高度</td></tr><tr><td>Ctrl + w -</td><td>减少高度</td></tr></tbody></table></div><p><img width="70%" height="70%" title="点击查看大图:vi/vim-cheat-sheet" alt="点击查看大图:vi/vim-cheat-sheet" data-src="http://www.viemu.com/vi-vim-cheat-sheet.gif"></p><h2 id="配置VIM"><a href="#配置VIM" class="headerlink" title="配置VIM"></a>配置VIM</h2><h3 id="安装VIM"><a href="#安装VIM" class="headerlink" title="安装VIM"></a>安装VIM</h3><p>源代码编译<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vim/vim.git</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line"><span class="built_in">cd</span> vim/src</span><br><span class="line">make</span><br></pre></td></tr></tbody></table></figure><p></p><p>或者<br><code>apt-get install vim</code></p><h2 id="快速配置版："><a href="#快速配置版：" class="headerlink" title="快速配置版："></a>快速配置版：</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime</span><br><span class="line">sh ~/.vim_runtime/install_awesome_vimrc.sh</span><br></pre></td></tr></tbody></table></figure><p><a href="https://github.com/amix/vimrc" target="_blank" rel="noopener">The ultimate Vim configuration: vimrc</a></p><p><strong>SpaceVIM</strong>:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLf https://spacevim.org/install.sh | bash</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="安装Vundle"><a href="#安装Vundle" class="headerlink" title="安装Vundle"></a>安装Vundle</h3><p><strong>VIM plug-in：<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">Vundle</a></strong></p><ul><li>Set up Vundle: <code>git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</code><br><code>touch ~/.vimrc</code>， set up Vundle in your .vimrc by adding the following to the top of the file:<script src="//gist.github.com/3070328ab89c2dfd163deea15d9dfb48.js?file=.vimrc"></script></li></ul><ol><li><a href="https://blog.easwy.com/archives/advanced-vim-skills-catalog/" target="_blank" rel="noopener">https://blog.easwy.com/archives/advanced-vim-skills-catalog/</a></li><li><a href="https://segmentfault.com/a/1190000017502205" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017502205</a></li><li><a href="https://realpython.com/vim-and-python-a-match-made-in-heaven/" target="_blank" rel="noopener">https://realpython.com/vim-and-python-a-match-made-in-heaven/</a></li><li>SpaceVim: <a href="https://spacevim.org/" target="_blank" rel="noopener">https://spacevim.org/</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】54.Spiral-Matrix</title>
      <link href="/LeetCode54-Spiral-Matrix/"/>
      <url>/LeetCode54-Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br>例如，如果输入如下矩阵：</p><blockquote><p>1 2 3 4<br>5 6 7 8<br>9 10 11 12<br>13 14 15 16</p></blockquote><p>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>比较直观的解法：<br>按照顺时针一圈一圈的打印，如何确定打印的圈数呢？</p><p>规律中可以发现圈数是跟矩阵的行列数是有关系的。<br>圈数 = min(行数，列数)/2  即：<code>int circle = (min(row, col) +1) &gt;&gt; 1</code><br>然后按照四个步骤打印一圈：</p><ol><li>从左到右打印一行</li><li>从上到下打印一列</li><li>从右到左打印一行</li><li>从下到上打印一列</li></ol><p>比较特殊的例子：<br><img alt="这里写图片描述" data-src="http://static.oschina.net/uploads/img/201607/22091117_YCPI.jpg"><br>最内一圈分别退化成只有两行、一列、一行，甚至可能只有一个数字。不论退化成什么，都至少需要执行第一步。<br>第三步要执行，固定的行，移动的列。至少需要<code>两行两列</code>，所以要满足此圈的<code>终止行号大于起始行号并且终止列号大于起始列号</code> ，即<code>row-i-1&gt;i &amp;&amp; c&gt;=i</code><br>第四步要执行，则至少需要<code>三行两列</code>，所以要此圈满足的<code>终止行号大于(起始行号+1)并且终止列号大于起始列号</code>，即<code>d&gt;i &amp;&amp; col-i-1 &gt; i</code></p><figure class="highlight cpp"><figcaption><span>54.spiral-matrix.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/LeetCode/54.spiral-matrix.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment">#  Author:           Hailin - https://fuhailin.github.io/</span></span><br><span class="line"><span class="comment">#  Email:            hailinfufu@outlook.com</span></span><br><span class="line"><span class="comment">#  Description:      /</span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span><br><span class="line">{</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">   <span class="keyword">if</span> (matrix.size() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">   <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">   <span class="keyword">int</span> circle = (min(row, col) + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; circle; i++)</span><br><span class="line">   {</span><br><span class="line">      <span class="comment">//from left to right</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> a = i; a &lt; col - i; a++)</span><br><span class="line">         result.push_back(matrix[i][a]);</span><br><span class="line">      <span class="comment">//from up to dowm</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> b = i + <span class="number">1</span>; b &lt; row - i; b++)</span><br><span class="line">         result.push_back(matrix[b][col - i - <span class="number">1</span>]);</span><br><span class="line">      <span class="comment">//from right to left 终止列号&gt;起始列号 &amp;&amp; (终止行号) &gt; 起始行号</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = col - i - <span class="number">2</span>; (c &gt;= i) &amp;&amp; (row - i - <span class="number">1</span> &gt; i); c--) <span class="comment">// 至少两行两列</span></span><br><span class="line">         result.push_back(matrix[row - i - <span class="number">1</span>][c]);</span><br><span class="line">      <span class="comment">//from bottom to top 终止行号&gt;起始行号+1&amp;&amp; 终止列号 &gt; 起始列号</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> d = row - i - <span class="number">2</span>; (d &gt; i) &amp;&amp; (col - i - <span class="number">1</span> &gt; i); d--) <span class="comment">// 至少三行两列</span></span><br><span class="line">         result.push_back(matrix[d][i]);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">int</span> M, N;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"The rows and columns of matrix"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(M, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N));</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">   <span class="comment">/* input example</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">1 2 3 4</span></span><br><span class="line"><span class="comment">5 6 7 8</span></span><br><span class="line"><span class="comment">9 10 11 12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">   {</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">      {</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; matrix[i][j];</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   res = printMatrix(matrix);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)</span><br><span class="line">   {</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】53. 最大子序和</title>
      <link href="/LeetCode53-maxsum-of-sublist/"/>
      <url>/LeetCode53-maxsum-of-sublist/</url>
      
        <content type="html"><![CDATA[<p>题目描述：<br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><a id="more"></a><h1 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h1><p>思路：遍历所有可能的子序列组合，得到最大的子序列和<code>max(nums[i:j])</code></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> maxsum = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.size(); j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> tempsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">            {</span><br><span class="line">                tempsum = tempsum + nums[k];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (tempsum &gt; maxsum)</span><br><span class="line">                maxsum = tempsum;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：$O(N3)$</p><h1 id="优化的暴力破解法"><a href="#优化的暴力破解法" class="headerlink" title="优化的暴力破解法"></a>优化的暴力破解法</h1><p>观察到上面的计算过程中，<code>nums[0:i]</code>和的计算过程与<code>nums[0:i+1]</code>和的计算过程只相差一个数<code>nums[i+1]</code>，因此<code>sum(nums[0:i+1])</code>可以简化为<code>sum(nums[0:i])+nums[i+1]</code></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> maxsum = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> tempsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.size(); j++)</span><br><span class="line">        {</span><br><span class="line">            tempsum = tempsum + nums[j];</span><br><span class="line">            <span class="keyword">if</span> (tempsum &gt; maxsum)</span><br><span class="line">                maxsum = tempsum;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：$O(N2)$</p><h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>该方法采用一种“分治”策略。其想法就是把问题分成两个大致相等的子问题，然后递归地对它们求解，这是“分”的阶段。“治”阶段就是将两个子问题的解修补到一起并可能再做些少量的附加工作，最后得到整个问题的解。</p><p>在我们的例子中，最大子序列的和只可能出现在3个地方：</p><ol><li>出现在输入数据的左半部分</li><li>出现在输入数据的右半部分</li><li>跨越输入数据的中部而位于左右两个部分</li></ol><p>前两种情况可以递归求解，第三种情况的最大和可以通过求出前半部分（包含前半部分的最后一个元素）的最大和以及后半部分（包括后半部分的第一个元素）的最大和，再将二者相加得到。作为例子，考虑以下输入：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">    前半部分           后半部分</span><br><span class="line">-----------------------------------------</span><br><span class="line">-2, 11, 8, -4,    -1, 16, 5, 0</span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></tbody></table></figure><p>其中，前半部分的最大子序列和为19（A2~A3），而后半部分的最大子序列和为21（A6～A7）。前半部分包含其最后一个元素的最大和是15（A2～A4），后半部分包含第一个元素的最大和是20（A5～A7）。因此，跨越这两部分的这个子序列才是拥有最大和的子序列，和为15+20=35（A2～A7）。于是出现了下面这种算法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (left == right)</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLeftSum = divide(nums, left, center);</span><br><span class="line">    <span class="keyword">int</span> maxRightSum = divide(nums, center + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftBorderSum = <span class="number">0x80000000</span>, tmpleft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = center; i &gt;= left; i--)</span><br><span class="line">    {</span><br><span class="line">        tmpleft = tmpleft + nums[i];</span><br><span class="line">        <span class="keyword">if</span> (tmpleft &gt; leftBorderSum)</span><br><span class="line">            leftBorderSum = tmpleft;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightBorderSum = <span class="number">0x80000000</span>, tmpright = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = center + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">    {</span><br><span class="line">        tmpright = tmpright + nums[i];</span><br><span class="line">        <span class="keyword">if</span> (tmpright &gt; rightBorderSum)</span><br><span class="line">            rightBorderSum = tmpright;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max({maxLeftSum, maxRightSum, leftBorderSum + rightBorderSum});</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分治法算法复杂度分析：</p><p>算法的递推关系：$T(n)=2*T(n/2) + cn$，c为常数</p><p>若$n = 2 ^ { k }$ ，则有</p><script type="math/tex; mode=display">\begin{array} { l } { T ( n ) = 2 \cdot T \left( \frac { n } { 2 } \right) + c \cdot n } \\{ = 2 \cdot \left( 2 \cdot T \left( \frac { n } { 4 } \right) + c \cdot \frac { n } { 2 } \right) + c \cdot n = 4 T \left( \frac { n } { 4 } \right) + 2 c \cdot n } \\{ = 4 \left( 2 \cdot T \left( \frac { n } { 8 } \right) + c \cdot \frac { n } { 4 } \right) + 2 c \cdot n = 8 T \left( \frac { n } { 8 } \right) + 3 c \cdot n } \\{ = 8 \left( 2 \cdot T \left( \frac { n } { 16 } \right) + c \cdot \frac { n } { 8 } \right) + 3 c \cdot n = 16 T \left( \frac { n } { 8 } \right) + 4 c \cdot n } \\{ = \cdots \ldots } \\ { = 2 ^ { k } T ( 1 ) + k c \cdot n = a n + c n \log _ { 2 } n } \end{array}</script><p>时间复杂度：$O(NlogN)$</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>-具有最优子结构，和重叠子问题， 动态规划的算法思路：</p><p>最大连续子序列和只可能是以位置0～n-1中某个位置结尾。当遍历到第i个元素时，判断在它前面的连续子序列和是否大于0，如果大于0，则以位置i结尾的最大连续子序列和为元素i和前门的连续子序列和相加；否则，则以位置i结尾的最大连续子序列和为元素i。</p><p>状态转移方程： sum[i]=max(sum[i-1]+a[i],a[i])</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray_DP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">int</span> curMax = nums[<span class="number">0</span>], allMax = nums[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">   {</span><br><span class="line">      curMax = max(nums[i], curMax + nums[i]);</span><br><span class="line">      allMax = max(allMax, curMax);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> allMax;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum = num;</span><br><span class="line">        res = max(res, sum);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Pandas在Excel中输出折线图</title>
      <link href="/Pandas-Excel/"/>
      <url>/Pandas-Excel/</url>
      
        <content type="html"><![CDATA[<p>在银行业务中报表需要可视化，记录a simple example of converting a Pandas dataframe to an Excel file with a line chart using Pandas and XlsxWriter<sup><a href="#fn_1" id="reffn_1">1</a></sup>.</p><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>： Here is the footnote.</p><a id="more"></a><p><img alt data-src="https://xlsxwriter.readthedocs.io/_images/pandas_chart_line.png"></p><figure class="highlight py"><figcaption><span> example_pandas_chart_line</span><a href="/downloads/code/chart2Excel.py">view raw</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># An example of converting a Pandas dataframe to an xlsx file with a line</span></span><br><span class="line"><span class="comment"># chart using Pandas and XlsxWriter.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright 2013-2018, John McNamara, jmcnamara@cpan.org</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create some sample data to plot.</span></span><br><span class="line">max_row     = <span class="number">21</span></span><br><span class="line">categories  = [<span class="string">'Node 1'</span>, <span class="string">'Node 2'</span>, <span class="string">'Node 3'</span>, <span class="string">'Node 4'</span>]</span><br><span class="line">index_1     = range(<span class="number">0</span>, max_row, <span class="number">1</span>)</span><br><span class="line">multi_iter1 = {<span class="string">'index'</span>: index_1}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> category <span class="keyword">in</span> categories:</span><br><span class="line">    multi_iter1[category] = [random.randint(<span class="number">10</span>, <span class="number">100</span>) <span class="keyword">for</span> x <span class="keyword">in</span> index_1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Pandas dataframe from the data.</span></span><br><span class="line">index_2 = multi_iter1.pop(<span class="string">'index'</span>)</span><br><span class="line">df      = pd.DataFrame(multi_iter1, index=index_2)</span><br><span class="line">df      = df.reindex(columns=sorted(df.columns))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Pandas Excel writer using XlsxWriter as the engine.</span></span><br><span class="line">sheet_name = <span class="string">'Sheet1'</span></span><br><span class="line">writer     = pd.ExcelWriter(<span class="string">'pandas_chart_line.xlsx'</span>, engine=<span class="string">'xlsxwriter'</span>)</span><br><span class="line">df.to_excel(writer, sheet_name=sheet_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Access the XlsxWriter workbook and worksheet objects from the dataframe.</span></span><br><span class="line">workbook  = writer.book</span><br><span class="line">worksheet = writer.sheets[sheet_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a chart object.</span></span><br><span class="line">chart = workbook.add_chart({<span class="string">'type'</span>: <span class="string">'line'</span>})</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure the series of the chart from the dataframe data.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(categories)):</span><br><span class="line">    col = i + <span class="number">1</span></span><br><span class="line">    chart.add_series({</span><br><span class="line">        <span class="string">'name'</span>:       [<span class="string">'Sheet1'</span>, <span class="number">0</span>, col],</span><br><span class="line">        <span class="string">'categories'</span>: [<span class="string">'Sheet1'</span>, <span class="number">1</span>, <span class="number">0</span>,   max_row, <span class="number">0</span>],</span><br><span class="line">        <span class="string">'values'</span>:     [<span class="string">'Sheet1'</span>, <span class="number">1</span>, col, max_row, col],</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure the chart axes.</span></span><br><span class="line">chart.set_x_axis({<span class="string">'name'</span>: <span class="string">'Index'</span>})</span><br><span class="line">chart.set_y_axis({<span class="string">'name'</span>: <span class="string">'Value'</span>, <span class="string">'major_gridlines'</span>: {<span class="string">'visible'</span>: <span class="literal">False</span>}})</span><br><span class="line"></span><br><span class="line"><span class="comment"># Insert the chart into the worksheet.</span></span><br><span class="line">worksheet.insert_chart(<span class="string">'G2'</span>, chart)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close the Pandas Excel writer and output the Excel file.</span></span><br><span class="line">writer.save()</span><br></pre></td></tr></tbody></table></figure><p><a href="https://xlsxwriter.readthedocs.io/example_pandas_chart.html" target="_blank" rel="noopener">https://xlsxwriter.readthedocs.io/example_pandas_chart.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL</title>
      <link href="/PostgreSQL/"/>
      <url>/PostgreSQL/</url>
      
        <content type="html"><![CDATA[<p>PostgreSQL的一些特点：PostgreSQL中可以插入重复数据，也就是说不需要唯一性主键。</p><h1 id="PostgreSQL在Ubuntu下的安装"><a href="#PostgreSQL在Ubuntu下的安装" class="headerlink" title="PostgreSQL在Ubuntu下的安装"></a>PostgreSQL在Ubuntu下的安装</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install postgresql postgresql-contrib</span><br></pre></td></tr></tbody></table></figure><p>安装完成后，默认会：</p><p>（1）创建名为”postgres”的Linux用户<br>（2）创建名为”postgres”、不带密码的默认数据库账号作为数据库管理员<br>（3）创建名为”postgres”的表</p><p>安装完成后的一些默认信息如下：</p><p>config /etc/postgresql/9.5/main<br>data /var/lib/postgresql/9.5/main<br>locale en_US.UTF-8<br>socket /var/run/postgresql<br>port 5432</p><h2 id="PostgreSQL在终端中的使用"><a href="#PostgreSQL在终端中的使用" class="headerlink" title="PostgreSQL在终端中的使用"></a>PostgreSQL在终端中的使用</h2><ul><li><code>\password</code>：设置密码</li><li><code>\q</code>：退出</li><li><code>\h</code>：查看SQL命令的解释，比如\h select。</li><li><code>\?</code>：查看psql命令列表。</li><li><code>\l</code>：列出所有数据库。</li><li><code>\c</code> [database_name]：连接其他数据库。</li><li><code>\d</code>：列出当前数据库的所有表格。</li><li><code>\d [table_name]</code>：列出某一张表格的结构。</li><li><code>\du</code>：列出所有用户。</li><li><code>\e</code>：打开文本编辑器。</li><li><code>\conninfo</code>：列出当前数据库和连接的信息。</li><li><code>psql -U postgres -c 'SHOW config_file'</code>：显示postgresql.conf位置</li><li><code>sudo /etc/init.d/postgresql start</code> ：  # 开启</li><li><code>sudo /etc/init.d/postgresql stop</code>  ：  # 关闭</li><li><code>sudo /etc/init.d/postgresql restart</code>： # 重启</li><li>``</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">    column1 <span class="built_in">integer</span>,</span><br><span class="line">    column2 <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">20</span>),</span><br><span class="line">    column3 <span class="built_in">numeric</span>(<span class="number">19</span>,<span class="number">3</span>),</span><br><span class="line">    column4 <span class="built_in">numeric</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h3 id="PostgreSQL-中获取表名、数据库名称"><a href="#PostgreSQL-中获取表名、数据库名称" class="headerlink" title="PostgreSQL 中获取表名、数据库名称"></a>PostgreSQL 中获取表名、数据库名称</h3><p>①表名<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tablename <span class="keyword">FROM</span> pg_tables <span class="keyword">WHERE</span> tablename <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">'pg%'</span> <span class="keyword">AND</span> tablename <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">'sql_%'</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>②数据库名</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> datname <span class="keyword">FROM</span> pg_database;</span><br></pre></td></tr></tbody></table></figure><p>③列名</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name = <span class="string">'final_back_pg_lv10'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Python连接PostgreSQL"><a href="#Python连接PostgreSQL" class="headerlink" title="Python连接PostgreSQL"></a>Python连接PostgreSQL</h3><p><strong>配置允许远程访问</strong></p><ol><li>修改postgresql.conf</li></ol><p><code>vim /etc/postgresql/xx/main/postgresql.conf</code>，这里的x取决于你安装PostgreSQL的版本号，编辑<code>listen_addresses</code>一行，使PostgreSQL可以接受来自任意IP的连接请求。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = '*'</span><br></pre></td></tr></tbody></table></figure><p></p><ol><li>修改pg_hba.conf</li></ol><p><code>vim /etc/postgresql/xx/main/pg_hba.conf</code>，位置与postgresql.conf相同，虽然上面配置允许任意地址连接PostgreSQL，但是这在pg中还不够，我们还需在pg_hba.conf中配置服务端允许的认证方式。任意编辑器打开该文件，编辑或添加下面一行。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line">host    all             all             0.0.0.0/0               md5</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pandas.io.sql <span class="keyword">as</span> psql</span><br><span class="line"></span><br><span class="line"><span class="comment">## ****** LOAD PSQL DATABASE ***** ##</span></span><br><span class="line"></span><br><span class="line">PGHOST = <span class="string">'192.168.1.4'</span></span><br><span class="line">PGDATABASE = <span class="string">'postgres'</span></span><br><span class="line">PGUSER = <span class="string">'postgres'</span></span><br><span class="line">PGPASSWORD = <span class="string">'********'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a connection to the postgres server.</span></span><br><span class="line">conn_string = <span class="string">"host="</span> + PGHOST + <span class="string">" port="</span> + <span class="string">"5432"</span> + <span class="string">" dbname="</span> + PGDATABASE + <span class="string">" user="</span> + PGUSER \</span><br><span class="line">    + <span class="string">" password="</span> + PGPASSWORD</span><br><span class="line">conn = psycopg2.connect(conn_string)</span><br><span class="line">print(<span class="string">"Connected!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a cursor object</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(schema, table)</span>:</span></span><br><span class="line"></span><br><span class="line">    sql_command = <span class="string">"SELECT * FROM {}.{};"</span>.format(str(schema), str(table))</span><br><span class="line">    print(sql_command)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load the data</span></span><br><span class="line">    data = pd.read_sql(sql_command, conn)</span><br><span class="line"></span><br><span class="line">    print(data.shape)</span><br><span class="line">    <span class="keyword">return</span> (data)</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Linux下面的文件权限</title>
      <link href="/Linux-File-Authority/"/>
      <url>/Linux-File-Authority/</url>
      
        <content type="html"><![CDATA[<h1 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h1><p>在终端中输入<code>ls -l directory/filename</code>来查看文件的权限；<br>在终端中输入<code>ls -ld directory</code>来查看目录的权限；</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/1.png"></p><p>在命令行中查看权限的结果是这样的：</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/03-01-02.png"></p><p>输出的结果主要由四部分组成：</p><ol><li><code>Type</code>: 很多种 (最常见的是 - 为文件, d 为文件夹, 其他的还有l, n … )</li><li>用户权限</li><li>接下来的数字显示的是文件的硬链接数。</li><li><p>最后一部分是Owner和Group所有者的格式。</p><h1 id="权限组"><a href="#权限组" class="headerlink" title="权限组"></a>权限组</h1><p>在Linux下面，每个用户和目录有三种不同的用户权限组：</p><ul><li><strong>owner</strong>: Owner权限仅适用于文件或目录的所有者，它们不会影响其他用户的操作；</li><li><strong>group</strong>: Group权限仅适用于已分配给文件或目录的组，它们不会影响其他用户的操作；</li><li><strong>all users</strong>: “所有用户”权限适用于系统上的所有其他用户，这是您要注意最多的权限组。</li></ul><h1 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h1><p>每一个文件或者目录又有三种基本的权限类型：</p><ul><li><strong>read</strong>: 读取权限是指用户读取文件内容的功能。</li><li><strong>write</strong>: 写入权限是指用户编写或修改文件或目录的功能。</li><li><strong>execute</strong>:  执行权限会影响用户执行文件或查看目录内容的能力。</li></ul></li></ol><h1 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h1><p>在命令行中修改权限类型的命令是<strong>chmod</strong><br>在命令行中修改权限所有者的命令是<strong>chown</strong></p><h2 id="精确定义权限"><a href="#精确定义权限" class="headerlink" title="精确定义权限"></a>精确定义权限</h2><p>精确定义权限需要定义权限组和权限类型</p><p>可以使用的权限组有：<br><strong>u</strong> - Owner<br><strong>g</strong> - Group<br><strong>o</strong> - Others<br><strong>a</strong> - All users</p><p>可以使用权限分配操作符 <strong>+</strong>(加权限)和 <strong>-</strong>(减权限)来告诉操作系统增加还是移除对应的权限。</p><p>可以使用的权限类型有：<br><strong>r</strong> - 读取<br><strong>w</strong> - 写去<br><strong>x</strong> - 执行</p><p>例如，如果我把 <em>file1</em> 的权限设置为<code>_rw_rw_rw</code>，其意思就是文件<code>Owner、Group、all users</code>将具有<strong>读取</strong>和<strong>写入</strong>的权限</p><p><code>chmod a-rw file1</code>：将<em>all users</em>的<em>读取、写入</em>权限移除</p><p><code>chmod a+rw file1</code>: 为<em>all users</em>增加<em>读取、写入</em>权限</p><p><code>chmod +rw folder/</code>: 为当前用户增加对 <code>folder</code>目录的 <em>读取、写入</em>权限</p><p><code>chmod -R +rw folder/</code>: 为当前用户增加对 <code>folder</code>目录及其子文件目录的 <em>读取、写入</em>权限；<code>-R</code>:for recursive traversal of all files and subfolders</p><p><code>chown -R hailin:hailingroup folder/</code>: 将当前目录的所有者修改为：<code>hailin</code>，用户组修改为<code>hailingroup</code></p><hr><h1 id="一个执行Python文件的技巧"><a href="#一个执行Python文件的技巧" class="headerlink" title="一个执行Python文件的技巧"></a>一个执行Python文件的技巧</h1><p>如果一个<code>.py</code> 没有 <code>x</code> 权限, 在 terminal 中你就需要这样执行:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 t.py</span><br><span class="line">This is a Python script!</span><br></pre></td></tr></tbody></table></figure><p>如果你有了 <code>x</code> (可执行权限), 你运行这个文件可以直接这样打:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./t.py</span><br><span class="line">This is a Python script!</span><br></pre></td></tr></tbody></table></figure><p>如果你天天要运行这个脚本, 每次运行的时候少几个字还是挺好的. 如果你决定要这样做, 你在这个 Python 脚本的开头还需要加一句话.</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3        # 这句话是为了告诉你的电脑执行这个文件的时候用什么来加载</span></span><br><span class="line">print(<span class="string">"This is a Python script!"</span>)</span><br></pre></td></tr></tbody></table></figure><p>未完待续</p><p><strong>Good References:</strong><br><a href="https://www.linux.com/learn/understanding-linux-file-permissions" target="_blank" rel="noopener">Understanding Linux File Permissions</a><br><a href="https://morvanzhou.github.io/tutorials/others/linux-basic/3-01-file-permissions/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/others/linux-basic/3-01-file-permissions/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信用评分模型的评估指标</title>
      <link href="/Evaluation-Credit-model/"/>
      <url>/Evaluation-Credit-model/</url>
      
        <content type="html"><![CDATA[<p>最近在做某银行的客户信用评分模型时接触到几个模型稳定性的评估指标，只要有PSI、VOI、K-S值等统计学概念，之前不太了解，这里记录一下。</p><a id="more"></a><h4 id="预测能力指标"><a href="#预测能力指标" class="headerlink" title="预测能力指标"></a>预测能力指标</h4><p>用于评估模型对违约事件的预测能力，比如：</p><ul><li>WOE/VOI</li><li>ROC/AUC</li><li>K-S指标</li><li>GINI系数</li></ul><h5 id="WOE-amp-VOI"><a href="#WOE-amp-VOI" class="headerlink" title="WOE&amp;VOI"></a>WOE&amp;VOI</h5><p>WOE(Weight of Evidence)叫做证据权重，VOI(Value of Information )叫做信息价值，是一组评估变量的预测能力的指标。也就是说，当我们想要拿出证据证明“年龄”这个变量对于违约概率是否有影响的时候，可以使用这个指标评估年龄到底对违约概率的影响有多大。</p><script type="math/tex; mode=display">WOE = ln[(正常/总正常)/(违约/总违约)]</script><script type="math/tex; mode=display">VOI =</script><h5 id="ROC-AUC"><a href="#ROC-AUC" class="headerlink" title="ROC/AUC"></a>ROC/AUC</h5><p>这个就不再详写了，学过机器学习的都知道。</p><h5 id="K-S-Kolmogorov-Smirnov"><a href="#K-S-Kolmogorov-Smirnov" class="headerlink" title="K-S(Kolmogorov-Smirnov)"></a>K-S(Kolmogorov-Smirnov)</h5><p>作为一个模型，我们当然希望这个模型能够帮我们挑选到最多的好客户，同时不要放进来那么多坏客户。K-S值就是一个这样思路的指标。比如，在完成一个模型后，将测试模型的样本平均分成10组，以好样本占比降序从左到右进行排列，其中第一组的好样本占比最大，坏样本占比最小。这些组别的好坏样本占比进行累加后得到每一组对应的累计的占比。好坏样本的累计占比随着样本的累计而变化（图中Good/Bad两条曲线），而两者差异最大时就是我们要求的K-S值（图中比较长的直线箭头的那个位置）。</p><p>KS值的取值范围是[0，1]。通常来说，值越大，表明正负样本区分的程度越好。一般，KS值&gt;0.2就可认为模型有比较好的预测准确性。</p><p><img alt data-src="https://pic4.zhimg.com/80/v2-a74c5977f9a7ece1620b8d602300f853_hd.jpg"></p><h5 id="GINI系数"><a href="#GINI系数" class="headerlink" title="GINI系数"></a>GINI系数</h5><p>还记得经济学中那个著名的基尼系数吗？下图应该可以让你回忆起来。将一个国家所有的人口按最贫穷到最富有进行排列，随着人数的累计，这些人口所拥有的财富的比例也逐渐增加到100%，按这个方法得到图中的曲线，称为洛伦兹曲线。基尼系数就是图中A/B的比例。可以看到，假如这个国家最富有的那群人占据了越多的财富，贫富差距越大，那么洛伦茨曲线就会越弯曲，基尼系数就越大。</p><p>同样的，假设我们把100个人的信用评分按照从高到低进行排序，以横轴为累计人数比例，纵轴作为累计坏样本比例，随着累计人数比例的上升，累计坏样本的比例也在上升。如果这个评分的区分能力比较好，那么越大比例的坏样本会集中在越低的分数区间，整个图像形成一个凹下去的形状。所以洛伦兹曲线的弧度越大，基尼系数越大，这个模型区分好坏样本的能力就越强。</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-2a5e9400b1bef939a71158a4dc397380_hd.jpg"></p><h4 id="稳定性指标"><a href="#稳定性指标" class="headerlink" title="稳定性指标"></a>稳定性指标</h4><p>用于评估模型在训练样本和测试样本中预测能力的一致性，如PSI指标。</p><h5 id="PSI-Population-Stability-Index"><a href="#PSI-Population-Stability-Index" class="headerlink" title="PSI(Population Stability Index)"></a>PSI(Population Stability Index)</h5><p>PSI(Population Stability Index)叫做群体稳定性指标，用于衡量两组样本的评分是否有显著差异。PSI = sum(（实际占比-预期占比）*ln(实际占比/预期占比)</p><p>举个栗子，假设在训练一个评分模型时，我们将样本评分按从小到大排序分成10组，那么每组会有不同的样本数量占比P1；评分模型制作出来之后，我们试用这个模型去预测新的一组数据样本，按上面的方法同样按评分分成10组，每组也会有一定的样本数量占比P2。PSI可以帮助我们量化P1和P2，即预期占比与实际占比的差距。</p><p><strong>References</strong>:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/31229720" target="_blank" rel="noopener">这一次，真正搞懂信用评分模型（上篇）</a></li><li><a href="http://documentation.statsoft.com/portals/0/formula%20guide/Weight%20of%20Evidence%20Formula%20Guide.pdf" target="_blank" rel="noopener">http://documentation.statsoft.com/portals/0/formula%20guide/Weight%20of%20Evidence%20Formula%20Guide.pdf</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信用评分 </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】121. Best Time to Buy and Sell Stock</title>
      <link href="/LeetCode121-Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/LeetCode121-Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><figcaption><span>121.best-time-to-buy-and-sell-stock.cpp</span><a href="https://github.com/fuhailin/show-me-cpp-code/blob/master/LeetCode/121.best-time-to-buy-and-sell-stock.cpp" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><!-- <figure class="highlight cpp"><figcaption><span> hello world in c lang</span><a href="/downloads/code/hello_world.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure> --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]深度学习中Embedding层有什么用？</title>
      <link href="/Embedding/"/>
      <url>/Embedding/</url>
      
        <content type="html"><![CDATA[<p><em>这篇博客翻译自国外的深度学习系列文章的第四篇，想查看其他文章请点击下面的链接，人工翻译也是劳动，如果你觉得有用请打赏，转载请打赏:</em></p><a id="more"></a><ol><li><a href="https://medium.com/towards-data-science/deep-learning-1-1a7e7d9e3c07" target="_blank" rel="noopener">Setting up AWS &amp; Image Recognition</a></li><li><a href="https://medium.com/towards-data-science/deep-learning-2-f81ebe632d5c" target="_blank" rel="noopener">Convolutional Neural Networks</a></li><li><a href="https://medium.com/towards-data-science/deep-learning-3-more-on-cnns-handling-overfitting-2bd5d99abe5d" target="_blank" rel="noopener">More on CNNs &amp; Handling Overfitting</a></li></ol><hr><p>在深度学习实验中经常会遇Eembedding层,然而网络上的介绍可谓是相当含糊。比如 Keras中文文档中对嵌入层 Embedding的介绍除了一句 “<em>嵌入层将正整数（下标）转换为具有固定大小的向量</em>”之外就不愿做过多的解释。那么我们为什么要使用嵌入层 Embedding呢? 主要有这两大原因:</p><ol><li><p>使用One-hot 方法编码的向量会很高维也很稀疏。假设我们在做自然语言处理（NLP）中遇到了一个包含2000个词的字典，当使用One-hot编码时，每一个词会被一个包含2000个整数的向量来表示，其中1999个数字是0，要是我的字典再大一点的话这种方法的计算效率岂不是大打折扣？</p></li><li><p>训练神经网络的过程中，每个嵌入的向量都会得到更新。如果你看到了博客上面的图片你就会发现在多维空间中词与词之间有多少相似性，这使我们能可视化的了解词语之间的关系，不仅仅是词语，任何能通过嵌入层 Embedding 转换成向量的内容都可以这样做。</p></li></ol><p>上面说的概念可能还有点含糊. 那我们就举个栗子看看嵌入层 Embedding 对下面的句子做了什么：）。Embedding的概念来自于word embeddings，如果您有兴趣阅读更多内容，可以查询 <a href="https://arxiv.org/pdf/1301.3781.pdf" target="_blank" rel="noopener">word2vec</a> 。</p><blockquote><p>“deep learning is very deep”</p></blockquote><p>使用嵌入层embedding 的第一步是通过索引对该句子进行编码，这里我们给每一个不同的句子分配一个索引，上面的句子就会变成这样：</p><blockquote><p>1 2 3 4 1</p></blockquote><p>接下来会创建嵌入矩阵，我们要决定每一个索引需要分配多少个‘潜在因子’，这大体上意味着我们想要多长的向量，通常使用的情况是长度分配为32和50。在这篇博客中，为了保持文章可读性这里为每个索引指定6个潜在因子。嵌入矩阵就会变成这样：</p><p><img alt="Embedding Matrix" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/1_Di85w_0UTc6C3ilk5_LEgg.png"></p><p>这样，我们就可以使用嵌入矩阵来而不是庞大的one-hot编码向量来保持每个向量更小。简而言之，嵌入层embedding在这里做的就是把单词“deep”用向量[.32,&nbsp;.02,&nbsp;.48,&nbsp;.21,&nbsp;.56,&nbsp;.15]来表达。然而并不是每一个单词都会被一个向量来代替，而是被替换为用于查找嵌入矩阵中向量的索引。其次这种方法面对大数据时也可有效计算。由于在深度神经网络的训练过程中嵌入向量也会被更新，我们就可以探索在高维空间中哪些词语之间具有彼此相似性，再通过使用<a href="https://lvdmaaten.github.io/tsne/" target="_blank" rel="noopener">t-SNE </a>这样的降维技术就可以将这些相似性可视化。</p><p><img width="50%" height="50%" title="t-SNE visualization of word embeddings" alt="t-SNE visualization of word embeddings" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/1_m8Ahpl-lpVgm16CC-INGuw.png"></p><hr><h3 id="Not-Just-Word-Embeddings"><a href="#Not-Just-Word-Embeddings" class="headerlink" title="Not Just Word Embeddings"></a>Not Just Word Embeddings</h3><p>These previous examples showed that word embeddings are very important in the world of Natural Language Processing. They allow us to capture relationships in language that are very difficult to capture otherwise. However, embedding layers can be used to embed many more things than just words. In my current research project I am using embedding layers to embed online user behavior. In this case I am assigning indices to user behavior like ‘page view on page type X on portal Y’ or ‘scrolled X pixels’. These indices are then used for constructing a sequence of user behavior.</p><p>In a comparison of ‘traditional’ machine learning models (SVM, Random Forest, Gradient Boosted Trees) with deep learning models (deep neural networks, recurrent neural networks) I found that this embedding approach worked very well for deep neural networks.</p><p>The ‘traditional’ machine learning models rely on a tabular input that is feature engineered. This means that we, as researchers, decide what gets turned into a feature. In these cases features could be: amount of homepages visited, amount of searches done, total amount of pixels scrolled. However, it is very difficult to capture the spatial (time) dimension when doing feature-engineering. By using deep learning and embedding layers we can efficiently capture this spatial dimension by supplying a sequence of user behavior (as indices) as input for the model.</p><p>In my research the Recurrent Neural Network with Gated Recurrent Unit/Long-Short Term Memory performed best. The results were very close. From the ‘traditional’ feature engineered models Gradient Boosted Trees performed best. I will write a blog post about this research in more detail in the future. I think my next blog post will explore Recurrent Neural Networks in more detail.</p><p>Other research has explored the use of embedding layers to encode student behavior in MOOCs (Piech et al., 2016) and users’ path through an online fashion store (Tamhane et al., 2017).</p><hr><h4 id="Recommender-Systems"><a href="#Recommender-Systems" class="headerlink" title="Recommender Systems"></a>Recommender Systems</h4><p>Embedding layers can even be used to deal with the sparse matrix problem in recommender systems. Since the deep learning course (fast.ai) uses recommender systems to introduce embedding layers I want to explore them here as well.</p><p>Recommender systems are being used everywhere and you are probably being influenced by them every day. The most common examples are Amazon’s product recommendation and Netflix’s program recommendation systems. Netflix actually held a $1,000,000 challenge to find the best collaborative filtering algorithm for their recommender system. You can see a visualization of one of these models <a href="http://abeautifulwww.com/wp-content/uploads/2007/04/netflixAllMovies-blackBack3[5].jpg" target="_blank" rel="noopener">here</a>.</p><p>There are two main types of recommender systems and it is important to distinguish between the two.</p><ol><li>Content-based filtering. This type of filtering is based on data about the item/product. For example, we have our users fill out a survey on what movies they like. If they say that they like sci-fi movies we recommend them sci-fi movies. In this case al lot of meta-information has to be available for all items.</li><li>Collaborative filtering: Let’s find other people like you, see what they liked and assume you like the same things. People like you = people who rated movies that you watched in a similar way. In a large dataset this has proven to work a lot better than the meta-data approach. Essentially asking people about their behavior is less good compared to looking at their actual behavior. Discussing this further is something for the psychologists among us.</li></ol><p>In order to solve this problem we can create a huge matrix of the ratings of all users against all movies. However, in many cases this will create an extremely sparse matrix. Just think of your Netflix account. What percentage of their total supply of series and movies have you watched? It’s probably a pretty small percentage. Then, through gradient descent we can train a neural network to predict how high each user would rate each movie. Let me know if you would like to know more about the use of deep learning in recommender systems and we can explore it further together. In conclusion, embedding layers are amazing and should not be overlooked.</p><p>If you liked this posts be sure to recommend it so others can see it. You can also follow this profile to keep up with my process in the Fast AI course. See you there!</p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>Piech, C., Bassen, J., Huang, J., Ganguli, S., Sahami, M., Guibas, L. J., &amp; Sohl-Dickstein, J. (2015). <em>Deep knowledge tracing. In Advances in Neural Information Processing Systems</em> (pp. 505–513).</p><p>Tamhane, A., Arora, S., &amp; Warrier, D. (2017, May). <em>Modeling Contextual Changes in User Behaviour in Fashion e-Commerce</em>. In Pacific-Asia Conference on Knowledge Discovery and Data Mining (pp. 539–550). Springer, Cham.</p><h4 id="Embedding-layers-in-keras"><a href="#Embedding-layers-in-keras" class="headerlink" title="Embedding layers in keras"></a>Embedding layers in keras</h4><p>嵌入层embedding用在网络的开始层将你的输入转换成向量，所以当使用 Embedding前应首先判断你的数据是否有必要转换成向量。如果你有categorical数据或者数据仅仅包含整数（像一个字典一样具有固定的数量）你可以尝试下Embedding 层。<br>如果你的数据是多维的你可以对每个输入共享嵌入层或尝试单独的嵌入层。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers.embeddings import Embedding</span><br><span class="line"></span><br><span class="line">Embedding(input_dim, output_dim, embeddings_initializer='uniform', embeddings_regularizer=None, activity_regularizer=None, embeddings_constraint=None, mask_zero=False, input_length=None)</span><br></pre></td></tr></tbody></table></figure><p>-The first value of the Embedding constructor is the range of values in the input. In the example it’s 2 because we give a binary vector as input.</p><ul><li>The second value is the target dimension.</li><li>The third is the length of the vectors we give.<ul><li>input_dim: int &gt;= 0. Size of the vocabulary, ie. 1+maximum integer<br>index occuring in the input data.</li></ul></li></ul><p>本文译自：<a href="https://medium.com/towards-data-science/deep-learning-4-embedding-layers-f9a02d55ac12" target="_blank" rel="noopener">https://medium.com/towards-data-science/deep-learning-4-embedding-layers-f9a02d55ac12</a></p><p>How does embedding work? An example demonstrates best what is going on.</p><p>Assume you have a sparse vector [0,1,0,1,1,0,0] of dimension seven. You can turn it into a non-sparse 2d vector like so:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(2, 2, input_length=7))</span><br><span class="line">model.compile('rmsprop', 'mse')</span><br><span class="line">model.predict(np.array([[0,1,0,1,1,0,0]]))</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array([[[ 0.03005414, -0.02224021],</span><br><span class="line">        [ 0.03396987, -0.00576888],</span><br><span class="line">        [ 0.03005414, -0.02224021],</span><br><span class="line">        [ 0.03396987, -0.00576888],</span><br><span class="line">        [ 0.03396987, -0.00576888],</span><br><span class="line">        [ 0.03005414, -0.02224021],</span><br><span class="line">        [ 0.03005414, -0.02224021]]], dtype=float32)</span><br></pre></td></tr></tbody></table></figure><p>Where do these numbers come from? It’s a simple map from the given range to a 2d space:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.layers[0].W.get_value()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[ 0.03005414, -0.02224021],</span><br><span class="line">       [ 0.03396987, -0.00576888]], dtype=float32)</span><br></pre></td></tr></tbody></table></figure><p>The 0-value is mapped to the first index and the 1-value to the second as can be seen by comparing the two arrays. The first value of the Embedding constructor is the range of values in the input. In the example it’s 2 because we give a binary vector as input. The second value is the target dimension. The third is the length of the vectors we give.<br>So, there is nothing magical in this, merely a mapping from integers to floats.</p><p>Now back to our ‘shining’ detection. The training data looks like a sequences of bits:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array([[ 0.,  1.,  1.,  1.,  0.,  1.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,</span><br><span class="line">         1.,  0.,  0.,  0.,  0.,  0.],</span><br><span class="line">       [ 0.,  1.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,</span><br><span class="line">         0.,  0.,  0.,  0.,  0.,  0.],</span><br><span class="line">       [ 0.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,</span><br><span class="line">         0.,  0.,  1.,  0.,  1.,  0.],</span><br><span class="line">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,</span><br><span class="line">         0.,  1.,  0.,  1.,  0.,  0.],</span><br><span class="line">       [ 0.,  0.,  0.,  0.,  0.,  0.,  1.,  0.,  1.,  0.,  1.,  0.,  0.,</span><br><span class="line">         0.,  0.,  0.,  0.,  0.,  1.]])</span><br></pre></td></tr></tbody></table></figure><p>If you want to use the embedding it means that the output of the embedding layer will have dimension (5, 19, 10). This works well with LSTM or GRU (see below) but if you want a binary classifier you need to flatten this to (5, 19*10):</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(3, 10, input_length= X.shape[1] ))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(1, activation='sigmoid'))</span><br><span class="line">model.compile(loss='binary_crossentropy', optimizer='rmsprop')</span><br><span class="line">model.fit(X, y=y, batch_size=200, nb_epoch=700, verbose=0, validation_split=0.2, show_accuracy=True, shuffle=True)</span><br></pre></td></tr></tbody></table></figure><p>It detects ‘shining’ flawlessly:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.predict(X)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[  1.00000000e+00],</span><br><span class="line">       [  8.39483363e-08],</span><br><span class="line">       [  9.71878720e-08],</span><br><span class="line">       [  7.35597965e-08],</span><br><span class="line">       [  9.91844118e-01]], dtype=float32)</span><br></pre></td></tr></tbody></table></figure><p>An LSTM layer has historical memory and so the dimension outputted by the embedding works in this case, no need to flatten things:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line">model.add(Embedding(vocab_size, 10))</span><br><span class="line">model.add(LSTM(5))</span><br><span class="line">model.add(Dense(1, activation='sigmoid'))</span><br><span class="line">model.compile(loss='binary_crossentropy', optimizer='rmsprop')</span><br><span class="line">model.fit(X, y=y,  nb_epoch=500, verbose=0, validation_split=0.2, show_accuracy=True, shuffle=True)</span><br></pre></td></tr></tbody></table></figure><p>Obviously, it predicts things as well:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.predict(X)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[ 0.96855599],</span><br><span class="line">       [ 0.01917232],</span><br><span class="line">       [ 0.01917362],</span><br><span class="line">       [ 0.01917258],</span><br><span class="line">       [ 0.02341695]], dtype=float32)</span><br></pre></td></tr></tbody></table></figure><p>本文译自：<a href="http://www.orbifold.net/default/2017/01/10/embedding-and-tokenizer-in-keras/" target="_blank" rel="noopener">http://www.orbifold.net/default/2017/01/10/embedding-and-tokenizer-in-keras/</a></p><p>万物皆Embedding，从经典的word2vec到深度学习基本操作item2vec: <a href="https://zhuanlan.zhihu.com/p/53194407?utm_source=qq&amp;utm_medium=social&amp;utm_oi=1066622868011413504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53194407?utm_source=qq&amp;utm_medium=social&amp;utm_oi=1066622868011413504</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Embedding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读过的书</title>
      <link href="/Books-read/"/>
      <url>/Books-read/</url>
      
        <content type="html"><![CDATA[<p>记录自己读过的对提升自己有帮助的书，对学习也好，生活也好，更好的理解这个世界:)<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png?v8">📚</span></p><ul><li>[x] Finish my changes</li><li>[ ] Push my commits to GitHub</li><li>[ ] Open a pull request</li></ul><a id="more"></a><p>2018.11-12</p><ul><li>[x] 《浪潮之巅》           <iframe src="https://drive.google.com/file/d/1rh7O20BthBYAfJ27PjNhc8ilnlENxYNv/preview" width="50%" height="30%"></iframe></li></ul><p><strong>推荐指数</strong>：<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><br><strong>书评</strong>：历史课本for了解计算机、互联网的发展过程</p><hr><ul><li>[ ] 《统计学习方法》        <iframe src="https://drive.google.com/file/d/1Q3sQfhkiiOedy0X4N3RazszUQe94h5BT/preview" width="50%" height="30%"></iframe></li></ul><p><strong>推荐指数</strong>：<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><br><strong>书评</strong>：数据挖掘必读课本</p><hr><ul><li>[ ] 《机器学习》          <iframe src="https://drive.google.com/file/d/1SzmwFZXK3Urgozh8XNEQR7hFdKOfIw52/preview" width="50%" height="30%"></iframe></li></ul><p><strong>推荐指数</strong>：<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><br><strong>书评</strong>：机器学习入门必读课本</p><hr><ul><li>[ ] 《美团机器学习实践》</li><li>[ ] 《编程之美》</li><li>[ ] 《剑指offer》</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公司上市可以实现财富自由？什么是期权、股票</title>
      <link href="/Stock-Option/"/>
      <url>/Stock-Option/</url>
      
        <content type="html"><![CDATA[<p>今天程序员圈流传着一篇新闻，<a href="https://www.jiemian.com/article/2703824.html" target="_blank" rel="noopener">25倍稀释股权，蘑菇街员工“财富自由梦”破灭</a>，里面提到的很多概念我不是很清楚，什么是期权、股票？为什么很多人通过公司上市后实现财富自由？为什么蘑菇街这位员工的期权对应的股票被稀释了25倍？首先我们需要理清楚这些资本概念。</p><a id="more"></a><h1 id="一个新兴科技公司-Startups-的诞生过程"><a href="#一个新兴科技公司-Startups-的诞生过程" class="headerlink" title="一个新兴科技公司(Startups)的诞生过程"></a>一个新兴科技公司(Startups)的诞生过程</h1><p>在美国，一个新兴的科技公司（Startups）的创业过程通常是这样的：来自思科公司的工程师山姆和IBM公司的工程师强尼发明了一种无线通信的技术，当然这种技术和他们所在公司的核心业务无关，两人觉得这种技术很有商业前景，他们就写了个专利草案，又花五千美元找了个专利律师，向美国专利局递交了专利申请（关键之一，知识产权很重要）。两个人下班后以及周末的所有时间全泡在山姆家的车库里用模拟软件 Matlab 进行模拟，证明这种技术可以将无线通信速度提高五十倍（关键之二，是否有数量级的提高是衡量一项新技术是革命性的还是革新性的关键。）两个人想了好几种应用，比如代替现有的计算机WiFi，或者用到手机上，于是在原有的专利上又添加了两个补充性专利。强尼和山姆于是拿着自己做的 Powerpoint 投影胶片、实验结果和专利申请材料到处找投资者，在碰了七八次壁以后，找到了山姆原来的老板，思科早期雇员亚平。亚平从思科发了</p><h2 id="风险投资（Venture-Capital-Investment，or-VC）"><a href="#风险投资（Venture-Capital-Investment，or-VC）" class="headerlink" title="风险投资（Venture Capital Investment，or VC）"></a>风险投资（Venture Capital Investment，or VC）</h2><p>债券(Bonds)<br>对冲基金(Hedge Funds)<br>天使投资(Angel Investment)</p><p><strong>References</strong>:</p><ol><li><a href="https://www.jiemian.com/article/2703824.html" target="_blank" rel="noopener">25倍稀释股权，蘑菇街员工“财富自由梦”破灭</a></li><li><a href="https://xueqiu.com/8680422520/24094156" target="_blank" rel="noopener">你手里期权值多少钱？写给上市公司的同学</a></li><li><a href="https://www.investopedia.com/university/options/" target="_blank" rel="noopener">Options Basics: What Are Options? | Investopedia</a></li><li><a href="https://news.newseed.cn/p/1320449" target="_blank" rel="noopener">创业公司大都给期权，然而员工到手的期权并没有什么卵用？</a></li><li><a href="https://blog.coding.net/blog/options" target="_blank" rel="noopener">期权都是废纸？——创业公司的期权、股票与回报</a></li><li><a href="https://www.investopedia.com/ask/answers/06/adshares.asp" target="_blank" rel="noopener">Does a Company’s American Depositary Share Equal One Share of Common Stock?</a></li><li><a href="https://www.zhihu.com/question/19988574" target="_blank" rel="noopener">公司为什么要融资上市？</a></li><li><a href="http://column.iresearch.cn/b/201703/795031.shtml" target="_blank" rel="noopener">扫雷丨3张图秒懂创业公司股权、期权、股权代持里的那些坑！</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 股票 </tag>
            
            <tag> 期权 </tag>
            
            <tag> 金融 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL有多少种join方式</title>
      <link href="/SQL-Join/"/>
      <url>/SQL-Join/</url>
      
        <content type="html"><![CDATA[<p>SQL JOIN 用于把来自两个或多个表的数据或行基于它们的公共字段结合起来。有四种不同的JOIN方式:</p><ul><li>INNER JOIN</li><li>LEFT JOIN</li><li>RIGHT JOIN</li><li>FULL JOIN</li></ul><a id="more"></a><p>在这里<a href="https://www.liaoxuefeng.com/wiki/001508284671805d39d23243d884b8b99f440bfae87b0f4000/001509167363938072fc3ae9c454397bbd791fd88b7d92d000" target="_blank" rel="noopener">在线SQL</a>网页里面有两张表，<code>students</code>表</p><div class="table-container"><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr><tr><td>4</td><td>1</td><td>小米</td><td>F</td><td>73</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>F</td><td>81</td></tr><tr><td>6</td><td>2</td><td>小兵</td><td>M</td><td>55</td></tr><tr><td>7</td><td>2</td><td>小林</td><td>M</td><td>85</td></tr><tr><td>8</td><td>3</td><td>小新</td><td>F</td><td>91</td></tr><tr><td>9</td><td>3</td><td>小王</td><td>M</td><td>89</td></tr><tr><td>10</td><td>3</td><td>小丽</td><td>F</td><td>88</td></tr></tbody></table></div><p>和<code>classes</code>表</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr><tr><td>3</td><td>三班</td></tr><tr><td>4</td><td>四班</td></tr></tbody></table></div><h1 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h1><p>返回两个表的交集部分</p><p><img alt="INNER JOIN" data-src="http://www.vertabelo.com/_file/blog/sql-joins/sql-joins-venn-diagrams-inner-join.png"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes <span class="keyword">ON</span> students.id=classes.id</span><br></pre></td></tr></tbody></table></figure><div class="table-container"><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td><td>1</td><td>一班</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td><td>2</td><td>二班</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td><td>3</td><td>三班</td></tr><tr><td>4</td><td>1</td><td>小米</td><td>F</td><td>73</td><td>4</td><td>四班</td></tr></tbody></table></div><h1 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h1><p>把右表的部分追加到左表的后面，没有的那些字段值置为<code>NULL</code><br><img alt="LEFT JOIN" data-src="https://i.stack.imgur.com/VkAT5.png"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> classes <span class="keyword">ON</span> students.id=classes.id</span><br></pre></td></tr></tbody></table></figure><div class="table-container"><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td><td>1</td><td>一班</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td><td>2</td><td>二班</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td><td>3</td><td>三班</td></tr><tr><td>4</td><td>1</td><td>小米</td><td>F</td><td>73</td><td>4</td><td>四班</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>F</td><td>81</td><td>NULL</td><td>NULL</td></tr><tr><td>6</td><td>2</td><td>小兵</td><td>M</td><td>55</td><td>NULL</td><td>NULL</td></tr><tr><td>7</td><td>2</td><td>小林</td><td>M</td><td>85</td><td>NULL</td><td>NULL</td></tr><tr><td>8</td><td>3</td><td>小新</td><td>F</td><td>91</td><td>NULL</td><td>NULL</td></tr><tr><td>9</td><td>3</td><td>小王</td><td>M</td><td>89</td><td>NULL</td><td>NULL</td></tr><tr><td>10</td><td>3</td><td>小丽</td><td>F</td><td>88</td><td>NULL</td><td>NULL</td></tr></tbody></table></div><h1 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h1><p>把左表的部分追加到右表的后面，没有的那些字段值置为<code>NULL</code></p><p><img alt="RIGHT JOIN" data-src="http://www.databasejournal.com/img/jk_JustSQL4_image004.jpg"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> classes <span class="keyword">ON</span> students.id=classes.id</span><br></pre></td></tr></tbody></table></figure><div class="table-container"><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td><td>1</td><td>一班</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td><td>2</td><td>二班</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td><td>3</td><td>三班</td></tr><tr><td>4</td><td>1</td><td>小米</td><td>F</td><td>73</td><td>4</td><td>四班</td></tr></tbody></table></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM classes OUTER JOIN students ON students.id=classes.id</span><br></pre></td></tr></tbody></table></figure><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>一班</td><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>二班</td><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>三班</td><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr><tr><td>4</td><td>四班</td><td>4</td><td>1</td><td>小米</td><td>F</td><td>73</td></tr><tr><td>NULL</td><td>NULL</td><td>5</td><td>2</td><td>小白</td><td>F</td><td>81</td></tr><tr><td>NULL</td><td>NULL</td><td>6</td><td>2</td><td>小兵</td><td>M</td><td>55</td></tr><tr><td>NULL</td><td>NULL</td><td>7</td><td>2</td><td>小林</td><td>M</td><td>85</td></tr><tr><td>NULL</td><td>NULL</td><td>8</td><td>3</td><td>小新</td><td>F</td><td>91</td></tr><tr><td>NULL</td><td>NULL</td><td>9</td><td>3</td><td>小王</td><td>M</td><td>89</td></tr><tr><td>NULL</td><td>NULL</td><td>10</td><td>3</td><td>小丽</td><td>F</td><td>88</td></tr></tbody></table></div><h1 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h1><p>只要其中一个表中存在匹配，则返回行，没有的那些字段值置为<code>NULL</code>。相当于返回两个表的交集</p><p><img alt="OUTER JOIN" data-src="https://i.stack.imgur.com/3Ll1h.png"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes <span class="keyword">ON</span> students.id=classes.id</span><br></pre></td></tr></tbody></table></figure><div class="table-container"><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td><td>1</td><td>一班</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td><td>2</td><td>二班</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td><td>3</td><td>三班</td></tr><tr><td>4</td><td>1</td><td>小米</td><td>F</td><td>73</td><td>4</td><td>四班</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>F</td><td>81</td><td>NULL</td><td>NULL</td></tr><tr><td>6</td><td>2</td><td>小兵</td><td>M</td><td>55</td><td>NULL</td><td>NULL</td></tr><tr><td>7</td><td>2</td><td>小林</td><td>M</td><td>85</td><td>NULL</td><td>NULL</td></tr><tr><td>8</td><td>3</td><td>小新</td><td>F</td><td>91</td><td>NULL</td><td>NULL</td></tr><tr><td>9</td><td>3</td><td>小王</td><td>M</td><td>89</td><td>NULL</td><td>NULL</td></tr><tr><td>10</td><td>3</td><td>小丽</td><td>F</td><td>88</td><td>NULL</td><td>NULL</td></tr></tbody></table></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建博客进阶之SEO搜索引擎优化</title>
      <link href="/Hexo-SEO/"/>
      <url>/Hexo-SEO/</url>
      
        <content type="html"><![CDATA[<p>SEO (Search Engine Optimization)，即搜索引擎优化。简单来说，SEO就是您可以使用提升网站排名的所有方法的总称，SEO用于确保您的网站及其内容在搜索引擎结果页面（SERP）上的可见性。</p><a id="more"></a><!-- # 验证你的网站(让你博客被搜索引擎找到) --><p><strong>查看你的博客是否被收录</strong></p><p>在谷歌或者百度的搜索链接中，使用以下格式可以直接搜索自己的域名， 如果能搜索到就说明已经被收录，反之则没有。可以直接搜索自己的域名，或者加一些关键词来更好地判断，例如：<code>site: https://fuhailin.github.io/</code></p><p>若未被搜索引擎收录，则需进行以下配置，</p><h2 id="第一步：网站所有权验证"><a href="#第一步：网站所有权验证" class="headerlink" title="第一步：网站所有权验证"></a>第一步：网站所有权验证</h2><h3 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h3><p>首先要让搜索引擎先验证我们对网站的所有权，Google搜索引擎提交的入口为：<br><a href="https://search.google.com/search-console" target="_blank" rel="noopener">Google Search Console</a></p><p>验证你对该网站的所有权有多种方式，我这里使用的是<code>Hexo-&gt;Next</code>主题中提供的”google_analytics”验证方式</p><p>在<code>主题配置文件</code>中可以找到google_analytics字段，到<a href="https://analytics.google.com/analytics/web" target="_blank" rel="noopener">Google Analytics</a>中生成你自己的 google_analytics 代码，将这个代码粘贴到<code>主题配置文件</code>中 google_analytics 字段后面，像这样：</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20181212110446.png"></p><p>我的就已经验证成功了：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20181212105705.png"><br><!-- <img src="TIM20181212105705.png" width="50%" height="50%" title="所有权验证." alt=""/> --></p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>我这里选用的验证方式是通过文件验证：</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20181212140519.png"></p><p>将下载的文件<code>baidu_verify_evCLN0THH4.html</code>放置到<code>source</code>文件夹，然后重新编译博客<code>hexo g</code>，会发现刚刚添加的文件复制到了<code>themes/next/source</code>文件夹中，通过<code>hexo d</code>完成部署之后，可以通过域名访问刚刚的链接了：<a href="https://fuhailin.github.io/baidu_verify_DWdJWj7U7R.html">https://fuhailin.github.io/baidu_verify_DWdJWj7U7R.html</a> ，点击完成验证即可。</p><h2 id="第二步：添加站点地图"><a href="#第二步：添加站点地图" class="headerlink" title="第二步：添加站点地图"></a>第二步：添加站点地图</h2><h3 id="生成sitemap文件"><a href="#生成sitemap文件" class="headerlink" title="生成sitemap文件"></a>生成sitemap文件</h3><p>安装相关插件<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></tbody></table></figure><p></p><p>修改配置：修改<code>站点配置文件</code>_config.yml, 添加如下两段配置<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># hexo sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line"></span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></tbody></table></figure><p></p><p>然后重新编译你的博客：<code>hexo g</code>，看看在public文件夹里面是不是出现了<code>sitemap.xml</code>和<code>baidusitemap.xml</code>两个文件，你还可以本地访问 <a href="http://localhost:4000/sitemap.xml" target="_blank" rel="noopener">http://localhost:4000/sitemap.xml</a> 和 <a href="http://localhost:4000/baidusitemap.xml" target="_blank" rel="noopener">http://localhost:4000/baidusitemap.xml</a> 查看效果，说明配置成功。</p><h2 id="第三步：搜索引擎收录"><a href="#第三步：搜索引擎收录" class="headerlink" title="第三步：搜索引擎收录"></a>第三步：搜索引擎收录</h2><h3 id="Google-1"><a href="#Google-1" class="headerlink" title="Google"></a>Google</h3><p>谷歌操作比较简单，就是向<a href="https://search.google.com/search-console" target="_blank" rel="noopener">Google Search Console</a>提交sitemap：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/TIM20181212104327.png"></p><h3 id="百度-1"><a href="#百度-1" class="headerlink" title="百度"></a>百度</h3><p>百度收录很麻烦，效率比谷歌差远了。由于 GitHub 屏蔽了百度的爬虫，即使提交成功，百度知道这里有可供抓取的链接，也不一定能抓取成功。我们还需要设置自动推送。</p><p><strong>设置自动推送</strong><br>在主题配置文件下设置,将baidu_push设置为true：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span><br><span class="line">baidu_push: true</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="文章链接优化"><a href="#文章链接优化" class="headerlink" title="文章链接优化"></a>文章链接优化</h3><p>Hexo 默认的文章链接形式为 <code>domain/year/month/day/postname</code>，分级较多，造成 URL(Universal Resource Locator，统一资源定位符) 较长，不利于搜索引擎检索，我们可根据需要缩短 URL，将其改为 <code>domain/postname</code>的形式。编辑<strong>站点配置文件_config.yml</strong>, 将 permalink 字段改为 <code>permalink: :title/</code>。<br>tips:<br>如果仍想在 URL 中保留时间要素，比如将 URL 改为 <code>domain/year-month-day/postname</code> 的形式，也可将permalink字段改为 <code>permalink: :year-:month-:day/:title/</code></p><h3 id="添加蜘蛛协议robots-txt"><a href="#添加蜘蛛协议robots-txt" class="headerlink" title="添加蜘蛛协议robots.txt"></a>添加蜘蛛协议robots.txt</h3><blockquote><p>robots.txt（统一小写）是一种存放于网站根目录下的 ASCII 编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。</p></blockquote><p>在根目录 <strong>source</strong> 文件下新建 <strong>robots.txt</strong> 文件，添加以下文件内容（将 Sitemap 中的域名切换成自己网站域名）<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /tags/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /about/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://fuhailin.github.io/sitemap.xml</span><br><span class="line">Sitemap: https://fuhailin.github.io/baidusitemap.xml</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>参数说明： User-agent: * 允许所有 robot 访问，Allow 允许访问 X 目录，Disallow 禁止访问 X 目录</p></blockquote><p><strong>References</strong>:</p><ol><li><a href="http://www.yuan-ji.me/Hexo-%E4%BC%98%E5%8C%96%EF%BC%9A%E6%8F%90%E4%BA%A4sitemap%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96-GitHub-Pages-%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">Hexo 优化：提交 sitemap 及解决百度爬虫无法抓取 GitHub Pages 链接问题</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法工程师常见面经问题</title>
      <link href="/InterviewQuestion4ML/"/>
      <url>/InterviewQuestion4ML/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习基础题"><a href="#机器学习基础题" class="headerlink" title="机器学习基础题"></a>机器学习基础题</h1><ol><li><p>LSTM的公式</p></li><li><p>RNN为什么出现梯度消失及BPTT的推导</p></li><li><p>DQN的基本原理么</p></li><li><p>GBDT和随机森林有什么区别</p></li><li><p>GBDT的原理，如何做分类和回归</p></li><li><p>随机森林的随机体现在哪方面</p></li><li><p>Wide &amp;Deep的原理</p></li><li><p>GBDT+LR是怎么做的?</p></li><li><p>DQN模型为什么要做经验回放</p></li><li><p>数据之间如果不是独立同分布的会怎样</p></li><li><p>AUC的原理介绍一下</p></li><li><p>XGBOOst和GBDT的区别。</p></li><li><p>强化学习和监督学习的区别</p></li><li><p>神经网络里面的损失函数有哪些</p></li><li><p>机器学习中常见的激活函数有哪些？为什么通常需要零均值？</p></li><li><p>DeepFM介绍</p></li><li><p>FM推导</p></li><li><p>boosting和bagging的区别？</p></li><li><p>bagging为什么能减小方差？</p></li><li><p>交叉熵损失函数，0-1分类的交叉熵损失函数的形式。什么是凸函数？0-1分类为什么用交叉熵而不是平方损失？</p></li><li><p>L1和L2有什么区别，从数学角度解释L2为什么能提升模型的泛化能力。</p></li><li><p>深度学习中，L2和dropout有哪些区别？</p></li><li><p>L1正则化有哪些好处</p></li><li><p>如果有一万个地理坐标，转换成1-10000的数，可以用决策树么？</p></li><li><p>CART分类树和ID3以及C4.5有什么区别？</p></li><li><p>树集成模型有哪几种实现方式：Bagging和Boosting，随即森林的随机体现在哪些方面，AdaBoost是如何改变样本权重，GBDT分类树拟合的是什么？</p></li><li><p>Dueling DQN和DQN有什么区别</p></li><li><p>early stop对参数有什么影响？</p></li><li>梯度消失为什么会出现？如何解决？<ul><li>预训练加微调</li><li>梯度剪切、权重正则（针对梯度爆炸）</li><li>使用不同的激活函数(ReLU)</li><li>使用batchnorm</li><li>使用残差结构</li><li>使用LSTM网络</li></ul><ol><li>如何防止过拟合？</li></ol><ul><li>early stopping</li><li>数据集扩增（Data augmentation）</li><li>正则化（Regularization）</li><li>Dropout</li></ul></li></ol><h1 id="数据结构算法题"><a href="#数据结构算法题" class="headerlink" title="数据结构算法题"></a>数据结构算法题</h1><ol><li><p>K个有序数组，找一个长度最小的区间，在这个区间里至少包含每个数组各一个数</p></li><li><p>n个[0,n)的数，求每个数的出现次数（不能开辟额外空间）</p></li><li><p>数组的全排列（空间复杂度O（1））</p></li><li><p>一堆钞票，尽可能均分（利用背包问题的思想）</p></li><li><p>无向无环图中，最短路径的最大值（Floyd算法)</p></li><li><p>层次遍历二叉树</p></li><li><p>字符串的最长公共子序列（动态规划）</p></li><li><p>树的前序遍历和zigzag遍历（非递归）</p></li><li><p>一个数组，所有数组都出现了两次，只有一个数出现了一次，返回这个数（位运算）</p></li><li><p>一个数组，一个数出现了超过一半次数，返回这个数</p></li><li><p>将除法的结果用字符串返回，如果能够除尽，则返回相除的结果，如果不能除尽，则无限循环部分用[]标记。</p></li><li><p>数组排序，假设数组排序后的位次和排序前的位次绝对值差值小于K，有什么比快排好的算法？</p></li><li><p>树中两个节点的第一个的公共祖先。</p></li><li><p>判断是否是回文链表</p></li><li><p>判断两个链表中是否有相同节点</p></li><li>堆和栈的介绍以及它们之间有什么区别？</li></ol><h1 id="编程语言题"><a href="#编程语言题" class="headerlink" title="编程语言题"></a>编程语言题</h1><p>介绍一下构造函数，析构函数，函数重载(面向对象这一块的知识)</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ol><li>Python的匿名函数是什么吗？简单介绍一下并且举一个例子说明一下。</li><li>Python中一个*和两个**有什么区别？</li></ol><h1 id="实践题"><a href="#实践题" class="headerlink" title="实践题"></a>实践题</h1><ol><li><p>如果你想往模型中加入一个特征，如何判定这个特征是否有效？</p></li><li><p>LR和FM的区别？FM需要进行交叉特征的选择么？如果在LR选了一部分特征做交叉之后，取得了比FM更好的效果，这是为什么？如果FM变成DeepFM之后，效果超过了LR，这又是为什么？</p></li><li><p>如果逻辑回归的所有样本的都是正样本， 那么它学出来的超平面是怎样的？</p></li><li><p>哪些场景下的分类问题不适用于交叉熵损失函数？</p></li><li><p>推荐系统中你认为最重要的环节是什么？</p></li><li><p>多臂老虎机中，有许多方法，比如e-greedy，timponson采样，UCB，这些方法都有哪些适用场景？</p></li><li><p>如何预测一家店分品类的销量</p></li><li><p>信息流采样，有n份数据，但是n的长度并不知道，设计一个采样算法，使得每份被选择的概率是相同的。</p></li><li><p>模型在线下评估和线上使用时，往往出现线上实际效果不如线下效果的情况，请分析可能的原因。</p></li></ol><p><strong>References</strong>:</p><ol><li><a href="https://www.nowcoder.com/discuss/111127" target="_blank" rel="noopener">tmdp|牛客网</a></li><li><a href="https://zhuanlan.zhihu.com/p/36801851" target="_blank" rel="noopener">2018校招算法岗面试题汇总</a></li><li><a href="https://github.com/zslomo/2019-Autumn-recruitment-experience" target="_blank" rel="noopener">【2019年秋招计算机类面经】</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&amp;mid=2247484291&amp;idx=1&amp;sn=997a5bdafb400e91ff3726b42bea8782&amp;chksm=e9d01342dea79a54d9b13bc3912887c396444f0d707cc4369c63fede6a9ad178e2e448cc6a09&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">我在美团的这两年，想和你分享</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十分钟教你看懂中国房地产经济(一篇十一年前的文章依然适用于今天的贸易战)</title>
      <link href="/TradeWar-ChineseProperty/"/>
      <url>/TradeWar-ChineseProperty/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是经济发展？"><a href="#什么是经济发展？" class="headerlink" title="什么是经济发展？"></a>什么是经济发展？</h1><p>　　　　简单的讲经济发展就是有钱，但钱从何来？钱只能印出来。那么到底是什么使印钞机不停的运转？<br>　　　　假设一个岛上有1000口人，与世隔绝，人与人之间交换物品过活，但有时候你手里用来交换的东西不一定就是对方想要的，怎么办？于是人们就用都喜欢的金银作为交换的东西，于是交换方便了。但金银要磨损，携带也不方便，当交换活动频繁时，发现这个东西太繁琐，限制了交换活动，于是为了解决这个问题，想了一个办法，就是由岛上的管理者发行一种符号，用它来代替金银，于是钞票出现了。<br>　　　　刚开始这种钞票可以随时得兑换金银。大家都很放心，因为钞票就是金银。可是岛上金银的产量太小，当人们的交换活动更加频繁时，钞票不够用了，只能暂停交换。暂停交换的后果就是大家不生产别人想要的东西了，因为虽然别人用，但交换不出去，套用现在的话说就是经济发展减速了。<br>　　　　于是大家想了一个办法，成立一家钱庄，这个钱庄是大家的，由钱庄来发行钞票，印出的钞票借给想用钱的人，然后这个人有钱了再还给钱庄。于是银行就出现了。<br>　　　　银行的出现，能保证交换活动更持续的进行，大家都拼命的生产，岛上的东西越来越多，银行根据产品的生产数量，不停的印制钞票，以保证交换能更深入的进行。<br>　　后来人们的交换活动更频繁了，一家钱庄太少了，于是出现了很多钱庄，总要有个管钱庄的吧，于是指定一家钱庄管理其他钱庄，并且钞票只能由这家钱庄印刷，然后通过其他钱庄借给用钱的人，中央银行就这么也出现了。　　　　　　　　</p><h1 id="什么是对外贸易？"><a href="#什么是对外贸易？" class="headerlink" title="什么是对外贸易？"></a>什么是对外贸易？</h1><p>　　　　有一天岛上的人发明了船，于是就到处划船跑，发现了另一个岛屿，那上面也有人，也有钞票，也像自己岛上这么活动。但自己岛上生产的东西多，那个岛上生产的东西少，1元钱在自己的岛上能买1斤大米，那个岛上的一元钱只能买半斤大米，于是另外岛上的钱来这个岛上买东西时只能2元换1元才行。于是汇率出现了。算好汇率后，他们开始互相买卖东西到对方岛上，这就是对外贸易。对外贸易丰富了人们的生活生产需要，使交换活动到了一个空前的高潮。　　</p><h1 id="什么是通货膨胀？"><a href="#什么是通货膨胀？" class="headerlink" title="什么是通货膨胀？"></a>什么是通货膨胀？</h1><p>　　　　由于岛上生产的产品太多了，以至于没法准确估计到底该发行多少钞票，发行多了的时候，因为没有那么多产品可买，产品就开始涨价，发行少了呢就开始降价，为了保证价格稳定，央行要求各钱庄要把一部分钱放在央行里面用来调节产品的价格，根据价格情况多放和少放。这就是存款准备金率。<br>　　　　可是有一部分聪明人开始怎么才能把钱弄到自己手上，他在海边捡了一颗石子，说这个石子值100万快钱，把它卖给了一个人，这个人觉得整个岛上的钱加一起也没有100万啊，怎么办，于是向钱庄借，钱庄也没有这么多钱，于是把印钞机打开，印了这100万，借给了他买了这个石子。<br>　　　　然后这个人开始卖这个石子，100万卖给了第二个人，由于第一个卖石子的人把钱花了，所以岛上的钱多了，所以这一百万可以筹集到，多买些产品就有了。但当把这个石子以200万转让的时候，钱庄只能又印了100万钞票，就这样钞票越印越多，可是当这个石子不停的流动转让时，大家并不觉得岛上的钱多，产品价格还是原来的那样。可是当这个石子不流通或流通的慢时，大家觉得钱多了，可是如果当持有石子的人把它扔到大海里，那就等于岛上凭空多出N多个100 万来，怎么办，央行最害怕的就是这颗石子没了。它没了岛上产品的价格就会飞涨，就会通货膨胀。那么持有石子的人就绑架了岛上的经济。</p><h1 id="房价能绑架中国经济吗？"><a href="#房价能绑架中国经济吗？" class="headerlink" title="房价能绑架中国经济吗？"></a>房价能绑架中国经济吗？</h1><p>　　　　中国的房地产已经使中国央行发行了太多的人民币，如果房价下降，等于把那颗石子投进了海里，那么多印出来的钱会使中国产品价格飞涨，会发生严重的通货膨胀。<br>　　　　看似房价与石子毫无相干，可是他们的属性是一样的，就是价格和价值严重的背离。实际上房地产的崩盘受害最大的并不是中国的商业银行，而是整个中国经济体系。为什么政府迟迟没有把房价降下来，不是降不下来，如果真想降房价，只需要一道政令，房地产价格会在一夜之间土崩瓦解。可是后果谁能承担，严重通货膨胀谁来负责？<br>　　　　房地产业已经绑架了中国的经济，是无可置疑的，是客观实在的，没有人能改变。<br>　　　　不管谁是总理，廉洁也好，贪污也好，都希望社会和谐，可这是一个棘手的问题。</p><h1 id="房价和通货膨胀有关系吗？"><a href="#房价和通货膨胀有关系吗？" class="headerlink" title="房价和通货膨胀有关系吗？"></a>房价和通货膨胀有关系吗？</h1><p>　　　　可更棘手的问题还不仅仅在这里。如果降房价，面对的是马上的通货膨胀，可不降房价，那么面对的就是更严重的通货膨胀，何去何从？<br>　　　　所以最可靠的办法就是稳定房价，然后在社会产品增加时，减少货币的投放量，加上其他政策如加息、增加商业银行准备金率、缩小信贷规模等辅助手段，来使中国经济软着陆，这是最好的办法，我们看到的一切政令也是这个逻辑。不信的话，可以查阅一下近年来政府发布的一系列调控房地产业的措施。<br>　　　　可是为什么房价不稳定而且更加的疯长呢？难道是开发商与政府在博弈吗？告诉你在中国没有人能和党叫板，几个肚子大点的开发商是没有这个实力的。实际上是幕后的另一只黑手在和中国政府博弈，这支黑手就是外资，以美国为代表的帝国主义攫取中国人民血汗的黑手。　　　</p><h1 id="房价高涨的原动力是什么？"><a href="#房价高涨的原动力是什么？" class="headerlink" title="房价高涨的原动力是什么？"></a>房价高涨的原动力是什么？</h1><p>　　　　使房价上涨的动力很多，房价上涨对其有利的人就是动力之一，比如：为了GDP和个人利益的地方政府、为了赚钱的开发商、炒房族、以至于买了房的所谓“房奴”都是是房价上涨的动力，可是最大的原动力不是这些，是外资，是美国的以攫取超额利润的各大财团。<br>　　　　开发商作为商人，为了赚取高额利润不是什么伤天害理的事情，可是各行各业都有商人，难道想赚就有吗？那除非是神话。房地产业的开发商也一样，不是他们想赚多少就有多少的。根据价值规律，当商品的价格和价值严重背离时，会有一种趋向正常价格回归的力量钳制价格的上涨，可是在中国的房地产业，这种规律似乎不起作用，一个重要的原因是忽视了一个参考范围的原因，如果以中国经济本身而言确实打破了这个规律，可是目前的情况是有一股力量在维持着房地产业的价格，即托市，那么谁在托市呢？<br>　　　　谁能在房地产业失控能得到巨额利润的人就是托市的人。<br>　　　　讨论这个问题前，现看一下中国的外汇储备情况。中国的外汇储备在近几年迅速由1、2千亿突破万亿，并且还在迅速的增长，难道是中国人民奋发图强，挣来的吗？这个不需要证明，看中国的GDP增幅就知道，外汇储备的增长速度明显大于GDP的增幅。显然不是挣来的，那么除了挣来的一部分，那么就是所谓的 “国际热钱”的涌入，而国际热钱的涌入的目的只有一个，就是要取得高额的回报。<br>　　　　国际热钱进入中国市场后，首先要兑换成人民币，那么一下子哪有这么多人民币呢？只有一个办法就是让印钞机没日没夜的工作，然后这笔钱用来托住已是烫手山芋的房地产市场，就是拼命的投资房地产业，当房地产价格因背离价值而向下波动时，通过托市再把它抬高，反复如此，给人的表象就是房产价格决没有偏离价值。导致房价越涨越高。<br>　　　　而开发商呢，他们一到房子将要卖不出去的时候，就有人出高价买下来，他们怎么会降价，如果没有这部分资金在运作，别说是开发商联盟，就是全国只有一个开发商，价格也会降下来，没有人买了，难道等房子发霉吗？<br>　　　　那么外资持有这么多高价房产做什么？不怕砸到手里吗？<br>　　　　不怕！为什么呢？在这个资本运作的过程中，有一个冤大头在最底下接着呢，是谁呢？就是中国的商业银行，由于火爆的房地产市场，一流的流通性，近年来没有看到任何萎缩的迹象，放了贷款就盈利，为什么不贷款呢？没有理由不放贷款。<br>　　　　加之中国老百姓买房的心情，外资可以轻易的把高价房转嫁到中国的银行和消费者身上，连炒房的农民都能赚到一杯羹，职业的外资会赔钱吗？<br>　　　　那么房价一直涨下去，会怎样呢？请看下一节：“7、房价一直涨下去，开发商会笑还是会哭？什么情况下会笑？什么情况下会哭？” *</p><h1 id="房价一直涨下去，开发商会笑还是会哭？什么情况下会笑？什么情况下会哭？"><a href="#房价一直涨下去，开发商会笑还是会哭？什么情况下会笑？什么情况下会哭？" class="headerlink" title="房价一直涨下去，开发商会笑还是会哭？什么情况下会笑？什么情况下会哭？"></a>房价一直涨下去，开发商会笑还是会哭？什么情况下会笑？什么情况下会哭？</h1><p>　　　　在中国政府近几年来密集的几十道金牌的调控下，房价还是如脱了缰的野马一样狂奔不止。暂且不论何时能停止上涨的势头，毕竟房价在目前还是上涨的，所以我们就看看房价上涨不止会带来什么。<br>　　　　首先：由于GDP上涨，中国政府为了维持上文说的“保持产品交换的继续”要不断地投放人民币，即开动印钞机。只要房地产这个石子还没有投入到大海里去，还有一定的流通性，那么就不会有通货膨胀的发生。<br>　　　　其次：开发商会在这个过程中也赚取巨大的利润。<br>　　　　再次：能看到的是，炒房族会赚钱、所谓的买房的“房奴”会增值。<br>　　　　都赚钱！可是在这个过程中到底谁亏了呢？钱从哪里来呢？如果你是有炒股的经验就会知道，如果投资价格和价值背离的商品，你赚的钱就是别人赔的钱，那么套用到房地产上，就是买房自住的人，现在看似增值，那是镜中月、水中花，你不变现就不是你的。再有就是当价格完全回归真实价值的时候，有时甚至会到真实价值一下，被高价房套住的投资者。还有一个就是开发商！<br>　　　　为什么说开发商也有赔钱呢？大家知道商人的本性是赚钱，赚取利润。如果一个商人投机一次就永远都不做这个生意了，他是赚钱了，可他不是商人，这种商业行为没有意义。由于商人的本性，所以赚来的钱会继续扩大再生产，在能赚钱的领域不断的加大投资。这个道理从生活中就可看出来，越是做大生意的人总喊没钱，因为要更大的流动资金来维持其扩大再生产的需要。<br>　　　　所以一旦房价回归真实的价值之时，就是有一大批开发商崩溃之日。这个是不以任何人的意志和任何行为为转移的。如果现在有开发商逃离房地产业的角斗场，那么跑得慢的就是最后的输家。如果都不跑，就像击鼓传花一样，最后拿到接力棒的就是接盘者。有句话叫：“出来混迟早是要还的”。也许只不过是方式不一样，看谁的运气好而已。<br>　　　　可是现在却没有任何的开发商赔钱的迹象，有的是开发商不断的赚钱，老百姓送钱都来不及。只是因为目前房价还在上涨，房产还在不断的流动。<br>　　　　一个巨大的问题来了，这样不断上涨的房价何时是个头啊，请看下一节：“8、坐在华尔街办公室的财团们是如何吸干中国山区一个农民的血汗的”</p><h1 id="坐在华尔街办公室的财团们是如何吸干中国山区一个农民的血汗的"><a href="#坐在华尔街办公室的财团们是如何吸干中国山区一个农民的血汗的" class="headerlink" title="坐在华尔街办公室的财团们是如何吸干中国山区一个农民的血汗的"></a>坐在华尔街办公室的财团们是如何吸干中国山区一个农民的血汗的</h1><p>　　　　毛主席说过：“帝国主义没有睡大觉,而是天天在蠢蠢欲动,在图谋不轨,想达到他们的罪恶目的。诚然他们的气焰的确没有以前那么嚣张,但他们确实在活动着。”是不是冷战结束就代表着人类的和平得以实现呢？“一句上帝面前人人平等”就能掩盖帝国主义噬血的本质吗？人人平等的理念是对的，但它只不过是帝国主义用来欺骗人们的伎俩罢了，说到和做到永远是两码事。<br>　　　　国际财团通过国际热钱涌入中国，使人民币加大发行量，然后通过房地产炒作，把中国的国内价格水平无限制的提高，GDP的增长又一次使人民币的发行量被迫提高。国际财团心黑手狠，双管齐下，目的就是使中国经济热到烫手，热到让每个中国人为之疯狂。<br>　　　　我们暂不去关心这个过程，我们放眼未来，看看这一过程的结果是什么样呢？换句话说财团的目的是什么呢？<br>　　　　很明显，中国人最不愿意看到的事情，就是财团们最乐见的结果。先做个假设，比如国际热钱在投资的中国房地产领域里上演最后的疯狂后，然后把房产成功解套全部变现，如果此时人民币兑美元的汇率达到美国预期最高时，汇率是热钱逃离时需要相乘的那个倍数，会发生什么谁都能想到，所有热钱会一夜之间全部兑换美元逃离。财团们会赚得沟满壕平，中国市场上除了钱就是钱，能遮住天的大把人民币将成为中国人民的噩梦。<br>　　　　这是中国人最不愿意看到的事情，也是财团最乐见的结果。近期美国不断的通过政治、贸易等手段逼迫人民币升值，而中国政府迟迟不升值或小范围的升值，远远没有达到美国政府的预期，这是在出口处的中美之间的博弈。美国逼迫人民币升值的狼子野心昭然若揭！<br>　　　　顺便提一句，如果真的这个升值预期达到了，中国楼市将重演日本上世纪90年代崩盘的历史。只是那时中国经济也会像日本一样进入一个连续低迷不振的不归路。<br>　　　　在这种攸关民族生存的问题上，政府会坐视不管吗？就算是退一步来讲，一个完全不负责任的政府遇到这种情况，因为这个资本运作同时也极大侵犯了政府的利益，也会拼命反搏的。<br>　　　　那么中国政府会以什么样的方式来化解这一“经济危机”呢？请看下一节：“在有关这场围绕房价和通货膨胀之间的各方博弈中可能选择的中庸路线”。　　　　　　</p><h1 id="在有关这场围绕房价和通货膨胀之间的各方博弈中可能选择的中庸路线"><a href="#在有关这场围绕房价和通货膨胀之间的各方博弈中可能选择的中庸路线" class="headerlink" title="在有关这场围绕房价和通货膨胀之间的各方博弈中可能选择的中庸路线"></a>在有关这场围绕房价和通货膨胀之间的各方博弈中可能选择的中庸路线</h1><p>　　　　我一直相信：物极必反，中庸，是老祖宗留给后人解决棘手问题的杀手锏！<br>　　　　既然是中国房地产“绑架”了中国的经济，那么我们就从“绑架”说起。何为“绑架”，应该是相对弱的一方，拿着相对强的一方的“要害”，使相对强的一方即便有能力对付弱的一方，但碍于投鼠忌器，无力可施。<br>　　　　我们先来看看绑架双方的阵容和各自手上的筹码。房地产业的主体是开发商，所以开发商算一方，它绑架的要害是中国经济，那中国经济是谁的要害呢？是中国人民的要害，代表中国人民的，目前只能是中国政府。中国政府算一方。外资呢？它是煽风点火者，划到开发商一方。中国政府一方有公权力，可以通过税收、财政、经济政策、行政手段对开发商阵营施力，开发商阵营通过源源不断的后备资金来绑架中国经济，且不断的提高赎金。<br>　　　　问题已经摆在这里，怎么办呢？冲上去一枪击毙，那歹徒非撕票不可，太极端不可行。所以有为政府开出药方，只要实现了某某一条既可降低房价的主意，就犹如这一枪击毙一样是不可行的。我们想象如何解救绑架事件的，首先要稳定住对方的情绪，再一步步地靠近，但这种靠近虽会引起歹徒的敌意，但不会导致他撕票，然后再进一步稳定情绪，再靠近，然后条件成熟时，再稳准狠，即保证人质的安全，又要保证歹徒一举拿下。这才是真正的营救。<br>　　　　所以中庸才是解决棘手问题的杀手锏。极端、盲目、冒进是要不得的。<br>　　　　针对如何解决中国房地产市场的绑架问题，就要围绕问题的关键部分一步步地施加反作用力，然后一举成功，才是正道。<br>　　　　第一个关键的部分就是汇率，中国政府会严把汇率关，我们可以预期的是，人民币兑美元的汇率决不会过快升值，但会小幅升值，就是要稳定对方的情绪，如果一点不升，对方会狗急跳墙，如果升的过快，是给自己掘墓，所以为什么中国汇率升幅总是犹抱琵琶半遮面，看看美国政府的态度跟一个绑匪是多么的贴切，我要一瓶果汁，为什么拿来半瓶水。可又说不出什么来，毕竟还能暂时解渴。<br>　　　　第二个关键是限制资产流动性，既然房地产能绑架中国经济，说明它举足轻重，限制房产的流通性，就可以限制资产的流动性，注意这里是两个概念，“资产流动性”和“房产流通性”。两者完全不同，但又息息相关。房产流通性减弱，资产流动性减弱，那么需要印刷的人民币就减少。就像那个石子，不流通马上通胀，不涨价流通没问题，可是行不通，外资也不同意。既然是不断的上涨价格，只能一步步地限制房产流通，只要房产流通性少一点，通胀就会显现一点，然后再通过上调准备金率和加息等柔性政策来调整一点，用柳叶棉丝掌来化解泰森的一记重拳，以绵柔克强刚、化千钧于无形，这就是中国政府的策略（这好像是中国人最擅长的事情）。我们从官方媒体就能看到相关的消息，楼市签约率在下降，即流通性在下降，然后物价开始有所涨幅，如猪肉等副食产品，但央行马上上调准备金率和加息，来稳定物价。不知各位看官是否也看出些端倪。可预期的是，到完全化解危机之前，会不断地加息和调高准备金率，同时房产流通性会越来越弱，这个预言是否准确可在以后的央行政策上验证。等完全消除了由于经济过热导致的通货膨胀预期，那么就是房地产价格回归真实价值之时。<br>　　　　不管你看到没看到，这已是最后的疯狂，我们从两方面来分析：<br>　　　　第一，如果这场博弈以外资胜利而告终，那么中国经济将步日本90年代持续下滑的深渊，由于外资撤走，房市赖以生存的支柱坍塌，房价会一落千丈，可到时候不管是开发商还是老百姓都将承受经济下滑之苦，持有的货币迅速贬值，即便房价落下，也不一定买的起。这是中国政府和中国人民不可接受的，也是无法接受的。<br>　　　　第二，如果外资以失败而告终，即在汇率上把住出口，让房价回归真实价值，把外资同样套在中国，这才是胜利的前提。那么以美国财团为首的帝国主义噬血者必将疯狂报复，会在投资、出口等各方面对中国施加压力。我们今天人民币升值没有达到美国预期，已经导致中国出口到美国的产品受打压，进而引起了众多的贸易摩擦，由此可见一斑。我们知道，经济发展的三套马车是，投资、出口和消费，在投资、出口领域遭到报复会影响中国经济的发展，但我相信不会影响我们的发展速度，别忘了还有一套马车是“消费”，房价下降后，如果你是爱国者，请现在保护好你的钱包，到时千万别羞羞答答，要果断地出手买房，中国经济会在消费领域异军突起，继续独占世界经济引擎的鳌头。<br>　　　　所以我们要相信我们的政府，配合我们的政府，政府在事关全局的问题上是和老百姓站在一起的，政府是水上承载的舟，人民是水，没有水，何以载舟。</p><p><strong>References</strong>:</p><ol><li><a href="http://blog.sina.com.cn/s/blog_489bcf0701007xxp.html" target="_blank" rel="noopener">十分钟教你看懂中国房地产经济|魏延政的博客</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 中国经济 </tag>
            
            <tag> 房地产 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包问题及代码实现</title>
      <link href="/01backpack/"/>
      <url>/01backpack/</url>
      
        <content type="html"><![CDATA[<p>背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。</p><p>相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。</p><p>也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V。</p><p><img alt="背包问题的一个例子：应该选择哪些盒子，才能使价格尽可能地大，而保持重量小于或等于15 kg？" title="背包问题的一个例子：应该选择哪些盒子，才能使价格尽可能地大，而保持重量小于或等于15 kg？" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/375px-Knapsack.svg.png"></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>遵循贪心策略，首先尽量多地先装单位价值高的商品，如果该商品已全部拿走而背包未装满，继续尽量多地拿走每磅价值第二高的商品，依次类推，直到达到重量上限W。因此，通过将商品按每磅价值排序，贪心算法的时间运行时间是O(nlgn)。</p><p>但是这种方法并不能得到最优解：<strong>它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了</strong>。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义子问题 $\mathbf{\text{P(i, W)}}$ 为：在前 i 个物品中挑选总重量不超过 W 的物品，每种物品至多只能挑选1个，使得总价值最大；这时的最优值记作 $m(i,W)$ ，其中 $1\leq i\leq n$ ， $1\leq W\leq C$ 。</p><p><strong>1) Optimal Substructure最优子结构</strong>:<br>考虑第 i 个物品，无外乎两种可能：选，或者不选。<br>不选的话，背包的容量不变，改变为问题 $P(i-1, W)$ ；<br>选的话，背包的容量变小，改变为问题 $P(i-1, W-w_i)$ 。<br>最优方案就是比较这两种方案，哪个会更好些：</p><script type="math/tex; mode=display">m(i,W)=\max\{m(i-1,W),m(i-1,W-w_i)+v_i\} 。</script><p>得到：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/equation.svg"></p><p><strong>2) Overlapping Subproblems重叠子问题</strong>：</p><p>如果wi &gt; w，$P[i, w]$转化为求解一个子问题$P[i-1, w]$；<br>如果wi ≤ w，$P[i, w]$转换成了求解两个子问题：<br>一个包含商品i，$pi + P[i-1, w- wi]$；<br>一个不包含商品i，$P[i-1, w]$；<br>两种情况中的较大者即为$P[i, w]$</p><p>很显然$P[i-1, w-wi]$与$P[i-1, w]$有重叠子问题。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A Naive recursive implementation of 0-1 Knapsack problem */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the maximum value that can be put in a knapsack of capacity W</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapSack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> wt[], <span class="keyword">int</span> val[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Base Case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || W == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If weight of the nth item is more than Knapsack capacity W, then</span></span><br><span class="line">    <span class="comment">// this item cannot be included in the optimal solution</span></span><br><span class="line">    <span class="keyword">if</span> (wt[n - <span class="number">1</span>] &gt; W)</span><br><span class="line">        <span class="keyword">return</span> knapSack(W, wt, val, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the maximum of two cases:</span></span><br><span class="line">    <span class="comment">// (1) nth item included</span></span><br><span class="line">    <span class="comment">// (2) not included</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> max(val[n - <span class="number">1</span>] + knapSack(W - wt[n - <span class="number">1</span>], wt, val, n - <span class="number">1</span>),</span><br><span class="line">                   knapSack(W, wt, val, n - <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver program to test above function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> val[] = {<span class="number">60</span>, <span class="number">100</span>, <span class="number">120</span>}; <span class="comment">// 价值</span></span><br><span class="line">    <span class="keyword">int</span> wt[] = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>};    <span class="comment">// 重量</span></span><br><span class="line">    <span class="keyword">int</span> W = <span class="number">50</span>;                 <span class="comment">//背包的总capacity</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(val) / <span class="keyword">sizeof</span>(val[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; knapSack(W, wt, val, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>References</strong>:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/30959069" target="_blank" rel="noopener">0-1背包问题的动态规划算法</a></li><li><a href="https://www.google.com.hk/search?q=Knapsack+problem&amp;oq=Knapsack+problem&amp;aqs=chrome..69i57&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">0-1 Knapsack Problem | DP-10 - GeeksforGeeks</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中super()有什么用</title>
      <link href="/Python-super/"/>
      <url>/Python-super/</url>
      
        <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>super() 函数是用于调用父类(超类)的一个方法。</p><p>super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p><p>MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>以下是 super() 方法的语法:</p><p>super(type[, object-or-type])</p><p>Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 <code>super().xxx</code> 代替 <code>super(Class, self).xxx</code>.</p><p>在继承方法中，有以下两种子类继承方式，都可以完成父类继承<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Base created"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildA</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildB</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        /* super(ChildB, self).__init__() */</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">ChildA()</span><br><span class="line">ChildB()</span><br></pre></td></tr></tbody></table></figure><p></p><p>哪一种好呢？</p><p>我推荐用super()完成子类继承。理由是如果你的子类有多个父类，父类又有父类的话，使用super()方法就可以顺序继承了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯实战中文垃圾邮件分类</title>
      <link href="/NaiveBayes-Spam-Classification/"/>
      <url>/NaiveBayes-Spam-Classification/</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>  在我们日常生活中，经常会受到各种垃圾邮件，譬如来自商家的广告、打折促销信息、澳门博彩邮件、理财推广信息等，一般来说邮件客户端都会设置一定的关键词屏蔽这种垃圾邮件，或者对邮件进行归类，但是总会有一些漏网之鱼。<br>  不过，自己手动做一个垃圾邮件分类器也并不是什么难事。传统的机器学习算法通常会采用朴素贝叶斯、支持向量机等算法对垃圾邮件进行过滤，今天我们主要讲如何用Python手写一个朴素贝叶斯垃圾邮件分类器。当然，在讲PaddlePaddle做垃圾邮件处理之前，先回顾一下传统的机器学习算法是如何对垃圾邮件进行分类的。</p><h1 id="贝叶斯原理"><a href="#贝叶斯原理" class="headerlink" title="贝叶斯原理"></a>贝叶斯原理</h1><p>我们要做的是计算在已知词向量 $w=(w_1,w_2,…,w_n)$<br>的条件下求包含该词向量邮件是否为垃圾邮件的概率，即求：</p><script type="math/tex; mode=display">P(s|w),w=(w_1,w_2,...,w_n)</script><p>其中，ss表示分类为垃圾邮件. 根据贝叶斯公式和全概率公式，</p><script type="math/tex; mode=display">=\frac {P(s,w_1,w_2,...,w_n)}{P(w_1,w_2,...,w_n)}=\frac {P(w_1,w_2,...,w_n|s)P(s)}{P(w_1,w_2,...,w_n|s)\cdot p(s)+P(w_1,w_2,...,w_n|s^{'})\cdot p(s^{'})}\qquad\qquad...式1</script><h1 id="了解数据集"><a href="#了解数据集" class="headerlink" title="了解数据集"></a>了解数据集</h1><p>  首先先了解一下今天的数据集：<code>trec06c</code>。trec06c是一个公开的垃圾邮件语料库，由国际文本检索会议提供，分为英文数据集（trec06p）和中文数据集（trec06c），其中所含的邮件均来源于真实邮件保留了邮件的原有格式和内容。<br>文件下载地址：<a href="https://plg.uwaterloo.ca/~gvcormac/treccorpus06/" target="_blank" rel="noopener">trec06c</a><br>数据集结构：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trec06c</span><br><span class="line">│</span><br><span class="line">└───data</span><br><span class="line">│   │   000</span><br><span class="line">│   │   001</span><br><span class="line">│   │   ...</span><br><span class="line">│   └───215</span><br><span class="line">└───delay</span><br><span class="line">│   │   index</span><br><span class="line">└───full</span><br><span class="line">│   │   index</span><br></pre></td></tr></tbody></table></figure><p></p><p>每个文件夹里都包含两类邮件样本，而且没什么规律，要从<code>full/index</code>文件中查看标签：</p><p><img width="50%" height="50%" alt="trec06c" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/94d2a57376b39cc86a5bbc0486921dff.png"></p><p>垃圾邮件<code>spam</code>示例：</p><blockquote><p>本公司有部分普通发票（商品销售发票）增值税发票及海关代征增值税专用缴款书及其它服务行业发票,公路、内河运输发票。可以以低税率为贵公司代开，本公司具有内、外贸生意实力，保证我司开具的票据的真实性。 希望可以合作!共同发展!敬侯您的来电洽谈、咨询！ 联系人：李先生 联系电话：13632588281 如有打扰望谅解，祝商琪。</p></blockquote><p>正常邮件<code>ham</code>示例：</p><blockquote><p>本文讲的是孔子后人的故事。一个老领导回到家乡，跟儿子感情不和，跟贪财的孙子孔为本和睦。老领导的弟弟魏宗万是赶马车的。有个洋妞大概是考察民俗的，在他们家过年。孔为本总想出国，被爷爷教育了。最后，一家人基本和解。 顺便问另一类电影，北京青年电影制片厂的。</p></blockquote><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>拿到数据后我们可以很清楚的看到邮件的内容，但并不是所有的内容都是我们需要的，在这里我们仅提取了邮件中的中文来作为训练语料。如果仔细观察的话，会发现不是所有的邮件都能直接打开，数据的编码格式也需要转换成utf-8格式方便我们后面训练使用。所以我们需要对原始数据做一些数据预处理，包括以下几个内容。</p><ol><li>转换源数据编码格式为utf-8格式</li><li>转换过滤字符<br>去除所有非中文字符，如标点符号、英文字符、数字、网站链接等特殊字符。</li><li>转换过滤停用词</li><li>转换对邮件内容进行分词处理</li></ol><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p> 具体实现的源码已经给出，这里简单说下思路，就是一个分词并记录词频的过程：</p><ol><li>用结巴分词，并用停用表进行简单过滤，然后使用正则表达式过滤掉邮件中的非中文字符；</li><li>别保存正常邮件与垃圾邮件中出现的词有多少邮件出现该词，得到两个词典。例如词”疯狂”在8000封正常邮件中出现了20次，在8000封垃圾邮件中出现了200次；</li><li>测试集中的每一封邮件做同样的处理，并计算得到P(s|w)P(s|w)最高的15个词，在计算过程中，若该词只出现在垃圾邮件的词典中，则令P(w|s′)=0.01P(w|s′)=0.01，反之亦然；若都未出现，则令P(s|w)=0.4P(s|w)=0.4。PS.这里做的几个假设基于前人做的一些研究工作得出的。</li><li>得到的每封邮件中重要的15个词利用式2计算概率，若概率&gt;&gt;阈值α(一般设为0.9)α(一般设为0.9)，则判为垃圾邮件，否则判为正常邮件。</li></ol><p>References:</p><ol><li><a href="https://jizhi.im/blog/post/paddle-spam-mail-01" target="_blank" rel="noopener">用PaddlePaddle调戏邮件诈骗犯-Part1</a></li><li><a href="https://www.cnblogs.com/charlotte77/p/9071775.html" target="_blank" rel="noopener">PaddlePaddle垃圾邮件处理实战（一）</a></li><li><a href="https://blog.csdn.net/shijing_0214/article/details/51200965" target="_blank" rel="noopener">Python实现基于朴素贝叶斯的垃圾邮件分类</a></li><li><a href="https://blog.csdn.net/shijing_0214/article/details/51973376" target="_blank" rel="noopener">使用sklearn实现朴素贝叶斯文本分类</a></li><li><a href="https://blog.csdn.net/u011067360/article/details/22890465" target="_blank" rel="noopener">朴素贝叶斯分类器</a></li><li><a href="https://wizardforcel.gitbooks.io/dm-algo-top10/content/naive-bayes.html" target="_blank" rel="noopener">朴素贝叶斯分类器</a></li><li><a href="https://github.com/shijing888/BayesSpam" target="_blank" rel="noopener">shijing888/BayesSpam</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法:字典树(前缀树)Trie</title>
      <link href="/Trie/"/>
      <url>/Trie/</url>
      
        <content type="html"><![CDATA[<p>Trie，即字典树，又称前缀树，是一种有序树形结构。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p><!-- <img src="Trie_example.svg" width="50%" height="50%" title="一个保存了8个键的trie结构" alt=""/> --><p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><h1 id="前缀树的3个基本性质："><a href="#前缀树的3个基本性质：" class="headerlink" title="前缀树的3个基本性质："></a>前缀树的3个基本性质：</h1><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><h1 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点</strong>：</h2><p>可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。<br>跟哈希表比较：</p><ol><li>最坏情况时间复杂度比hash表好</li><li>没有冲突，除非一个key对应多个值（除key外的其他信息）</li><li>自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。</li></ol><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h2><ol><li><p>虽然不同单词共享前缀，但其实trie是一个以空间换时间的算法。其每一个字符都可能包含至多字符集大小数目的指针（不包含卫星数据）。<br>每个结点的子树的根节点的组织方式有几种。<br>1&gt;如果默认包含所有字符集，则查找速度快但浪费空间（特别是靠近树底部叶子）。<br>2&gt;如果用链接法(如左儿子右兄弟)，则节省空间但查找需顺序（部分）遍历链表。<br>3&gt;<em>alphabet reduction</em>: 减少字符宽度以减少字母集个数。<br>4&gt;对字符集使用bitmap，再配合链接法。</p></li><li><p>如果数据存储在外部存储器等较慢位置，Trie会较hash速度慢（hash访问O(1)次外存，Trie访问O(树高)）。</p></li><li>长的浮点数等会让链变得很长。可用bitwise trie改进。</li></ol><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p><strong>时间复杂度</strong> : $O(m)$, where m is the key length.<br>In each iteration of the algorithm, we either examine or create a node in the trie till we reach the end of the key. This takes only $m$ operations.</p><p><strong>空间复杂度</strong> : $O(m)$.<br>In the worst case newly inserted key doesn’t share a prefix with the the keys already inserted in the trie. We have to add $m$ new nodes, which takes us $O(m)$ space</p><h1 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h1><h2 id="自动补全Autocomplete"><a href="#自动补全Autocomplete" class="headerlink" title="自动补全Autocomplete"></a>自动补全<a href="https://en.wikipedia.org/wiki/Autocomplete" target="_blank" rel="noopener">Autocomplete</a></h2><p><img alt="Google Suggest in action." title="Google搜索实时建议" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/208_GoogleSuggest.png"></p><h2 id="拼写检查Spell-checker"><a href="#拼写检查Spell-checker" class="headerlink" title="拼写检查Spell checker"></a>拼写检查<a href="https://en.wikipedia.org/wiki/Spell_checker" target="_blank" rel="noopener">Spell checker</a></h2><!-- ![A spell checker used in word processor.](SpellCheck.png "拼写检查") --><p><img width="50%" height="50%" title="拼写检查工具Grammarly." alt="拼写检查工具Grammarly." data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/SpellCheck.png"></p><h2 id="IP路由-最长前缀匹配-IP-routing-Longest-prefix-matching"><a href="#IP路由-最长前缀匹配-IP-routing-Longest-prefix-matching" class="headerlink" title="IP路由(最长前缀匹配)IP routing (Longest prefix matching)"></a>IP路由(最长前缀匹配)<a href="https://en.wikipedia.org/wiki/Longest_prefix_match" target="_blank" rel="noopener">IP routing (Longest prefix matching)</a></h2><!-- ![最长前缀匹配算法使用IP协议中的前缀树来从转发表中选择路由端口.](208_IPRouting.gif "最长前缀匹配算法使用IP协议中的前缀树来从转发表中选择路由端口.") --><p><img width="50%" height="50%" title="最长前缀匹配算法使用IP协议中的前缀树来从转发表中选择路由端口." alt="最长前缀匹配算法使用IP协议中的前缀树来从转发表中选择路由端口." data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/208_IPRouting.gif"></p><h2 id="手机9键输入预测文本"><a href="#手机9键输入预测文本" class="headerlink" title="手机9键输入预测文本"></a>手机9键输入预测文本</h2><p><img width="50%" height="50%" title="T9代表9键上的文字，在20世纪90年代后期用于手机输入文本" alt="手机9键输入预测文本" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/208_T9.jpg"></p><h2 id="拼字游戏Boggle"><a href="#拼字游戏Boggle" class="headerlink" title="拼字游戏Boggle"></a>拼字游戏<a href="http://coursera.cs.princeton.edu/algs4/assignments/boggle.html" target="_blank" rel="noopener">Boggle</a></h2><!-- ![](208_Boggle.png) --><p><img width="50%" height="50%" alt="拼字游戏Boggle" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/208_Boggle.png"></p><h2 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h2><p>事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。<br>举例：</p><blockquote><ol><li>N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。</li><li>给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。</li><li>1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。</li></ol></blockquote><h2 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h2><blockquote><ol><li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li><li>有个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li><li>找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复度比较高，虽然总数是1千万，但是如果去除重复，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。<br>(1) 请描述你解决这个问题的思路；<br>(2) 请给出主要的处理流程，算法，以及算法的复杂度。</li></ol></blockquote><p>==》若无内存限制：Trie + “k-大/小根堆”（k为要找到的数目）。</p><p>否则，先hash分段再对每一个段用hash（另一个hash函数）统计词频，再要么利用归并排序的某些特性（如partial_sort），要么利用某使用外存的方法。参考</p><p>“海量数据处理之归并、堆排、前K方法的应用：一道面试题” :<a href="https://yq.aliyun.com/ziliao/417622" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/417622</a><br>“算法面试题之统计词频前k大” ：<a href="http://blog.csdn.net/u011077606/article/details/42640867" target="_blank" rel="noopener">http://blog.csdn.net/u011077606/article/details/42640867</a><br>算法导论笔记——第九章 中位数和顺序统计量</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。</p><blockquote><p> 比如给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。</p></blockquote><h2 id="字符串最长公共前缀"><a href="#字符串最长公共前缀" class="headerlink" title="字符串最长公共前缀"></a>字符串最长公共前缀</h2><p>Trie树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。<br>举例：</p><blockquote><p> 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？</p></blockquote><p>解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。<br>而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：</p><ol><li>利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；</li><li>求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；</li></ol><h2 id="字符串搜索的前缀匹配"><a href="#字符串搜索的前缀匹配" class="headerlink" title="字符串搜索的前缀匹配"></a>字符串搜索的前缀匹配</h2><p>trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。<br>Trie树检索的时间复杂度可以做到n，n是要检索单词的长度，<br>如果使用暴力检索，需要指数级O(n2)的时间复杂度。</p><h2 id="为其他数据结构和算法的辅助结构"><a href="#为其他数据结构和算法的辅助结构" class="headerlink" title="为其他数据结构和算法的辅助结构"></a>为其他数据结构和算法的辅助结构</h2><p>如后缀树，AC自动机等<br>后缀树可以用于全文搜索</p><h1 id="LeetCode相关题目"><a href="#LeetCode相关题目" class="headerlink" title="LeetCode相关题目"></a>LeetCode相关题目</h1><p>实现字典树<a href="https://www.jianshu.com/p/f1e5f385defd" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree)</a><br>字典树添加查找<a href="https://www.jianshu.com/p/1918ea7199ed" target="_blank" rel="noopener">211. Add and Search Word - Data structure design</a></p><h1 id="前缀树Python实现"><a href="#前缀树Python实现" class="headerlink" title="前缀树Python实现"></a>前缀树Python实现</h1><script src="//gist.github.com/d27c69e5852f3d0f4e7dc15bb90a2e24.js?file=trie.py"></script><p><strong>References</strong>:</p><ol><li><a href="https://leetcode.com/articles/implement-trie-prefix-tree/" target="_blank" rel="noopener">Leetcode 208. Implement Trie (Prefix Tree)</a></li><li><a href="https://segmentfault.com/a/1190000008877595" target="_blank" rel="noopener">小白详解 Trie 树</a></li><li><a href="http://www.cnblogs.com/justinh/p/7716421.html" target="_blank" rel="noopener">Trie（前缀树/字典树）及其应用</a></li><li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/06.09.md" target="_blank" rel="noopener">The-Art-Of-Programming-By-July:Trie树（字典树）</a></li><li><a href="https://my.oschina.net/u/158589/blog/61037" target="_blank" rel="noopener">Trie 的原理和实现 (python 实现）</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始用Python搭建推荐引擎(附代码)</title>
      <link href="/build-recommendation-with-Python/"/>
      <url>/build-recommendation-with-Python/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当今社会的每个人都面临着各种各样的选择。例如，如果我漫无目的想找一本书读，那么关于我如何搜索就会出现很多可能。这样一来，我可能会浪费很多时间在网上浏览，并且在各种各样的网站上搜寻，希望能找到有价值的书籍。这个时候我可能寻找别人的推荐。</p><p>如果有一家网站或者手机应用可以基于我以前阅读的书籍向我推荐新的书籍，那对我肯定有很大的帮助。这时我会有如下愉快的体验，登录网站，就可以看到符合我兴趣的10本书籍，不用浪费时间在网站上搜寻。</p><!-- ![](building-recommendation-engines.jpg) --><p>这就是推荐引擎所做的事情，它们的力量现在正被大多数企业所使用。从亚马逊到Netflix，谷歌到谷歌阅读，推荐引擎是机器学习技术中最广泛的应用之一。</p><a id="more"></a><p>在本文中，将介绍各种推荐引擎算法以及使用Python构建它们的基本框架。我们还将讨论这些算法工作背后的数学原理，最后使用矩阵分解技术创建属于我们自己的推荐引擎。</p><h1 id="什么是推荐引擎？"><a href="#什么是推荐引擎？" class="headerlink" title="什么是推荐引擎？"></a>什么是推荐引擎？</h1><p>一直到现在，人们也会倾向于买朋友或者信任的人推荐商品。当对某个商品有任何疑问时，人们往往会采用这种方式。但是随着数字时代的到来，这个圈子已经扩展到包括使用某种推荐引擎的在线网站。</p><p><strong>一个推荐引擎使用不同的算法过滤数据，并向用户推荐最相关的物品。它首先存储客户过去的行为数据，然后基于这些数据向客户推荐他们可能购买的物品。</strong></p><p>如果一个全新的用户访问一个电子商务网站，网站没有该用户的任何历史数据。那么在这样的场景中，网站是如何向用户推荐产品呢？一种可能的方法是向客户推荐卖的最好的商品，也就是该商品需求量很大。还有另外一种可能的方法是向用户推荐可以给网站带来最大利润的商品。</p><p>如果我们可以根据用户的需要和兴趣向用户推荐一些商品，这可以对用户体验产生积极的影响，最后可以达到多次访问的效果。因此，现在的企业通过研究用户过去的行为数据来构建聪明和智能的推荐引擎。</p><p>目前我们对推荐引擎有了直观的认识，现在让我们来看看它们是如何工作的。</p><h1 id="推荐引擎是如何工作的？"><a href="#推荐引擎是如何工作的？" class="headerlink" title="推荐引擎是如何工作的？"></a>推荐引擎是如何工作的？</h1><p>在深入探讨这个主题之前，我们首先考虑一下如何向用户推荐商品：</p><ul><li>我们可以向一个用户推荐最受欢迎的商品</li><li>可以根据用户偏好（用户特征）把用户分为多个细分类别，然后基于他们属于的类别推荐商品。</li></ul><p>上述两种方法都有缺点。在第一种方法中，对于每一个用户来说最受欢迎的商品都是相同的，所以用户看到的推荐也是相同的。在第二种方法中，随着用户数量的增加，用户特征也随着增加。因此将用户划分为多个类别将会是一件非常困难的任务。</p><p>这里的主要问题是我们无法为用户具体的兴趣定制推荐。这就像亚马逊建议你买一台笔记本电脑，仅仅是因为它被大多数购物者购买。但幸运的是，亚马逊（或其他大公司）并没有使用上述方法来推荐商品。他们使用一些个性化的方法来帮助他们更准确地推荐产品。</p><p>我们现在来看看推荐引擎是如何通过以下步骤来工作的。</p><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>收集数据是构建推荐引擎的第一步也是最关键的一步。可以通过两种方式收集数据：显式和隐式。显示数据是用户有意提供的信息，比如电影排名，相反隐氏数据则不是用户主动提供，而是从数据流中收集得到的信息，例如搜索历史、点击率、历史订单等。</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/explicit.png"></p><p>在上面的图片中，Netflix正在以用户对不同电影的评分形式明确地收集数据。</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/implicit.jpg"></p><p>上图可以看到Amazon记录的用户历史订单，这是一个隐式数据收集模式的例子。</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>数据量决定了模型的建议有多好，例如，在电影推荐系统中，用户对电影的评价越多，推荐给其他用户的效果就越好。数据类型对采用何种存储类型有很重要的影响，这种类型的存储可以包括一个标准的SQL数据库、NoSQL数据库或某种类型的对象存储。</p><h2 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h2><p>在收集和存储数据之后，我们必须对其进行过滤，以便提取出最终推荐所需的相关信息。<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Filtering.png"></p><p>有各种各样的算法可以帮助我们简化过滤过程。在下一节中，我们将详细介绍每种算法。</p><h3 id="基于内容的过滤"><a href="#基于内容的过滤" class="headerlink" title="基于内容的过滤"></a>基于内容的过滤</h3><p>这个算法推荐的产品类似于用户过去喜欢的产品。<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-06-21-10-57-38.png"><br>例如，如果一位用户喜欢《盗梦空间》这部电影，那么算法就会推荐属于同一类型的电影。但是，算法是如何理解选择和推荐电影的类型呢？</p><p>以Netflix为例：它们以向量形式保存与每个用户相关的所有信息。这个向量包含用户过去的行为，也就是用户喜欢/不喜欢的电影和他们给出的评分，这个向量也被称为轮廓向量（profile vector）。所有与电影相关的信息都存储在另一个叫做项目向量（item vector）中。项目向量包含每个电影的细节，如类型、演员、导演等。</p><p>基于内容的过滤算法找到了轮廓向量与项目向量夹角的余弦，也就是余弦相似度。假设A是轮廓矢量，B是项目矢量，那么它们之间的相似性可以按如下公式计算：</p><script type="math/tex; mode=display">\operatorname { sim } ( A , B ) = \cos ( \theta ) = \frac { A \cdot B } { \| A \| B \| }</script><p>根据在-1到1之间的余弦值，可以将电影按降序排列，并且采用下面两种方法中的一种用于推荐：</p><ul><li>选择前N部电影：推荐最相关的前N部电影（这里N可以由公司决定）。</li><li>等级量表的方法：设置一个阈值，并推荐所有超过该阈值的电影。</li></ul><p>其它可以用来计算相似性的方法有：</p><ul><li>欧几里得距离：如果在N维空间中绘制，相似的实体将会彼此靠近。因此，我们可以计算实体之间的距离根据这个距离，向用户推荐内容。下面是欧几里得距离公式：</li></ul><script type="math/tex; mode=display">\text { Euclidean Distance } = \sqrt { \left( x _ { 1 } - y _ { 1 } \right) ^ { 2 } + \ldots + \left( x _ { N } - y _ { N } \right) ^ { 2 } }</script><ul><li>皮尔逊相似度：它告诉我们两个实体的相关程度，越高的相关性，就越相似。皮尔逊的相关性可以用以下公式来计算：</li></ul><script type="math/tex; mode=display">\operatorname { sim } ( u , v ) = \frac { \sum \left( r _ { u i } - \overline { r } _ { u } \right) \left( r _ { v i } - \overline { r } _ { v } \right) } { \sqrt { \sum \left( r _ { u i } - \overline { r } _ { u } \right) ^ { 2 } } \sqrt { \sum \left( r _ { v i } - \overline { r } _ { v } \right) ^ { 2 } } }</script><p>这种算法有一个主要的缺点，也就是它仅限于推荐相同类型的实体。它永远不会推荐用户过去没有购买或喜欢的产品。因此，如果用户过去仅仅看或喜欢动作电影，系统也就只会推荐动作电影。很显然，这种搭建推荐引擎的方法泛化性能很差。</p><p>我们要找到一种算法可以改进这种类型的推荐系统，它不仅可以根据内容进行推荐，还要可以利用用户的行为信息。</p><h3 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h3><p>我们通过一个例子来理解这个方法。如果用户A喜欢3部电影，比如《星际穿越》，《盗梦空间》和《前目的地》，而用户B喜欢《盗梦空间》、《前目的地》和《致命魔术》，那么他们就有差不多的兴趣爱好。我们可以肯定地说，A应该喜欢《致命魔术》，B应该喜欢《星际穿越》。协同过滤算法使用“用户行为”来推荐电影。这是工业中最常用的算法之一，因为它不依赖于任何额外的信息。协同过滤技术有很多种不同的类型，我们将在下面详细讨论这些问题。</p><h4 id="基于用户的协同过滤"><a href="#基于用户的协同过滤" class="headerlink" title="基于用户的协同过滤"></a>基于用户的协同过滤</h4><p>该算法首先发现用户之间的相似性分数，基于这个相似性的分数，它会挑选出最相似的用户，并推荐这些类似的用户以前喜欢或购买的产品。</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/0o0zVW2O6Rv-LI5Mu1-850x466.png"></p><p>就我们之前的电影例子而言，这个算法根据他们之前给不同电影的评分来发现每个用户之间的相似性。用户$u$的一个实体的预测是通过计算其它用户对一个实体$i$的用户评分的加权总和来计算的。$Pu$，$i$通过下式计算得到：</p><script type="math/tex; mode=display">P _ { u , i } = \frac { \sum _ { v } \left( r _ { v , i } * s _ { u , v } \right) } { \sum _ { v } s _ { u , v } }</script><p>其中$P <em> { u , i }$ 是关于用户$u$对电影$i$的预测评分，$r </em> { v , i }$是用户$v$对电影$i$的实际评分，$s _ { u , v }$是用户$u$、$v$之间的相似度。</p><p>现在，我们在轮廓向量中对用户进行了评分，并且基于这个向量，我们要预测其他用户的评分。接下来的步骤如下：</p><ul><li>对于预测，我们需要用户u和v之间的相似性。这时可以利用皮尔逊相关性。</li><li>首先，我们发现被用户打分的商品，根据评分，计算用户之间的相关性。</li><li>可以用相似值来计算预测。这个算法首先计算每个用户之间的相似性，然后根据每个相似度计算预测值。具有高相关性的用户，一般都相似。</li><li>基于这些预测值给出推荐。我们通过一个例子来理解它：</li></ul><p>用户-电影评分矩阵：</p><div class="table-container"><table><thead><tr><th>User/Movie</th><th>$x_{1}$</th><th>$x_{2}$</th><th>$x_{3}$</th><th>$x_{4}$</th><th>$x_{5}$</th></tr></thead><tbody><tr><td>A</td><td>4</td><td>1</td><td>2</td><td>4</td><td>4</td></tr><tr><td>B</td><td>2</td><td>4</td><td>4</td><td>2</td><td>1</td></tr><tr><td>C</td><td>–</td><td>1</td><td>–</td><td>3</td><td>4</td></tr><tr><td>Mean Item Rating</td><td>3</td><td>2</td><td>3</td><td>3</td><td>3</td></tr></tbody></table></div><p>我们可以看到一个用户-电影评分矩阵，为了更深入地理解这个公式，让我们在上表中找到用户(A, C)和(B, C)之间的相似性。A与C共同评分的电影是$x<em>{2}$和$x</em>{4}$，B与C共同评分的电影是$x<em>{2}$,$x</em>{4}$和$x_{5}$。</p><script type="math/tex; mode=display">C_{14}=\frac{(4-3)*(4-3) + (2-3)*(2-3)}{[(4-3)^{2}+(2-3)^{2}]^{\frac{1}{2}} * [(4-3)^{2}+(2-3)^{2}]^{\frac{1}{2}}}=1</script><script type="math/tex; mode=display">C_{15}=\frac{(4-3)*(4-3) + (2-3)*(1-3)}{[(4-3)^{2}+(2-3)^{2}]^{\frac{1}{2}} * [(4-3)^{2}+(1-3)^{2}]^{\frac{1}{2}}}=0.94</script><p>用户A和C之间的相关性大于B和C之间的相关性。因此用户A和C有更多的相似性，用户A喜欢的电影会推荐给用户C，反之亦然。</p><p>这个算法非常耗时，因为它涉及到计算每个用户的相似度，然后计算每个相似度得分的预测。解决这个问题的一种方法是只选择几个用户(邻居)而不是对所有的值进行预测，也就是说，我们只选择几个相似值而不是对所有相似值进行预测：</p><ul><li>选择一个相似度阈值并选择该值以上的所有用户</li><li>随机选择用户</li><li>按照相似度值的降序排列相邻用户，然后选择前n个用户</li><li>使用聚类算法选择相邻用户</li></ul><p>当用户数量较少时，这个算法可以很好的发挥作用。当有大量的用户时，它并不有效，因为计算所有用户对之间的相似性需要花费大量的时间。这就产生了商品-商品的协同过滤，当用户数量远远超过推荐商品的数量时，这种算法是非常有效的。</p><h4 id="基于物品的相似度"><a href="#基于物品的相似度" class="headerlink" title="基于物品的相似度"></a>基于物品的相似度</h4><p>在这个算法中，我们计算每一对商品之间的相似度。<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/1skK2fqWiBF7weHU8SjuCzw.png"><br>所以在我们的案例中，我们会发现每个电影对之间的相似性，在此基础上，我们可以推荐用户过去喜欢的相似的电影。这个算法的工作原理类似于用户-用户协同过滤，仅仅做了一点小小的改变——不是对“相邻用户”的评分进行加权求和，而是对“相邻商品”的评分进行加权求和。预测公式如下：</p><script type="math/tex; mode=display">P _ { u , i } = \frac { \sum _ { N } \left( s _ { i , N } * R _ { u , N } \right) } { \sum _ { N } \left( \left| s _ { i , N } \right| \right) }</script><p>我们计算商品之间的相似性：</p><script type="math/tex; mode=display">\operatorname { sim } ( i , j ) = \cos ( \vec { i } , \vec { j } ) = \frac { \vec { i } \cdot \vec { j } } { \| \vec { i } \| _ { 2 } * \| \vec { j } \| _ { 2 } }</script><p>现在我们我们有每一对电影的相似性，评分和预测都已经有了，而且基于这些预测，我们可以进行相似电影的推荐。我们通过一个例子来理解：</p><div class="table-container"><table><thead><tr><th>User/Movie</th><th>$x_{1}$</th><th>$x_{2}$</th><th>$x_{3}$</th><th>$x_{4}$</th><th>$x_{5}$</th></tr></thead><tbody><tr><td>A</td><td>4</td><td>1</td><td>2</td><td>4</td><td>4</td></tr><tr><td>B</td><td>2</td><td>4</td><td>4</td><td>2</td><td>1</td></tr><tr><td>C</td><td>–</td><td>1</td><td>–</td><td>3</td><td>4</td></tr><tr><td>Mean Item Rating</td><td>3</td><td>2</td><td>3</td><td>3</td><td>3</td></tr></tbody></table></div><p>这里的电影评分均值是所有个某一特定电影评分的平均值（将它与我们在用户-用户过滤中看到的表进行比较）。并且我们不是像前面看到的那样找到用户-用户相似度，而是找到商品-商品相似度。</p><p>要做到这一点，首先我们需要找到对这些商品进行评分的用户，并根据评分计算商品之间的相似性。我们来找出电影($x<em>{1}$, $x</em>{4}$)和($x<em>{1}$, $x</em>{5}$)之间的相似性。从上表可以看出，给电影$x<em>{1}$, $x</em>{4}$都有打分的用户是A与B，给电影$x<em>{1}$, $x</em>{5}$都有打分的用户也是A与B。</p><p>电影$x<em>{1}$和$x</em>{4}$的相似度大于电影$x<em>{1}$和$x</em>{5}$的相似度，基于这些相似度值，如果有任何用户搜索电影 $x<em>{1}$，那么将会为他们推荐电影$x</em>{4}$，反之也一样。在进一步运用这些概念之前，有一个问题我们必须要知道答案——如果在数据集中添加了新用户或新电影，将会发生什么？这被称为冷启动，它有两种类型:</p><ul><li>用户冷启动</li><li>物品冷启动</li></ul><p>用户冷启动意味着数据库中新增加了一位新用户，由于没有该用户的历史记录，系统也就不知道该用户的偏好，所以向这位用户推荐商品就会很困难。所以我们将如何解决这个问题呢？一种基本的方法是采用基于流行度的策略，即推荐最受欢迎的产品。这些可以由最近的流行趋势来决定，以后一旦我们知道了用户的喜好，推荐商品就会变的很容易。</p><p>另一方面，产品冷启动意味着新产品投放市场或添加到系统中。用户的行为对决定任何产品价值来说都是很重要的。产品接受的交互越多，我们的模型就越容易向正确的用户推荐该产品。我们可以利用基于内容的过滤来解决这个问题。系统首先使用新产品的内容进行推荐，不过最终使用用户对该产品的交互进行推荐。</p><p>现在让我们使用Python中的一个案例学习来巩固我们对这些概念的理解。这个例子非常有趣，快打开你的电脑准备开始吧。</p><h1 id="基于MovieLens数据集的python实例学习"><a href="#基于MovieLens数据集的python实例学习" class="headerlink" title="基于MovieLens数据集的python实例学习"></a>基于MovieLens数据集的python实例学习</h1><p>我们将使用这个MovieLens数据集建立一个模型并向最终用户推荐电影。明尼苏达大学（University of Minnesota）的GroupLens研究项目已经收集了这些数据。数据集可以从这里下载：<a href="https://grouplens.org/datasets/movielens/100k/" target="_blank" rel="noopener">MovieLens-100k</a></p><p>这个数据集包含有：</p><ul><li>1682部电影中有943位观众观看了10万次(1-5次)</li><li>用户的人口统计信息(年龄、性别、职业等)</li></ul><p>首先，我们将导入标准库并将数据读入Python中：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># pass in column names for each CSV as the column name is not given in the file and read them using pandas.</span></span><br><span class="line"><span class="comment"># You can check the column names from the readme file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Reading users file:</span></span><br><span class="line">u_cols = [<span class="string">'user_id'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>, <span class="string">'occupation'</span>, <span class="string">'zip_code'</span>]</span><br><span class="line">users = pd.read_csv(<span class="string">'ml-100k/u.user'</span>, sep=<span class="string">'|'</span>, names=u_cols,encoding=<span class="string">'latin-1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Reading ratings file:</span></span><br><span class="line">r_cols = [<span class="string">'user_id'</span>, <span class="string">'movie_id'</span>, <span class="string">'rating'</span>, <span class="string">'unix_timestamp'</span>]</span><br><span class="line">ratings = pd.read_csv(<span class="string">'ml-100k/u.data'</span>, sep=<span class="string">'\t'</span>, names=r_cols,encoding=<span class="string">'latin-1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Reading items file:</span></span><br><span class="line">i_cols = [<span class="string">'movie id'</span>, <span class="string">'movie title'</span> ,<span class="string">'release date'</span>,<span class="string">'video release date'</span>, <span class="string">'IMDb URL'</span>, <span class="string">'unknown'</span>, <span class="string">'Action'</span>, <span class="string">'Adventure'</span>,</span><br><span class="line"><span class="string">'Animation'</span>, <span class="string">'Children\'s'</span>, <span class="string">'Comedy'</span>, <span class="string">'Crime'</span>, <span class="string">'Documentary'</span>, <span class="string">'Drama'</span>, <span class="string">'Fantasy'</span>,</span><br><span class="line"><span class="string">'Film-Noir'</span>, <span class="string">'Horror'</span>, <span class="string">'Musical'</span>, <span class="string">'Mystery'</span>, <span class="string">'Romance'</span>, <span class="string">'Sci-Fi'</span>, <span class="string">'Thriller'</span>, <span class="string">'War'</span>, <span class="string">'Western'</span>]</span><br><span class="line">items = pd.read_csv(<span class="string">'ml-100k/u.item'</span>, sep=<span class="string">'|'</span>, names=i_cols,</span><br><span class="line">encoding=<span class="string">'latin-1'</span>)</span><br></pre></td></tr></tbody></table></figure><p>加载数据集之后，我们应该查看每个文件的内容(用户、评分、电影)：</p><ul><li><strong>用户</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(users.shape)</span><br><span class="line">users.head()</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/user_df.png"></p><p>因此，我们可以看到数据集中有943个用户，每个用户有5个特性，即用户ID、年龄、性别、职业和邮政编码。现在我们来看看评分文件。</p><ul><li><strong>评分</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ratings.shape)</span><br><span class="line">ratings.head()</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/rating_df.png"></p><p>对于不同的用户和电影组合，我们有100k个电影评分。现在最后检查电影文件。</p><ul><li><strong>电影</strong><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(items.shape)</span><br><span class="line">items.head()</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/item_df.png"></p><p>这个数据集包含了1682部电影的属性，一共有24列，其中最后19列指定了具体电影的类型。这些是二进制列，即，值1表示该电影属于该类型，否则为0。</p><p>GroupLens已经将数据集划分为train和test，每个用户的测试数据有10个等级，总共9430行。我们接下来把这些文件读入到python环境中。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r_cols = [<span class="string">'user_id'</span>, <span class="string">'movie_id'</span>, <span class="string">'rating'</span>, <span class="string">'unix_timestamp'</span>]</span><br><span class="line">ratings_train = pd.read_csv(<span class="string">'ml-100k/ua.base'</span>, sep=<span class="string">'\t'</span>, names=r_cols, encoding=<span class="string">'latin-1'</span>)</span><br><span class="line">ratings_test = pd.read_csv(<span class="string">'ml-100k/ua.test'</span>, sep=<span class="string">'\t'</span>, names=r_cols, encoding=<span class="string">'latin-1'</span>)</span><br><span class="line">ratings_train.shape, ratings_test.shape</span><br></pre></td></tr></tbody></table></figure><p>现在终于到了构建我们推荐引擎的时候了!</p><h1 id="从0搭建协同过滤模型"><a href="#从0搭建协同过滤模型" class="headerlink" title="从0搭建协同过滤模型"></a>从0搭建协同过滤模型</h1><p>我们将根据用户-用户相似度和电影-电影相似度推荐电影。为此，我们首先需要计算独立用户和电影的数量。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n_users = ratings.user_id.unique().shape[<span class="number">0</span>]</span><br><span class="line">n_items = ratings.movie_id.unique().shape[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><p></p><p>现在，我们将创建一个用户电影矩阵，该矩阵可用于计算用户与电影之间的相似性。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_matrix = np.zeros((n_users, n_items))</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ratings.itertuples():</span><br><span class="line">    data_matrix[line[<span class="number">1</span>]<span class="number">-1</span>, line[<span class="number">2</span>]<span class="number">-1</span>] = line[<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure><p></p><p>现在，我们来计算相似度。我们可以使用sklearn的pairwise_distance函数来计算余弦相似度。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line">user_similarity = pairwise_distances(data_matrix, metric=<span class="string">'cosine'</span>)</span><br><span class="line">item_similarity = pairwise_distances(data_matrix.T, metric=<span class="string">'cosine'</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><p>这就给出了数组表单中的item-item和user-user相似度。下一步是根据这些相似数值做出预测，下面我们定义一个函数来做这个预测。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(ratings, similarity, type=<span class="string">'user'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> type == <span class="string">'user'</span>:</span><br><span class="line">        mean_user_rating = ratings.mean(axis=<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#We use np.newaxis so that mean_user_rating has same format as ratings</span></span><br><span class="line">        ratings_diff = (ratings - mean_user_rating[:, np.newaxis])</span><br><span class="line">        pred = mean_user_rating[:, np.newaxis] + similarity.dot(ratings_diff) / np.array([np.abs(similarity).sum(axis=<span class="number">1</span>)]).T</span><br><span class="line">    <span class="keyword">elif</span> type == <span class="string">'item'</span>:</span><br><span class="line">        pred = ratings.dot(similarity) / np.array([np.abs(similarity).sum(axis=<span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">return</span> pred</span><br></pre></td></tr></tbody></table></figure><p></p><p>最后，我们将基于用户相似度和电影相似度进行预测。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_prediction = predict(data_matrix, user_similarity, type=<span class="string">'user'</span>)</span><br><span class="line">item_prediction = predict(data_matrix, item_similarity, type=<span class="string">'item'</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><p>事实证明，我们还有一个库，可以自动生成所有这些推荐。现在让我们学习如何在Python中使用turicreate创建推荐引擎。要熟悉turicreate并将它安装到你的电脑上，请参考<a href="https://github.com/apple/turicreate/blob/master/README.md" target="_blank" rel="noopener">这里</a>。</p><h1 id="使用Turicreate搭建简单流行的协同过滤模型"><a href="#使用Turicreate搭建简单流行的协同过滤模型" class="headerlink" title="使用Turicreate搭建简单流行的协同过滤模型"></a>使用Turicreate搭建简单流行的协同过滤模型</h1><p>在安装好turicreate库之后，首先导入它，然后在我们的环境中读取训练和测试数据集。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> turicreate</span><br><span class="line">train_data = turicreate.SFrame(ratings_train)</span><br><span class="line">test_data = turicreate.Sframe(ratings_test)</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们有用户行为，也有用户和电影的属性，所以我们可以制作基于内容和协同过滤算法。我们将从一个简单的流行模型开始，然后构建一个协同过滤模型。</p><p>首先，我们建立一个向用户推荐最流行电影的模型，也就是所有用户都会收到相同的推荐。我们可以使用Turicreate中的popularity_recommender推荐函数来实现。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popularity_model = turicreate.popularity_recommender.create(</span><br><span class="line">    train_data, user_id=<span class="string">'user_id'</span>, item_id=<span class="string">'movie_id'</span>, target=<span class="string">'rating'</span>)</span><br></pre></td></tr></tbody></table></figure><p>我们使用的各种变量有：</p><ul><li>train_data：SFrame包含了我们所需要的训练数据</li><li>user_id：这一列包含了每个用户的ID</li><li>item_id: 这一列包含了每一个要被推荐的电影（电影ID）</li><li>target:这一列包含了用户给的评分或等级</li></ul><p>预测的时间到了!我们将为我们数据集中的前5个用户推荐排名前5的电影。<br></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popularity_recomm = popularity_model.recommend(users=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],k=<span class="number">5</span>)</span><br><span class="line">popularity_recomm.print_rows(num_rows=<span class="number">25</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-29-22-18-32.png"></p><p>注意，所有用户的推荐都是一样的——1467、1201、1189、1122、814。它们的顺序是一样的!这证实了所有推荐电影的平均评分都是5分，即所有观看电影的用户都给予了最高的评分。因此我们基于流行的系统表现是符合我们预期的。</p><p>在构建了流行模型之后，我们现在将构建一个协同过滤模型。我们来训练电影相似度模型，并为前5名用户提供前5项推荐。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Training the model</span></span><br><span class="line">item_sim_model = turicreate.item_similarity_recommender.create(train_data, user_id=<span class="string">'user_id'</span>, item_id=<span class="string">'movie_id'</span>, target=<span class="string">'rating'</span>, similarity_type=<span class="string">'cosine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Making recommendations</span></span><br><span class="line">item_sim_recomm = item_sim_model.recommend(users=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],k=<span class="number">5</span>)</span><br><span class="line">item_sim_recomm.print_rows(num_rows=<span class="number">25</span>)</span><br></pre></td></tr></tbody></table></figure><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-29-22-20-07.png"></p><p>在这里我们可以看到每个用户的推荐(movie id)是不同的。对于不同的用户，我们有不同的推荐集，也就是说个性化是存在的。</p><p>在这个模型中，我们没有每个用户给出的每个电影的评分。我们必须找到一种方法来预测所有这些缺失的评分。为此，我们必须找到一组可以定义用户如何评价电影的特征。这些被称为潜在特征（latent features）。我们需要找到一种方法，从现有的特征中提取出最重要的潜在特征。下一节将介绍矩阵分解技术，它使用低维密集矩阵，帮助我们提取重要的潜在特征。</p><h1 id="矩阵分解简介"><a href="#矩阵分解简介" class="headerlink" title="矩阵分解简介"></a>矩阵分解简介</h1><p>我们通过一个例子来理解矩阵分解。考虑不同用户对不同电影给出的用户电影评分矩阵(1-5)。</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-29-22-21-25.png"></p><p>这里的用户id是不同用户的唯一id，每个电影也被分配一个唯一id。0.0表示用户没有对特定的电影进行评分(1是用户能给出的最低评分)。我们希望预测这些缺失的评分，使用矩阵分解可以找到一些潜在的特征，它们可以决定用户如何评价一部电影。我们将原矩阵分解成不同的组成部分，使这些部分的乘积等于原始矩阵。</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Matrix_factorization-850x315.png"></p><p>假设我们要找到k个潜在特征。因此，我们可以将我们的评分矩阵R(MxN)划分为P(MxK)和Q(NxK)，使P x QT(这里QT是Q矩阵的转置)近似于R矩阵:</p><script type="math/tex; mode=display">\mathrm { R } = \mathrm { P } \Sigma \mathrm { Q } ^ { \mathrm { T } }</script><p>其中$M$是用户数，$N$是电影数，$K$是潜在特征数，$R$是$M\times N$大小的用户电影评分矩阵，$P$是$M\times K$大小的用户特征关联矩阵，表示用户与特征之间的关联，$Q$是$N\times K$大小的电影特征关联矩阵，表示电影与特征之间的关联，$Σ$是$K*K$个对角特征权重矩阵，代表了特征的重要权重.</p><p>通过矩阵分解的方法来选择潜在特征并消除了数据中的噪声。如何做到的呢？它是删除了不能决定用户如何评价电影的特征。现在要得到用户puk对一部电影qik的所有潜在特征k的评分rui，我们可以计算这两个向量的点积，并将它们相加，得到基于所有潜在特征的评分。</p><script type="math/tex; mode=display">r _ { \mathrm { ui } } = \Sigma _ { \mathrm { k } = 1 } ^ { \mathrm { K } } \mathrm { p } _ { \mathrm { uk } } \sigma _ { \mathrm { k } } \mathrm { q } _ { \mathrm { ki } }</script><p>这就是矩阵分解给我们预测电影的评分，而这些电影并没有得到用户的评分。但是，我们如何将新数据添加到我们的用户电影评分矩阵中，也就是说，如果一个新用户加入并对电影进行评分，我们将如何将这些数据添加到已有的矩阵中?</p><p>我通过矩阵分解的方法让你更容易理解这个过程。如果有一个新用户进入系统，对角权重矩阵和商品-特征相关性矩阵是不会发生变化的，唯一的变化是发生在用户特征关联矩阵P中。我们可以用一些矩阵乘法来实现这个。</p><p>我们有：</p><script type="math/tex; mode=display">\mathrm { R } = \mathrm { P } \Sigma \mathrm { Q } ^ { \mathrm { T } }</script><p>两边同时乘以矩阵$Q$：</p><script type="math/tex; mode=display">\mathrm { RQ } = \mathrm { P } \Sigma \mathrm { Q } ^ { \mathrm { T } }Q</script><p>现在我们有${ Q } ^ { { T } }Q=1$，所以$RQ=PΣ$，进一步简化，得到$P$矩阵:</p><script type="math/tex; mode=display">P \Sigma Q^1 = P</script><p>这是更新后的用户特征关联矩阵。同样地，如果向系统中添加了新电影，我们可以按照类似的步骤得到更新后的电影特征关联矩阵Q。</p><p>我们要有意识，虽然把R矩阵分解成P和Q，但是我们如何决定哪个P和Q矩阵更加近似于R矩阵呢？我们可以用梯度下降算法来做这个，目标是最小化实际评分与使用P和Q进行评估的评分之间的平方误差。平方误差公式如下所示:</p><script type="math/tex; mode=display">e _ { u i } ^ { 2 } = \left( r _ { u i } - \check { r } _ { u i } \right) ^ { 2 } = \left( r _ { u i } - \Sigma _ { k = 1 } ^ { K } p _ { u k } \sigma _ { k } q _ { k } \right) ^ { 2 }</script><p>其中$e<em>{ui}$ 表示误差，$r</em>{ui}$ 表示用户$u$对电影$i$的实际评分，$ř_{ui}$ 表示预测用户$u$对电影$i$的评预测分。</p><p>我们的目标是确定p和q值，使误差最小化，因此需要更新p值和q值，以得到这些矩阵的优化值，这样误差最小。现在我们将为puk和qki定义一个更新规则，在梯度下降中的更新规则是由要最小化的误差梯度定义的。</p><script type="math/tex; mode=display">\frac { \partial } { \partial p u k } \left( e _ { u i } ^ { 2 } \right) = - 2 \left( r _ { u i } - \check { r } _ { u i } \right) q _ { k i } = - 2 e _ { u i } q _ { k j }</script><script type="math/tex; mode=display">\frac { \partial } { \partial q k i } \left( e _ { u i } ^ { 2 } \right) = - 2 \left( r _ { u i } - \check { r } _ { u i } \right) p _ { u k } = - 2 e _ { u i } p _ { u k }</script><p>因为我们现在有了梯度，我们可以为puk和qki应用更新规则：</p><script type="math/tex; mode=display">p _ { u k } ^ { \prime } = p _ { u k } - \alpha ^ { \star } \frac { \partial } { \partial p u k } \left( e _ { u i } ^ { 2 } \right) = p _ { u k } + 2 e _ { u i } q _ { k i }</script><script type="math/tex; mode=display">q _ { k i } ^ { \prime } = q _ { k i } - \alpha ^ { \star } \frac { \partial } { \partial q k i } \left( e _ { u i } ^ { 2 } \right) = q _ { k i } + 2 e _ { u i } p _ { u k }</script><p>α是学习率，它决定每次更新的大小。重复上述更新过程，直到误差最小化为止，最后我们可以得到最优的P和Q矩阵，可以用来预测评分。我们快速回顾一下这个算法是如何工作的，然后我们来构建推荐引擎预测未评分电影的评分。</p><p>下面是矩阵分解预测评分的工作原理:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># for f = 1,2,....,k :</span><br><span class="line">    # for rui ε R :</span><br><span class="line">        # predict rui</span><br><span class="line">        # update puk and qki</span><br></pre></td></tr></tbody></table></figure><p>基于每个潜在特征，R矩阵中所有缺失的评分都将使用预测的rui值进行填充。然后利用梯度下降法对puk和qki进行更新，得到它们的最优值。过程如下图所示:</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-29-22-24-52.png"></p><p>现在已经了解了这个算法的内部工作原理，接下来我们将举一个例子，看看如何将矩阵分解成它的组成部分。</p><p>使用一个2x3矩阵，如下图所示:</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-14-58-31.png"></p><p>这里我们有2个用户和3部电影的相应评分。现在，我们将这个矩阵分解成子部分，如下所示:</p><script type="math/tex; mode=display">A _ { 2 x _ { 3 } } = P _ { 2 x _ { 2 } } \Sigma _ { 2 x _ { 3 } } Q _ { 3 x _ { 3 } } ^ { T }</script><p>AAT的特征值会给我们P矩阵而ATA的特征值会给我们Q矩阵，Σ是AAT或ATA矩阵特征值的平方根。</p><p>计算AAT的特征值：</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-04-48.png"></p><script type="math/tex; mode=display">\begin{array} { l } { \operatorname { det } \left( A A ^ { \top } - \lambda l \right) = 0 } \\{ \lambda ^ { 2 } - 34 \lambda + 225 = ( \lambda - 25 ) ( \lambda - 9 ) = 0 } \end{array}</script><p>AAT的特征值是25，9同样道理，我们可以计算出ATA的特征值。这些值是25，9，0，现在我们可以计算AAT和ATA对应的特征向量。</p><p>特征值λ= 25,我们有:<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-06-27-17-42-32.png"><br>可以按行简化为:</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-10-32.png"><br>该矩阵内核中的单位向量为:<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-14-12.png"><br>同样,λ= 9我们有:<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-06-27-18-08-42.png"><br>可以按行简化为：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-19-00.png"><br>该矩阵内核中的单位向量为:<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-21-49.png"><br>对于最后一个特征向量，我们可以找到一个单位向量垂直于q1和q2。所以,<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-23-09.png"><br>Σ2X3矩阵是AAT或ATA特征值的平方根即25和9：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-25-18.png"><br>最后，我可可以通过公式σpi = Aqi, or pi = 1/σ(Aqi) 计算P2X2 ：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-27-49.png"><br>所以由A矩阵分解出的矩阵如下所示：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-29-21.png"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-30-30.png"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot-from-2018-05-30-15-35-38.png"><br>我们有了P和Q矩阵，我们可以使用梯度下降法得到它们的优化版本，现在我们来使用矩阵分解来构建推荐引擎。</p><h1 id="使用矩阵分解构建一个推荐引擎"><a href="#使用矩阵分解构建一个推荐引擎" class="headerlink" title="使用矩阵分解构建一个推荐引擎"></a>使用矩阵分解构建一个推荐引擎</h1><p>我们首先定义一个函数来预测用户对所有未被他或她评分的所有电影的评分。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MF</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initializing the user-movie rating matrix, no. of latent features, alpha and beta.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, R, K, alpha, beta, iterations)</span>:</span></span><br><span class="line">        self.R = R</span><br><span class="line">        self.num_users, self.num_items = R.shape</span><br><span class="line">        self.K = K</span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        self.beta = beta</span><br><span class="line">        self.iterations = iterations</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initializing user-feature and movie-feature matrix</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.P = np.random.normal(scale=<span class="number">1.</span>/self.K, size=(self.num_users, self.K))</span><br><span class="line">        self.Q = np.random.normal(scale=<span class="number">1.</span>/self.K, size=(self.num_items, self.K))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initializing the bias terms</span></span><br><span class="line">        self.b_u = np.zeros(self.num_users)</span><br><span class="line">        self.b_i = np.zeros(self.num_items)</span><br><span class="line">        self.b = np.mean(self.R[np.where(self.R != <span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># List of training samples</span></span><br><span class="line">        self.samples = [</span><br><span class="line">        (i, j, self.R[i, j])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_users)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.num_items)</span><br><span class="line">        <span class="keyword">if</span> self.R[i, j] &gt; <span class="number">0</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Stochastic gradient descent for given number of iterations</span></span><br><span class="line">        training_process = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.iterations):</span><br><span class="line">        np.random.shuffle(self.samples)</span><br><span class="line">        self.sgd()</span><br><span class="line">        mse = self.mse()</span><br><span class="line">        training_process.append((i, mse))</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Iteration: %d ; error = %.4f"</span> % (i+<span class="number">1</span>, mse))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> training_process</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Computing total mean squared error</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mse</span><span class="params">(self)</span>:</span></span><br><span class="line">        xs, ys = self.R.nonzero()</span><br><span class="line">        predicted = self.full_matrix()</span><br><span class="line">        error = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(xs, ys):</span><br><span class="line">            error += pow(self.R[x, y] - predicted[x, y], <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> np.sqrt(error)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Stochastic gradient descent to get optimized P and Q matrix</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sgd</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, j, r <span class="keyword">in</span> self.samples:</span><br><span class="line">            prediction = self.get_rating(i, j)</span><br><span class="line">            e = (r - prediction)</span><br><span class="line"></span><br><span class="line">            self.b_u[i] += self.alpha * (e - self.beta * self.b_u[i])</span><br><span class="line">            self.b_i[j] += self.alpha * (e - self.beta * self.b_i[j])</span><br><span class="line"></span><br><span class="line">            self.P[i, :] += self.alpha * (e * self.Q[j, :] - self.beta * self.P[i,:])</span><br><span class="line">            self.Q[j, :] += self.alpha * (e * self.P[i, :] - self.beta * self.Q[j,:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ratings for user i and moive j</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_rating</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        prediction = self.b + self.b_u[i] + self.b_i[j] + self.P[i, :].dot(self.Q[j, :].T)</span><br><span class="line">        <span class="keyword">return</span> prediction</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Full user-movie rating matrix</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">full_matrix</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> mf.b + mf.b_u[:,np.newaxis] + mf.b_i[np.newaxis:,] + mf.P.dot(mf.Q.T)</span><br></pre></td></tr></tbody></table></figure><p>现在我们有了一个可以预测评分的函数，这个函数的输入是：</p><ul><li>R-用户-电影评分矩阵</li><li>K-潜在特征的个数</li><li>Alpha-随机梯度下降的学习率</li><li>Beta-正则化参数偏差</li><li>Iterations-执行随机梯度下降的迭代次数</li></ul><p>我们必须将用户-电影评分转换为矩阵形式，在python中使用pivot函数来完成转换。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R= np.array(ratings.pivot(index = <span class="string">'user_id'</span>, columns =<span class="string">'movie_id'</span>, values = <span class="string">'rating'</span>).fillna(<span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure><p>fillna(0)，表示将所有缺失值都用0来填充。现在我们有了R矩阵，可以初始化潜在特征的数量，但是这些特征的数量必须小于或等于原始特征的数量。</p><p>现在我们预测所有的缺失的评分<br></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mf = MF(R, K=<span class="number">20</span>, alpha=<span class="number">0.001</span>, beta=<span class="number">0.01</span>, iterations=<span class="number">100</span>)</span><br><span class="line">training_process = mf.train()</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">"P x Q:"</span>)</span><br><span class="line">print(mf.full_matrix())</span><br><span class="line">print()</span><br></pre></td></tr></tbody></table></figure><p></p><p>下面给我们提供了每20次迭代后的误差值，最后是完整的用户-电影评分矩阵，输出是这样的：</p><p><img alt data-src="Screenshot-from-2018-05-30-10-14-56.png"></p><p>我们已经创建了我们的推荐引擎，接下来我们关注下一节如何评估推荐引擎的性能。</p><h1 id="推荐引擎的评价指标"><a href="#推荐引擎的评价指标" class="headerlink" title="推荐引擎的评价指标"></a>推荐引擎的评价指标</h1><p>为了评估推荐引擎的性能，我们可以使用以下评价指标。</p><h2 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h2><ul><li>实际推荐的电影中，用户喜欢的比例有多少</li><li>公式如下：</li></ul><script type="math/tex; mode=display">\text { Recall } = \frac { tp } { tp + fn }</script><ul><li>这里的tp表示推荐给用户电影中他或她喜欢的数量tp+fn表示他或她喜欢的总数量</li><li>如果一个用户喜欢5个电影而推荐引擎决定显示其中的3个，那么召回率就是0.6</li><li>召回率越大，推荐效果越好</li></ul><h2 id="精确度"><a href="#精确度" class="headerlink" title="精确度"></a>精确度</h2><ul><li>在所有推荐的电影中，用户实际喜欢多少？</li><li>计算公式如下：</li></ul><script type="math/tex; mode=display">\text { Precision } = \frac { tp } { tp + fp }</script><p>这里的tp表示推荐给他/她喜欢的电影数量，tp+fp代表了向用户推荐的全部电影数量。</p><p>如果向用户推荐5部电影，他喜欢其中4部，那么精度将是0.8。</p><p>精度越高，推荐效果越好</p><p>但是考虑一下这样的情况：如果我们简单地推荐所有的电影，它们肯定会覆盖用户喜欢的电影。所以我们有百分之百的召回率！但是仔细考虑一下精确度，如果我们推荐1000部电影，而用户只喜欢其中的10部，那么精确度是0.1%，这真的很低。所以，我们的目标应该是最大化精确度和召回率。</p><h2 id="均方误差（RMSE）"><a href="#均方误差（RMSE）" class="headerlink" title="均方误差（RMSE）"></a>均方误差（RMSE）</h2><p>它衡量的是预测评分中的误差：</p><script type="math/tex; mode=display">RMSE = \sqrt { \frac { \sum _ { i = 1 } ^ { N } \left( \text { Predicted } _ { i } - \text { Actual } _ { i } \right) ^ { 2 } } { N } }</script><p>Predicted 是模型预测的评分，Actual是原始评分</p><p>如果一个用户给一部电影打5分，我们预测它的打分是4，那么RMSE是1。</p><p>RMSE越小，推荐效果越好</p><p>上面的指标告诉我们模型给出的推荐有多准确，但它们并不关注推荐的顺序，也就是说，它们不关注首先推荐的产品，以及之后的顺序。我们还需要一些度量标准，它们需要考虑了推荐产品的顺序。接下来我们来看看一些排名指标（ranking metrics）：</p><h2 id="MRR（Mean-Reciprocal-Rank）"><a href="#MRR（Mean-Reciprocal-Rank）" class="headerlink" title="MRR（Mean Reciprocal Rank）"></a>MRR（Mean Reciprocal Rank）</h2><p>评估推荐的列表</p><script type="math/tex; mode=display">\mathrm { MRR } = \frac { 1 } { \mathrm { n } } \cdot \sum _ { i = 1 } ^ { \mathrm { n } } \frac { 1 } { \mathrm { r } \left( \mathrm { Q } _ { i } \right) }</script><p>假设我们已经向用户推荐了3部电影A，B，C，并且它们顺序是给定的。但是用户只喜欢电影C，因为电影C的等级是3，所以Reciprocal Rank是1/3。</p><p>MRR越大，代表推荐效果越好</p><h2 id="MAP-at-k（Mean-Average-Precision-at-cutoff-k-K位置截止的平均精度均值）"><a href="#MAP-at-k（Mean-Average-Precision-at-cutoff-k-K位置截止的平均精度均值）" class="headerlink" title="MAP at k（Mean Average Precision at cutoff k K位置截止的平均精度均值）"></a>MAP at k（Mean Average Precision at cutoff k K位置截止的平均精度均值）</h2><p>精确度和召回率并不关系推荐中的顺序</p><p>截止k的精度是通过只考虑从1到k推荐的子集来计算的精度</p><script type="math/tex; mode=display">M A P _ { i } = \frac { 1 } { \left| R _ { i } \right| } \sum _ { k = 1 } ^ { \left| R _ { i } \right| } P \left( R _ { i } [ k ] \right)</script><p>假设我们已经给出了三个推荐，[0,1,1]。这里0表示推荐是不正确的，而1表示推荐是正确的。那么k的精度是[0 ,1/2, 2/3]，平均精度是（1/3）*(0+1/2+2/3）=0.38。</p><p>平均精度 越大，推荐的就越准确</p><h2 id="NDCG（Normalized-Discounted-Cumulative-Gain归一化累积折损增益"><a href="#NDCG（Normalized-Discounted-Cumulative-Gain归一化累积折损增益" class="headerlink" title="NDCG（Normalized Discounted Cumulative Gain归一化累积折损增益"></a>NDCG（Normalized Discounted Cumulative Gain归一化累积折损增益</h2><p>MAP和NDCG的主要区别在于，MAP假设物品是感兴趣的（或者不是），而NDCG给出了相关性评分。</p><p>我们通过一个例子来理解它：假设在10部电影中——A到J，我们可以推荐前五部电影，即A、B、C、D和E，而我们不能推荐其他5部电影，也就是F，G，H，I和J，最终推荐是[A B C D]。所以在这个例子中NDCG将是1因为推荐的产品与用户相关。</p><p>NDCG值越大，推荐效果越好</p><h1 id="还可以尝试什么？"><a href="#还可以尝试什么？" class="headerlink" title="还可以尝试什么？"></a>还可以尝试什么？</h1><p>到目前为止，我们已经了解了什么是推荐引擎以及它的不同类型和它们的工作方式。基于内容的过滤和协同过滤算法都有各自的优点和缺点。</p><p>在某些领域，生成对商品的有用描述是非常困难的。如果用户之前的行为没有提供有用的信息，基于内容的推荐模型将不会选择该商品。我们还需要使用额外的技术，以便系统能够在用户已经显示出兴趣的范围之外给出推荐。</p><p>协同过滤模型没有这些缺点。因为不需要对所推荐的商品进行描述，系统可以处理任何类型的信息。此外，它还可以推荐用户以前没有兴趣的产品，但是，如果没有用户对新商品进行评分，那么协同过滤就不能为新商品进行推荐。即使用户开始对该商品进行评分，为了做出准确的推荐，也需要一段时间才能获得足够多的评分来做推荐。</p><p>一个将内容过滤和协同过滤结合起来的系统，可以潜在地从内容的表示和用户的相似性中获得更多信息。将基于内容的推荐和协同过滤的推荐进行加权平均，这是把协同性和基于内容过滤结合起来的一种方法。</p><p>这样做的各种方法有：</p><ul><li>组合商品分数：</li></ul><p>我们把从两种推荐方法中得到的评分组合起来，最简单的方式是取平均值。</p><p>假设有一种方法推荐对一部电影的评分为4，而另一种方法则推荐对同一部电影的评分为5。所以最终的建议是两个评级的平均值，也就是4 .5。</p><p>我们也可以给不同的方法分配不同的权重。</p><ul><li>组合商品排名</li></ul><p>假设协同过滤推荐了5部电影A、B、C、D和E，并且按以下顺序：A、B、C、D、E，而基于内容过滤则按照以下顺序推荐：B、D、A、C、E。</p><p>那么电影的顺序如下所示：</p><ul><li>协同过滤：</li></ul><div class="table-container"><table><thead><tr><th>Movie</th><th>Rank</th></tr></thead><tbody><tr><td>A</td><td>1</td></tr><tr><td>B</td><td>0.8</td></tr><tr><td>C</td><td>0.6</td></tr><tr><td>D</td><td>0.4</td></tr></tbody></table></div><ul><li>基于内容过滤：</li></ul><div class="table-container"><table><thead><tr><th>Movie</th><th>Rank</th></tr></thead><tbody><tr><td>B</td><td>1</td></tr><tr><td>D</td><td>0.8</td></tr><tr><td>A</td><td>0.6</td></tr><tr><td>C</td><td>0.4</td></tr><tr><td>E</td><td>0.2</td></tr></tbody></table></div><p>因此，一个混合推荐引擎将结合这些排名，并根据综合排名做出最终的推荐。合并后的排名是：</p><div class="table-container"><table><thead><tr><th>Movie</th><th>New Rank</th></tr></thead><tbody><tr><td>A</td><td>1+0.6 = 1.6</td></tr><tr><td>B</td><td>0.8+1 = 1.8</td></tr><tr><td>C</td><td>0.6+0.4 = 1</td></tr><tr><td>D</td><td>0.4+0.8 = 1.2</td></tr><tr><td>E</td><td>0.2+0.2 = 0.4</td></tr></tbody></table></div><p>最后的推荐也会基于这个排名，可以看到推荐的顺序会是：B, A, D, C, E。</p><p>通过这种方式，可以将两种或更多的方法组合起来，构建一个混合的推荐引擎，并提高它们的总体推荐精度和效率。</p><h1 id="尾注"><a href="#尾注" class="headerlink" title="尾注"></a>尾注</h1><p>本文全面讲述了有关推荐引擎的内容，如果你想开始推荐引擎方面学习，本文也会是一个很好的帮助。我们不仅讨论了基本的推荐技术，而且还写到了如何实现当今业界的一些更先进的技术。</p><p>我们也针对每种技术联系到对应的现实问题，作为一个想要学习如何制作推荐引擎的人，我建议您学习本教程中讨论的技术，并在您的模型中实现它们。</p><p>你觉得这篇文章有用吗？可以在下方评论分享出你的观点！</p><blockquote><p><strong>Note:</strong> 关于本文:</p><ul><li>本文原文内容英文来源：<a href="https://www.analyticsvidhya.com/blog/2018/06/comprehensive-guide-recommendation-engine-python/" target="_blank" rel="noopener">Comprehensive Guide to build a Recommendation Engine from scratch (in Python)</a></li><li>中文内容引用来源： <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzM4Mjc4MQ==&amp;mid=2652426748&amp;idx=1&amp;sn=c53bf7407de4883a7c1c10c875982ba1&amp;chksm=bd7b99ee8a0c10f85e5ec13f28e188163e0b2735bc1d5b14f7599449730f3be9bad31afba5c3&amp;mpshare=1&amp;scene=24&amp;srcid=#rd" target="_blank" rel="noopener">PPV课数据科学社区</a>.</li><li>傅海林对本文有校对有修改。</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recommender system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机SVM完全笔记</title>
      <link href="/SVM-notebooks/"/>
      <url>/SVM-notebooks/</url>
      
        <content type="html"><![CDATA[<p>支持向量机，因其英文名为support vector machine，故一般简称SVM，通俗来讲，它是一种二分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p><a id="more"></a><h2 id="分类标准的起源：Logistic回归"><a href="#分类标准的起源：Logistic回归" class="headerlink" title="分类标准的起源：Logistic回归"></a>分类标准的起源：Logistic回归</h2><p>理解SVM，咱们必须先弄清楚一个概念：线性分类器。</p><p>给定一些数据点，它们分别属于两个不同的类，现在要找到一个线性分类器把这些数据分成两类。如果用x表示数据点，用y表示类别（y可以取1或者-1，分别代表两个不同的类），一个线性分类器的学习目标便是要在n维的数据空间中找到一个超平面（hyper plane），这个超平面的方程可以表示为（ wT中的T代表转置）：</p><script type="math/tex; mode=display">w^{T}x+b=0</script><p>可能有读者对类别取1或-1有疑问，事实上，这个1或-1的分类标准起源于logistic回归。</p><p>Logistic回归目的是从特征学习出一个0/1分类模型，而这个模型是将特性的线性组合作为自变量，由于自变量的取值范围是负无穷到正无穷。因此，使用logistic函数（或称作sigmoid函数）将自变量映射到(0,1)上，映射后的值被认为是属于y=1的概率。</p><p>假设函数</p><script type="math/tex; mode=display">h_{\theta }=g(\theta ^{T}x)=\frac{1}{1+e^{-\theta ^{T}x}}</script><p>其中x是n维特征向量，函数g就是logistic函数。而 $g(z)=\frac{1}{1 + e^{-z}}$ 的图像是 <img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/logistic.webp"></p><p>SVM 与 LR的优缺点对比：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP资料集中营</title>
      <link href="/NLP-material/"/>
      <url>/NLP-material/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650751755&amp;idx=1&amp;sn=1660877d1ef1d64c81c526dc4f79af31&amp;chksm=871a8775b06d0e63d22b7f542a976dd40fa391b82e0a733ec2eb4fe2157350ae911f318e694e&amp;mpshare=1&amp;scene=1&amp;srcid=#rd" target="_blank" rel="noopener">机器之心：254页PPT！这是一份写给NLP研究者的编程指南</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——Attentional Factorization Machines(AFM)</title>
      <link href="/Attentional-Factorization-Machines-AFM/"/>
      <url>/Attentional-Factorization-Machines-AFM/</url>
      
        <content type="html"><![CDATA[<p>References:<br><a href="https://zhuanlan.zhihu.com/p/38517948" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38517948</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——Neural Factorization Machines(NFM)</title>
      <link href="/Neural-Factorization-Machines-NFM/"/>
      <url>/Neural-Factorization-Machines-NFM/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——Product-based Neural Network(PNN)</title>
      <link href="/Product-based-Neural-Network-PNN/"/>
      <url>/Product-based-Neural-Network-PNN/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——GBDT+LR</title>
      <link href="/GBDT-LR/"/>
      <url>/GBDT-LR/</url>
      
        <content type="html"><![CDATA[<h1 id="1、-背景"><a href="#1、-背景" class="headerlink" title="1、 背景"></a>1、 背景</h1><pre><code>  CTR预估（Click-Through Rate Prediction）是互联网计算广告中的关键环节，预估准确性直接影响公司广告收入。CTR预估中用的最多的模型是LR（Logistic Regression），LR是广义线性模型，与传统线性模型相比，LR使用了Logit变换将函数值映射到0~1区间，映射后的函数值就是CTR的预估值。LR这种线性模型很容易并行化，处理上亿条训练样本不是问题，但线性模型学习能力有限，需要大量特征工程预先分析出有效的特征、特征组合，从而去间接增强LR的非线性学习能力。  LR模型中的特征组合很关键， 但又无法直接通过特征笛卡尔积解决，只能依靠人工经验，耗时耗力同时并不一定会带来效果提升。如何自动发现有效的特征、特征组合，弥补人工经验不足，缩短LR特征实验周期，是亟需解决的问题。Facebook 2014年的文章介绍了通过GBDT（Gradient Boost Decision Tree）解决LR的特征组合问题[^1]，随后Kaggle竞赛也有实践此思路[4][5]，GBDT与LR融合开始引起了业界关注。  GBDT（Gradient Boost Decision Tree）是一种常用的非线性模型，它基于集成学习中的boosting思想，每次迭代都在减少残差的梯度方向新建立一颗决策树，迭代多少次就会生成多少颗决策树。GBDT的思想使其具有天然优势可以发现多种有区分性的特征以及特征组合，决策树的路径可以直接作为LR输入特征使用，省去了人工寻找特征、特征组合的步骤。这种通过GBDT生成LR特征的方式（GBDT+LR），业界已有实践（Facebook，Kaggle-2014），且效果不错，是非常值得尝试的思路。下图1为使用GBDT+LR前后的特征实验示意图，融合前人工寻找有区分性特征（raw feature）、特征组合（cross feature），融合后直接通过黑盒子（Tree模型GBDT）进行特征、特种组合的自动发现。</code></pre><a id="more"></a><p>推荐系统CTR实战系列：</p><ol><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94FM/">推荐系统CTR实战——FM</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94FFM/">推荐系统CTR实战——FFM</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94DeepFM/">推荐系统CTR实战——DeepFM</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Wide-Deep/">推荐系统CTR实战——Wide &amp; Deep</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Deep-Cross/">推荐系统CTR实战——Deep &amp; Cross</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Deep-Interest-Network/">推荐系统CTR实战——Deep Interest Network</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94GBDT-LR/">推荐系统CTR实战——GBDT+LR</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94xDeepFM/">推荐系统CTR实战——xDeepFM</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Product-based-Neural-Network-PNN/">推荐系统CTR实战——Product-based Neural Network(PNN)</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Neural-Factorization-Machines-NFM/">推荐系统CTR实战——Neural Factorization Machines(NFM)</a></li><li><a href="https://fuhailin.github.io/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9FCTR%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94Attentional-Factorization-Machines-AFM/">推荐系统CTR实战——Attentional Factorization Machines(AFM)</a></li></ol><p><strong>首先祭出推荐系统CTR实战——GBDT+LR Demo的Python实现代码：</strong><br><em><a href="https://github.com/fuhailin/DeepRec/tree/master/GBDT%2BLR" target="_blank" rel="noopener">https://github.com/fuhailin/DeepRec/tree/master/GBDT%2BLR</a></em></p><h1 id="GBDT与LR融合现状"><a href="#GBDT与LR融合现状" class="headerlink" title="GBDT与LR融合现状"></a>GBDT与LR融合现状</h1><p>GBDT和LR的融合方案，FaceBook的paper中有个例子：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20150827190225375"><br>图中Tree1、Tree2为通过GBDT模型学出来的两颗树，x为一条输入样本，遍历两棵树后，x样本分别落到两颗树的叶子节点上，每个叶子节点对应LR一维特征，那么通过遍历树，就得到了该样本对应的所有LR特征。由于树的每条路径，是通过最小化均方差等方法最终分割出来的有区分性路径，根据该路径得到的特征、特征组合都相对有区分性，效果理论上不会亚于人工经验的处理方式。</p><p>GBDT模型的特点，非常适合用来挖掘有效的特征、特征组合。业界不仅GBDT+LR融合有实践，GBDT+FM也有实践，2014 Kaggle CTR竞赛冠军就是使用GBDT+FM，可见，使用GBDT融合其它模型是非常值得尝试的思路。</p><p>调研了Facebook、Kaggle竞赛关于GBDT建树的细节，发现两个关键点：采用ensemble决策树而非单颗树；建树采用GBDT而非RF（Random Forests）。解读如下：</p><pre><code>  1） 为什么建树采用ensemble决策树？  一棵树的表达能力很弱，不足以表达多个有区分性的特征组合，多棵树的表达能力更强一些。GBDT每棵树都在  学习前面棵树尚存的不足，迭代多少次就会生成多少颗树。按paper以及Kaggle竞赛中的GBDT+LR融合方式，  多棵树正好满足LR每条训练样本可以通过GBDT映射成多个特征的需求。  2） 为什么建树采用GBDT而非RF？  RF也是多棵树，但从效果上有实践证明不如GBDT。且GBDT前面的树，特征分裂主要体现对多数样本有区分度的特征；后面的树，  主要体现的是经过前N颗树，残差仍然较大的少数样本。优先选用在整体上有区分度的特征，再选用针对少数样本有区分度的特征，  思路更加合理，这应该也是用GBDT的原因。</code></pre><p>然而，Facebook和Kaggle竞赛的思路是否能直接满足现在CTR预估场景呢？</p><p>按照Facebook、Kaggle竞赛的思路，不加入广告侧的ADID特征？但是现CTR预估中，AD ID类特征是很重要的特征，故建树时需要考虑AD ID。直接将AD ID加入到建树的feature中？但是AD ID过多，直接将AD ID作为feature进行建树不可行。下面第三部分将介绍针对现有CTR预估场景GBDT+LR的融合方案。</p><h1 id="GBDT与LR融合方案"><a href="#GBDT与LR融合方案" class="headerlink" title="GBDT与LR融合方案"></a>GBDT与LR融合方案</h1><p>AD ID类特征在CTR预估中是非常重要的特征，直接将AD ID作为feature进行建树不可行，顾考虑为每个AD ID建GBDT树。但互联网时代长尾数据现象非常显著，广告也存在长尾现象，为了提升广告整体投放效果，不得不考虑<strong>长尾广告</strong>。在GBDT建树方案中，对于曝光充分训练样本充足的广告，可以单独建树，发掘对单个广告有区分度的特征，但对于曝光不充分样本不充足的长尾广告，无法单独建树，需要一种方案来解决长尾广告的问题。</p><p>综合考虑方案如下，<strong>使用GBDT建两类树，非ID建一类树，ID建一类树</strong>。1）非ID类树：不以细粒度的ID建树，此类树作为base，即便曝光少的广告、广告主，仍可以通过此类树得到有区分性的特征、特征组合。2）ID类树：以细粒度的ID建一类树，用于发现曝光充分的ID对应有区分性的特征、特征组合。</p><p>如何根据GBDT建的两类树，对原始特征进行映射？以如下图为例，当一条样本x进来之后，遍历两类树到叶子节点，得到的特征作为LR的输入。当AD曝光不充分不足以训练树时，其它树恰好作为补充。</p><p><img alt data-src="https://raw.githubusercontent.com/PnYuan/Practice-of-Machine-Learning/master/imgs/Kaggle_CTR/gbdt-lr/gbdt-lr_ad-id.png"></p><h1 id="总结GBDT-LR方案的好处如下："><a href="#总结GBDT-LR方案的好处如下：" class="headerlink" title="总结GBDT-LR方案的好处如下："></a>总结GBDT-LR方案的好处如下：</h1><ul><li>GBDT作为一种Boosting集成模型，其建模过程以残差拟合为目的，相应的数据信息学习也是从主体到细节（到噪声）。于是，对于GBDT序列化的子模型，其叶节点索引所对应的新特征的重要性是递减的，这事实上为我们提供了一套特征排序</li><li>GBDT实现了显示的特征转换，通过设置合理的子模型数量，既保留数据主体信息，又控制特征空间维度，提高数据效用和训练效率；</li><li>在广告推荐中，广告ID是一个易被忽略的重要特征。采用GBDT-LR的方案可将其很好的利用起来。一般而言，ID取值多且呈现长尾分布，常用作法是对一些大广告（曝光充分，样本充足）建立专属GBDT，其它构建共用GBDT，其思路如下图示：</li></ul><p><strong>Refenences</strong></p><blockquote id="fn_1"><sup>1</sup>. <a href="http://quinonero.net/Publications/predicting-clicks-facebook.pdf" target="_blank" rel="noopener">Practical Lessons from Predicting Clicks on Ads at Facebook</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://github.com/duboya/CTR-Prediction/tree/46c303986ec57092d9eb4478a3583fa019d18efd/Algorithm%20Practice/GBDT%20%2B%20LR" target="_blank" rel="noopener">duboya/CTR-Prediction|Github</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> ↩</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://pnyuan.github.io/blog/ml_practice/Kaggle%E6%BB%91%E6%B0%B4%20-%20CTR%E9%A2%84%E4%BC%B0%EF%BC%88GBDT-LR%EF%BC%89/" target="_blank" rel="noopener">Kaggle滑水 - CTR预估（GBDT-LR）</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> ↩</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://www.itread01.com/content/1546797307.html" target="_blank" rel="noopener">Practical Lessons from Predicting Clicks on Ads at Facebook (GBDT + LR) 模型實踐</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> ↩</a></blockquote><blockquote id="fn_5"><sup>5</sup>. <a href="https://blog.csdn.net/lilyth_lilyth/article/details/48032119" target="_blank" rel="noopener">CTR预估中GBDT与LR融合方案|CSDN</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> ↩</a></blockquote><blockquote id="fn_6"><sup>6</sup>. <a href="https://www.jianshu.com/p/96173f2c2fb4" target="_blank" rel="noopener">推荐系统遇上深度学习(十)—GBDT+LR融合方案实战|简书</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> ↩</a></blockquote><blockquote id="fn_7"><sup>7</sup>. <a href="https://www.cnblogs.com/wkang/p/9657032.html" target="_blank" rel="noopener">GBDT+LR算法解析及Python实现</a><a href="#reffn_7" title="Jump back to footnote [7] in the text."> ↩</a></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——xDeepFM</title>
      <link href="/xDeepFM/"/>
      <url>/xDeepFM/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——Wide &amp; Deep</title>
      <link href="/Wide-Deep/"/>
      <url>/Wide-Deep/</url>
      
        <content type="html"><![CDATA[<p>Wide &amp; Deep模型结构如下：<br><img alt="Wide &amp; Deep Network" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/wide_and_deep.webp"><br>最左边的线性模型和最右边的深度模型联手结盟打造出中间的wide and deep。</p><p>Wide &amp; Deep的主要特点:<br>本文提出Wide &amp; Deep模型，旨在使得训练得到的模型能够同时获得记忆（memorization）和泛化（generalization）能力：</p><ul><li><strong>记忆（memorization）即从历史数据中发现item或者特征之间的相关性；哪些特征更重要——Wide部分</strong>。</li><li><strong>泛化（generalization）即相关性的传递，发现在历史数据中很少或者没有出现的新的特征组合；——Deep部分</strong>。<br>在推荐系统中，记忆体现的准确性，而泛化体现的是新颖性。</li></ul><h2 id="Wide部分"><a href="#Wide部分" class="headerlink" title="Wide部分"></a>Wide部分</h2><p>wide部分就是一个广义线性模型，输入主要由两部分，一部分是原始特征，另一部分是交互特征，我们可以通过cross-product transformation的形式来构造K组交互特征：</p><script type="math/tex; mode=display">\phi _ { k } ( \mathbf { x } ) = \prod _ { i = 1 } ^ { d } x _ { i } ^ { c _ { k i } } \quad c _ { k i } \in \{ 0,1 \}</script><h2 id="Deep部分"><a href="#Deep部分" class="headerlink" title="Deep部分"></a>Deep部分</h2><p>Deep部分就是一个DNN的模型，每一层计算如下：</p><script type="math/tex; mode=display">a ^ { ( l + 1 ) } = f \left( W ^ { ( l ) } a ^ { ( l ) } + b ^ { ( l ) } \right)</script><h2 id="联合训练"><a href="#联合训练" class="headerlink" title="联合训练"></a>联合训练</h2><p>Wide &amp; Deep模型采用的是联合训练的形式，而非集成。二者的区别就是联合训练公用一个损失函数，然后同时更新各个部分的参数，而集成方法是独立训练N个模型，然后进行融合。因此，模型的输出为：</p><script type="math/tex; mode=display">P ( Y = 1 | \mathbf { x } ) = \sigma \left( \mathbf { w } _ { w i d e } ^ { T } [ \mathbf { x } , \phi ( \mathbf { x } ) ] + \mathbf { w } _ { d e e p } ^ { T } a ^ { \left( l _ { f } \right) } + b \right)</script><h2 id="使用Wide-and-Deep模型的App推荐系统架构"><a href="#使用Wide-and-Deep模型的App推荐系统架构" class="headerlink" title="使用Wide and Deep模型的App推荐系统架构"></a>使用Wide and Deep模型的App推荐系统架构</h2><p>当一个用户访问app商店时，此时会产生一个请求，请求到达推荐系统后，推荐系统为该用户返回推荐的apps列表。<br><img alt data-src="/https://gitee.com/fuhailin/Object-Storage-Service/raw/master/wide_and_deep_overview.png"><br>在实际的推荐系统中，通常将推荐的过程分为两个部分，即上图中的Retrieval和Ranking，Retrieval负责从数据库中检索出与用户相关的一些apps，Ranking负责对这些检索出的apps打分，最终，按照分数的高低返回相应的列表给用户。</p><p>模型的训练之前，最重要的工作是训练数据的准备以及特征的选择，在apps推荐中，可以使用到的数据包括用户和曝光数据。<br>每一条样本对应了一条曝光数据，同时，样本的标签为1表示安装，0则表示未安装。</p><p>对于类别特征，通过词典（Vocabularies）将其映射成向量；对于连续的实数特征，将其归一化到区间[0,1]。</p><p><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/wide_and_deep_structure.png"></p><h2 id="TensorFlow官方实现代码"><a href="#TensorFlow官方实现代码" class="headerlink" title="TensorFlow官方实现代码"></a>TensorFlow官方实现代码</h2><p><a href="https://github.com/tensorflow/models/tree/master/official/wide_deep" target="_blank" rel="noopener">https://github.com/tensorflow/models/tree/master/official/wide_deep</a></p><p><strong>References</strong>:</p><ol><li>Cheng H T, Koc L, Harmsen J, et al. Wide &amp; Deep Learning for Recommender Systems[J]. 2016:7-10.</li><li><a href="https://www.jianshu.com/p/71cf3d1f579d" target="_blank" rel="noopener">Wide and Deep,双剑合璧</a></li><li>[Wide &amp; Deep | Ryan_Fan’s Blog]<a href="http://blog.leanote.com/post/ryan_fan/wide-and-deep-Model" target="_blank" rel="noopener">http://blog.leanote.com/post/ryan_fan/wide-and-deep-Model</a><!-- 4. --></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——FFM</title>
      <link href="/FFM/"/>
      <url>/FFM/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——FM</title>
      <link href="/FM/"/>
      <url>/FM/</url>
      
        <content type="html"><![CDATA[<p>FM主要目标是：<strong><code>解决数据稀疏的情况下，特征怎样组合的问题</code></strong></p><a id="more"></a><p>FM有一下三个优点：</p><ol><li>可以在非常稀疏的数据中进行合理的参数估计</li><li>FM模型的时间复杂度是线性的</li><li>FM是一个通用模型，它可以用于任何特征为实值的情况</li></ol><p>假设样本中有$n$个特征，对特征$\mathbf{x}$，FM的输出 $\hat{y}$ 为：</p><script type="math/tex; mode=display">\hat { y } ( \mathbf {x} ) : = w_{0} + \sum _ {i=1}^{n} w_{i} x_{i} + \sum _ {i=1}^{n} \sum _ {j=i+1}^{n} \left\langle \mathbf {v}_{i} , \mathbf {v} _ {j} \right\rangle x_{i} x_{j}</script><p>其中：</p><script type="math/tex; mode=display">\left\langle \mathbf { v } _ { i } , \mathbf { v } _ { j } \right\rangle : = \sum _ { f = 1 } ^ { k } v _ { i , f } \cdot v _ { j , f }</script><p>可以看到为了得到$\hat{y}$，会有两层循环，这个形式的时间复杂度为</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=i+1}^n<V_i,V_j> x_ix_j=\frac{1}{2}\sum_{f=1}^{k}((\sum_{i=1}^nv_{if}x_i)(\sum_{j=1}^nv_{jf}x_j) - \sum_{i=1}^nv_{if}^2x_i^2)</script><blockquote id="fn_7"><sup>7</sup>. <a href="https://www.cnblogs.com/wkang/p/9588360.html" target="_blank" rel="noopener">FM算法解析及Python实现</a><a href="#reffn_7" title="Jump back to footnote [7] in the text."> ↩</a></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——DeepFM</title>
      <link href="/DeepFM/"/>
      <url>/DeepFM/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——Deep Interest Network</title>
      <link href="/Deep-Interest-Network/"/>
      <url>/Deep-Interest-Network/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统CTR实战——Deep &amp; Cross</title>
      <link href="/Deep-and-Cross-Network/"/>
      <url>/Deep-and-Cross-Network/</url>
      
        <content type="html"><![CDATA[<p>特征工程一直是很多预测模型效果突出的关键，许多有效的特征都来自于原始特征的交叉组合，传统特征工程寻找有效交叉特征往往要耗费大量精力。比如，在Wide&amp;Deep中，wide侧的交叉组合特征依然需要依靠hand-craft来完成；而FM虽然可以自动进行特征交叉，但也只限于二阶交叉。本文提出了一种交叉的网络结构的深度学习模型DCN，Deep &amp; Cross Network，能对sparse和dense的输入自动学习特征交叉，可以有效地捕获有限阶（bounded degrees）上的有效特征交叉，无需人工特征工程或暴力搜索（exhaustive searching），并且计算代价较低。，在CTR预估方面可以取得较好的效果。</p><p>Deep&amp;Cross的主要特点:</p><ol><li><strong>自动提取交叉组合特征，并不需要人为设计复杂的的特征工程</strong>；</li><li><strong>交叉网络（DCN）在LogLoss上与DNN相比少了近一个量级的参数量，所以模型更小</strong>。</li></ol><hr><h1 id="DCN网络结构"><a href="#DCN网络结构" class="headerlink" title="DCN网络结构"></a>DCN网络结构</h1><p>DCN模型以一个嵌入和堆叠层(embedding and stacking layer)开始，接着并列连一个cross network和一个deep network，接着通过一个combination layer将两个network的输出进行组合。</p><p>整体网络结构如下:</p><p><img width="70%" height="70%" title="The Deep &amp; Cross Network." alt="The Deep &amp; Cross Network." data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/DCN.png"></p><h2 id="Embedding-and-Stacking-Layer"><a href="#Embedding-and-Stacking-Layer" class="headerlink" title="Embedding and Stacking Layer"></a>Embedding and Stacking Layer</h2><p>在大规模推荐系统中，如CTR预测，通常会有大量的类别特征需要处理，如“country=usa”。为了将这些信息变成计算机能处理的特征，通常使用one_hot编码处理成独热向量如“[ 0,1,0 ]”；然而，这些大量的词汇往往导致处理后的特征空间维度过高。</p><p>为了减少维数，一种常用的做法是采用嵌入过程将这些离散特征转换成实数值的稠密向量（通常称为嵌入向量）：</p><script type="math/tex; mode=display">\mathbf { x } _ { \text { embed, } i } = W _ { \text { embed } , i } \mathbf { x } _ { i }</script><p>其中<script type="math/tex">x_{embed,i}</script>是embedding vector，<script type="math/tex">x_i</script>是第i个category的二元输入，<script type="math/tex">W_{embed,i} \in R^{n_e \times n_v}</script>是对应的embedding matrix，会与网络中的其它参数一起进行优化，$n_e$, $n_v$分别是embedding size和vocabulary size。</p><p>然后，我们将嵌入向量与连续特征向量叠加起来形成一个向量：</p><script type="math/tex; mode=display">x_0 = [ x_{embed,1}^T, ..., X_{embed,k}^T, X_{dense}^T]。</script><p>拼接起来的向量$X0$将作为我们Cross Network和Deep Network的输入.</p><p>这一部分在tensorflow中，使用tf.feature_columnAPI可以很容易实现，大致代码结构如下：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">embed0 = tf.feature_column.embedding_column(...)</span><br><span class="line">...</span><br><span class="line">dense0 = tf.feature_column.indicator_column(...)</span><br><span class="line">dense1 = tf.feature_column.numeric_column(...)</span><br><span class="line">...</span><br><span class="line">columns = [embed0, ..., dense0, dense1, ...]</span><br><span class="line">x0 = tf.feature_column.input_layer(features, feature_columns)</span><br></pre></td></tr></tbody></table></figure><h2 id="Cross-Network"><a href="#Cross-Network" class="headerlink" title="Cross Network"></a>Cross Network</h2><p>在广告场景下，特征交叉的组合与点击率是有显著相关的，例如，“USA”与“Thanksgiving”、“China”与“Chinese New Year”这样的关联特征，对用户的点击有着正向的影响。换句话说，来自“China”的用户很可能会在“Chinese New Year”有大量的浏览、购买行为，而在“Thanksgiving”却不会有特别的消费行为。这种关联特征与label的正向相关性在实际问题中是普遍存在的，如“化妆品”类商品与“女性”，“球类运动配件”的商品与“男性”，“电影票”的商品与“电影”品类偏好等。因此，引入特征的组合是非常有意义的。而这部分正是FM存在的意义。</p><p>DCN的特点之一就在于提出了一个创新的结构来计算组合特征：<br><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/cross_layer.webp"></p><p>交叉网络的核心思想是以有效的方式应用显式特征交叉。交叉网络由交叉层组成，每个层具有以下公式：</p><script type="math/tex; mode=display">x_{l+1} = x_0 x_l^T w_l + b_l + x_l = f(x_l, w_l, b_l) + x_l</script><p>其中:</p><ul><li><script type="math/tex">x_l,x_{l+1}</script>是列向量（column vectors），分别表示来自第l层和第(l+1)层cross layers的输出；</li><li>$w_l, b_l \in R^d$是第l层layer的weight和bias参数。</li></ul><p>可以看到，交叉网络的特殊结构使交叉特征的程度随着层深度的增加而增大。多项式的最高程度（就输入X0而言）为L层交叉网络L + 1。如果用Lc表示交叉层数，d表示输入维度。然后，参数的数量参与跨网络参数为：d <em> Lc </em> 2 (w和b).</p><p>在完成一个特征交叉f后，每个cross layer会将它的输入加回去，对应的mapping function $f：R^d \rightarrow R^d$，刚好等于残差$x_{l+1} - x_l$，这里借鉴了残差网络的思想。这种方式有两个好处：</p><ul><li>通过拟合残差的方式，提高权重的敏感度，更适合稀疏的输入。</li><li>方便网络整体的反向传播，提高网络训练效率。</li></ul><p>ResNet的原理，参见笔记：<a href="http://leanote.com/s/5b0eaf5a7968705f10000002" target="_blank" rel="noopener">http://leanote.com/s/5b0eaf5a7968705f10000002</a></p><h2 id="Deep-Network"><a href="#Deep-Network" class="headerlink" title="Deep Network"></a>Deep Network</h2><p>深度网络就是一个全连接的前馈神经网络，每个深度层具有如下公式：</p><script type="math/tex; mode=display">h _ { l + 1 } = f \left( W _ { l } h _ { l } + b _ { l } \right)</script><p>和传统DNN一样，input进来，简单的N层full-connected layer的叠加，所以参数量主要还是在deep侧。<br>参数数量为：$d∗m+m+(m2+m)∗(Ld−1)$<br>L_d denote the number of deep layers, m denote the deep layer size, d denote the input dimension.<br>Output</p><h2 id="Combination-Layer"><a href="#Combination-Layer" class="headerlink" title="Combination Layer"></a>Combination Layer</h2><p>将Cross layer和Deep layer两个并行网络出来的输出做一次concat，对于多分类问题，过一个softmax就OK了。</p><p>链接层将两个并行网络的输出连接起来，经过一层激活函数得到输出：</p><script type="math/tex; mode=display">p = \sigma \left( \left[ \mathbf { x } _ { L _ { 1 } } ^ { T } , \mathbf { h } _ { L _ { 2 } } ^ { T } \right] \mathbf { w } _ { \operatorname { logits } } \right)</script><p>如果是二分类就是$sigmoid$激活函数，损失函数可用$logloss$，多分类就是$softmax$.</p><h2 id="TensorFlow实现代码"><a href="#TensorFlow实现代码" class="headerlink" title="TensorFlow实现代码"></a>TensorFlow实现代码</h2><p><a href="https://github.com/RyanDeepLearning/Deep-Cross-Net" target="_blank" rel="noopener">https://github.com/RyanDeepLearning/Deep-Cross-Net</a></p><p><strong>References</strong>:</p><ol><li><a href="https://arxiv.org/pdf/1708.05123.pdf" target="_blank" rel="noopener">DEEP &amp; CROSS NETWORK FOR AD CLICK PREDICTIONS</a></li><li><a href="https://zhuanlan.zhihu.com/p/38461541" target="_blank" rel="noopener">Deep &amp; Cross 与广告不得不说的秘密</a></li><li><a href="http://blog.leanote.com/post/ryan_fan/Deep-Cross-Network" target="_blank" rel="noopener">http://blog.leanote.com/post/ryan_fan/Deep-Cross-Network</a></li><li><a href="https://www.jiqizhixin.com/articles/2018-07-16-17" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2018-07-16-17</a></li><li><a href="https://yangxudong.github.io/dcn/" target="_blank" rel="noopener">距离玩转企业级DCN(Deep &amp; Cross Network)模型，你只差一步|小毛驴</a></li><li><a href="https://www.jianshu.com/p/77719fc252fa" target="_blank" rel="noopener">推荐系统遇上深度学习(五)—Deep&amp;Cross Network模型理论和实践|石晓文的学习日记</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTR </tag>
            
            <tag> Recommender system </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【剑指Offer】24. 二叉搜索树的后序遍历</title>
      <link href="/offer24-Binary-searchtree/"/>
      <url>/offer24-Binary-searchtree/</url>
      
        <content type="html"><![CDATA[<p>题目描述：<br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p>思路：<br>1、序列的的最后一个数字是根节点<br>2、二叉搜索树左子树的节点都比根节点小，右子树的节点都比根节点大。<br><img alt="在这里插入图片描述" data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20181020211958624.png"></p><a id="more"></a><p>C++递归与非递归实现代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//参数为引用，不为值传递是为了防止拷贝构造函数的无限递归，最终导致栈溢出。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sequence, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (left == right)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> mid = left;</span><br><span class="line"><span class="keyword">while</span> (sequence[mid] &lt; sequence[right] &amp;&amp; mid &lt; right)</span><br><span class="line">{</span><br><span class="line">mid++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> tmp = mid;</span><br><span class="line"><span class="keyword">while</span> (sequence[tmp] &gt; sequence[right] &amp;&amp; tmp &lt; right)</span><br><span class="line">{</span><br><span class="line">tmp++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; right)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (mid == left || mid == right)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> judge(sequence, left, right - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> judge(sequence, left, mid - <span class="number">1</span>) &amp;&amp; judge(sequence, mid, right - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> size = sequence.size();</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == size)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (--size)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (sequence[i] &lt; sequence[size])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//while (sequence[i++] &lt; sequence[size]);</span></span><br><span class="line"><span class="comment">//while (sequence[i++] &gt; sequence[size]);</span></span><br><span class="line"><span class="keyword">while</span> (sequence[i] &gt; sequence[size])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; size)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBSTRecursize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> length = sequence.size();</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> judge(sequence, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree1{<span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>};</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree2{<span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">14</span>, <span class="number">10</span>};</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree3{<span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>};</span><br><span class="line">Solution solution = Solution();</span><br><span class="line"><span class="keyword">bool</span> tmp = solution.VerifySquenceOfBST(tree3);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Hexo博客搭建过程与扩展功能记录</title>
      <link href="/Hello-Hexo/"/>
      <url>/Hello-Hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is a guide post to use Hexo. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for<br>more info. If you get any problems when using Hexo, you can find the answer in<br><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on<br><a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h2 id="How-to-use-Hexo-and-deploy-to-GitHub-Pages"><a href="#How-to-use-Hexo-and-deploy-to-GitHub-Pages" class="headerlink" title="How to use Hexo and deploy to GitHub Pages"></a>How to use Hexo and deploy to GitHub Pages</h2><ul><li><a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></li><li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li></ul><h3 id="1-Install-Hexo"><a href="#1-Install-Hexo" class="headerlink" title="1. Install Hexo"></a>1. Install Hexo</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">$ hexo -v</span><br><span class="line">hexo-cli: 0.1.9</span><br><span class="line">os: Darwin 14.3.0 darwin x64</span><br><span class="line">http_parser: 2.3</span><br><span class="line">node: 0.12.7</span><br><span class="line">v8: 3.28.71.19</span><br><span class="line">uv: 1.6.1</span><br><span class="line">zlib: 1.2.8</span><br><span class="line">modules: 14</span><br><span class="line">openssl: 1.0.1p</span><br></pre></td></tr></tbody></table></figure><h3 id="2-Create-a-project-for-your-GitHub-Pages"><a href="#2-Create-a-project-for-your-GitHub-Pages" class="headerlink" title="2. Create a project for your GitHub Pages"></a>2. Create a project for your GitHub Pages</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init fuhailin.github.io</span><br><span class="line">INFO  Copying data to ~/***/fuhailin.github.io</span><br><span class="line">INFO  You are almost <span class="keyword">done</span>! Don<span class="string">'t forget to run '</span>npm install<span class="string">' before you start blogging with Hexo!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ cd fuhailin.github.io</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ npm install</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-Run-a-test-server-for-your-page-on-Mac"><a href="#3-Run-a-test-server-for-your-page-on-Mac" class="headerlink" title="3. Run a test server for your page on Mac"></a>3. Run a test server for your page on Mac</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br><span class="line"></span><br><span class="line">hexo s --draft  # 预览Draft</span><br></pre></td></tr></tbody></table></figure><h3 id="4-Set-information-for-your-new-blog"><a href="#4-Set-information-for-your-new-blog" class="headerlink" title="4. Set information for your new blog"></a>4. Set information for your new blog</h3><p><a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">https://hexo.io/docs/configuration.html</a><br></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vi</span> <span class="string">_config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~</span> <span class="string">_config.yml</span> <span class="string">~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">fuhailin's</span> <span class="string">note</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">fuhailin's</span> <span class="string">personal</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">fuhailin</span></span><br><span class="line"><span class="attr">language:</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Japan</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://fuhailin.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="5-Set-information-to-use-Git"><a href="#5-Set-information-to-use-Git" class="headerlink" title="5. Set information to use Git"></a>5. Set information to use Git</h3><p><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">https://github.com/hexojs/hexo-deployer-git</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ vi _config.yml</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~ _config.yml ~~~~~~~~~~~~~~~~~~</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: http://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">    repo: git@github.com:fuhailin/fuhailin.github.io.git</span><br><span class="line">      branch: master</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="6-Set-“watch”-before-starting-your-work"><a href="#6-Set-“watch”-before-starting-your-work" class="headerlink" title="6. Set “watch” before starting your work"></a>6. Set “watch” before starting your work</h3><p>“watch” command can monitor your files.<br><a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">https://hexo.io/docs/generating.html</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --watch</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="7-Create-a-new-post-file"><a href="#7-Create-a-new-post-file" class="headerlink" title="7. Create a new post file"></a>7. Create a new post file</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new first-post</span><br><span class="line">INFO  Created: ~/***/fuhailin.github.io/source/_posts/first-post.md</span><br></pre></td></tr></tbody></table></figure><h3 id="8-Edit-the-above-file-with-Markdown-or-Hexo’s-Helper"><a href="#8-Edit-the-above-file-with-Markdown-or-Hexo’s-Helper" class="headerlink" title="8. Edit the above file with Markdown or Hexo’s Helper"></a>8. Edit the above file with Markdown or Hexo’s Helper</h3><p>Hexo’s Helper<br><a href="https://hexo.io/docs/helpers.html" target="_blank" rel="noopener">https://hexo.io/docs/helpers.html</a><br>I use Atom with “shift + control + m” when I use Markdown :-)<br><a href="https://atom.io/" target="_blank" rel="noopener">https://atom.io/</a></p><h3 id="9-Delete-“source-posts-hello-world-md”"><a href="#9-Delete-“source-posts-hello-world-md”" class="headerlink" title="9. Delete “source/_posts/hello-world.md”"></a>9. Delete “source/_posts/hello-world.md”</h3><p>It’s not necessary to deploy.</p><h3 id="10-Deploy-your-new-blog"><a href="#10-Deploy-your-new-blog" class="headerlink" title="10. Deploy your new blog!!"></a>10. Deploy your new blog!!</h3><p><a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p></p><p>After writting the above command, you can see your new blog on GitHub Pages.<br><a href="http://******.github.io/" target="_blank" rel="noopener">http://******.github.io/</a></p><h3 id="11-Change-your-blog-theme"><a href="#11-Change-your-blog-theme" class="headerlink" title="11. Change your blog theme"></a>11. Change your blog theme</h3><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">For instance, How to use the following theme.</span><br><span class="line">https://hexo.io/hexo-theme-light/</span><br><span class="line"></span><br><span class="line">## Install it</span><br><span class="line">$ cd fuhailin.github.io</span><br><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line">## Update the above files</span><br><span class="line">$ themes/light</span><br><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line">## Set information to use the theme</span><br><span class="line">$ cd fuhailin.github.io</span><br><span class="line">$ vi _config.yml</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~ _config.yml ~~~~~~~~~~~~~~~~~~</span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">## Themes: http://hexo.io/themes/</span><br><span class="line">theme: light</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="12-Create-a-new-page-file"><a href="#12-Create-a-new-page-file" class="headerlink" title="12. Create a new page file"></a>12. Create a new page file</h3><p><a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">https://hexo.io/docs/writing.html</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page aboutme</span><br><span class="line">INFO  Created: ~/***/fuhailin.github.io/source/aboutme/index.md</span><br><span class="line"></span><br><span class="line">$ cd source/aboutme/</span><br><span class="line"></span><br><span class="line">$ vi index.md</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="13-Use-“Read-More”"><a href="#13-Use-“Read-More”" class="headerlink" title="13. Use “Read More”"></a>13. Use “Read More”</h3><p>Write <code>&lt;!-- more --&gt;</code> in your articles.</p><h3 id="14-Use-Plugins"><a href="#14-Use-Plugins" class="headerlink" title="14. Use Plugins"></a>14. Use Plugins</h3><p><a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Plugins</a></p><h2 id="为blog添加评论区"><a href="#为blog添加评论区" class="headerlink" title="为blog添加评论区"></a>为blog添加评论区</h2><p>hexo添加gitment评论系统：<br><a href="http://kuring.me/post/gitment/" target="_blank" rel="noopener">http://kuring.me/post/gitment/</a></p><h2 id="给-Github-添加-README"><a href="#给-Github-添加-README" class="headerlink" title="给 Github 添加 README"></a>给 Github 添加 README</h2><p>默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source<br>目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。<br>正确的解决方法其实很简单：<br>把 README.md 文件的后缀名改成 “MDOWN” 然后扔到<code>blog/source</code>文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD<br>文件解析。<br><a href="https://neveryu.github.io/2016/09/30/hexo-next-two/" target="_blank" rel="noopener">https://neveryu.github.io/2016/09/30/hexo-next-two/</a></p><h2 id="添加Fork-Me-on-github书签"><a href="#添加Fork-Me-on-github书签" class="headerlink" title="添加Fork Me on github书签"></a>添加Fork Me on github书签</h2><p><a href="https://www.jianshu.com/p/2002f4881353" target="_blank" rel="noopener">https://www.jianshu.com/p/2002f4881353</a></p><hr><h2 id="NexT主题下修改文章底部-号tag标签"><a href="#NexT主题下修改文章底部-号tag标签" class="headerlink" title="NexT主题下修改文章底部#号tag标签"></a>NexT主题下修改文章底部#号tag标签</h2><p>主题配置文件：set <code>tag_icon: true</code><br><del>在<code>~hexo/themes/next/layout/_macro</code>中找到<code>post.swig</code>文件，在内搜索<code>el="tag"&gt;#</code>，将<strong>#</strong>换成<strong><i class="fa fa-tag"></i></strong>即可.</del></p><hr><h2 id="添加分享按钮"><a href="#添加分享按钮" class="headerlink" title="添加分享按钮"></a>添加分享按钮</h2><p><a href="https://github.com/theme-next/hexo-next-share" target="_blank" rel="noopener">theme-next/hexo-next-share</a></p><hr><h2 id="显示每篇文章的更新时间"><a href="#显示每篇文章的更新时间" class="headerlink" title="显示每篇文章的更新时间"></a>显示每篇文章的更新时间</h2><p>最新版本的next主题已经加入了配置博文更新时间的代码。在主题配置文件中，<code>post_meta</code>中有一个<code>updated_at</code>属性，如果enable就是开启这个功能。所以我们在博文开头开头部分加入<code>updated</code>定义就行：</p><div class="table-container"><table><thead><tr><th style="text-align:center">post Markdown code</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hexo_updatetime2.png"></td><td style="text-align:center"><img alt data-src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hexo_updatetime1.png"></td></tr></tbody></table></div><h2 id="在文章中插入图片"><a href="#在文章中插入图片" class="headerlink" title="在文章中插入图片"></a>在文章中插入图片</h2><p><a href="https://fuhailin.github.io/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F/">https://fuhailin.github.io/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F/</a></p><hr><h2 id="How-to-create-and-sync-your-hexo-blog-in-one-repo"><a href="#How-to-create-and-sync-your-hexo-blog-in-one-repo" class="headerlink" title="How to create and sync your hexo blog in one repo"></a>How to create and sync your hexo blog in one repo</h2><p><a href="https://xiaoyuliu.github.io/2018/03/28/how-to-sync-hexo-blog/" target="_blank" rel="noopener">https://xiaoyuliu.github.io/2018/03/28/how-to-sync-hexo-blog/</a></p><hr><h2 id="Hexo标签插件的使用"><a href="#Hexo标签插件的使用" class="headerlink" title="Hexo标签插件的使用"></a>Hexo标签插件的使用</h2><p><a href="https://wuchenxu.com/2015/12/08/Static-Blog-hexo-github-6-tag-plugins/" target="_blank" rel="noopener">https://wuchenxu.com/2015/12/08/Static-Blog-hexo-github-6-tag-plugins/</a></p><hr><h2 id="在文章中插入代码"><a href="#在文章中插入代码" class="headerlink" title="在文章中插入代码"></a>在文章中插入代码</h2><p>自定义 Hexo 博客代码块: <a href="https://www.w3ctrain.com/2017/12/11/hexo-code-block/" target="_blank" rel="noopener">https://www.w3ctrain.com/2017/12/11/hexo-code-block/</a><br><a href="http://octopress.org/docs/plugins/codeblock/" target="_blank" rel="noopener">http://octopress.org/docs/plugins/codeblock/</a></p><p>插入代码文件</p><p>把整个文件作为代码插入，这样做的好处是作为可运行的代码后续如果修正了bug，重新hexo g一下文章中的代码就会自动更新；不需要每次从文件中拷贝粘贴代码到文章中。</p><p><strong>配置code存放路径</strong><br>在hexo的配置文件<code>hexo/_config.yml</code>中看到<code>code_dir: downloads/code</code>,说明所有的code文件都放到<code>source/downloads/code</code>文件夹下。<br><strong>语法</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% include_code [title] [lang:language] path/to/file %}</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>[title]</code>:可选，标题名，默认是文件名<br><code>[lang:language]</code>:可选设置语言后，根据不同的语言设置语法高亮</p><p><strong>举例</strong><br>代码文件存放在<code>source/uploads/code/hello_world.c</code>.</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% include_code lang:c hello world in c lang hello_world.c %}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><figcaption><span> hello world in c lang</span><a href="/downloads/code/hello_world.c">view raw</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script src="//gist.github.com/55e8446e255abd3ee2900c3691cca09f.js?file=trie.py"></script><p>插入gist代码<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% gist d27c69e5852f3d0f4e7dc15bb90a2e24 trie.py %}</span><br></pre></td></tr></tbody></table></figure><p></p><p>插入github代码<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% ghcode github_code_link start_line end_line %}</span><br></pre></td></tr></tbody></table></figure><p></p><hr><h2 id="搜索引擎优化SEO"><a href="#搜索引擎优化SEO" class="headerlink" title="搜索引擎优化SEO"></a>搜索引擎优化SEO</h2><p><a href="https://fuhailin.github.io/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%E4%B9%8BSEO%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/">https://fuhailin.github.io/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%E4%B9%8BSEO%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/</a></p><hr><h2 id="Hexo博客文章添加置顶属性"><a href="#Hexo博客文章添加置顶属性" class="headerlink" title="Hexo博客文章添加置顶属性"></a>Hexo博客文章添加置顶属性</h2><p>使用插件<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">hexo-generator-index-pin-top</a><br>安装：</p><blockquote><p>$ npm uninstall hexo-generator-index —save<br>$ npm install hexo-generator-index-pin-top —save</p></blockquote><p>使用：在需要置顶的<strong>Front-matter</strong>中加上<code>top: 数字</code>即可，数字越大，置顶越靠前。</p><hr><h2 id="自定义Hexo博客的文章模板"><a href="#自定义Hexo博客的文章模板" class="headerlink" title="自定义Hexo博客的文章模板"></a>自定义Hexo博客的文章模板</h2><p>博客模版存放在<strong>scaffolds</strong>文件夹<br>scaffolds文件夹：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── scaffolds//保存着默认模板，自定义模板就是修改该目录下的文件</span><br><span class="line">│   ├── draft.md //默认的草稿模板</span><br><span class="line">│   ├── page.md //默认的页面模板</span><br><span class="line">│   └── post.md //默认的文章模板</span><br></pre></td></tr></tbody></table></figure><p></p><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：<br><code>hexo new draft "My Gallery"</code><br>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 draft.md</p><p><a href="http://www.mashangxue123.com/Hexo/353523292.html" target="_blank" rel="noopener">http://www.mashangxue123.com/Hexo/353523292.html</a></p><hr><h2 id="博文中嵌入PDF插件"><a href="#博文中嵌入PDF插件" class="headerlink" title="博文中嵌入PDF插件"></a>博文中嵌入PDF插件</h2><p><a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">https://github.com/superalsrk/hexo-pdf</a></p><hr><h2 id="在博客中显示LaTeX数学公式"><a href="#在博客中显示LaTeX数学公式" class="headerlink" title="在博客中显示LaTeX数学公式"></a>在博客中显示LaTeX数学公式</h2><p>我这里使用的是<code>MathJax</code> LaTeX渲染引擎和<del><code>hexo-renderer-markdown-it</code></del> <a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> Markdown解析器<br><a href="https://theme-next.org/docs/third-party-services/math-equations/" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/math-equations/</a></p><hr><h2 id="扩展支持emoji表情"><a href="#扩展支持emoji表情" class="headerlink" title="扩展支持emoji表情"></a>扩展支持emoji表情</h2><p><a href="https://github.com/crimx/hexo-filter-github-emojis" target="_blank" rel="noopener">https://github.com/crimx/hexo-filter-github-emojis</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>emoji使用方法</strong></p><p>这里有一份emoji与markdown编码的对照表:<br><a href="https://gist.github.com/rxaviers/7360908" target="_blank" rel="noopener">Complete list of github markdown emoji markup · GitHub</a></p><p>Emoji test：<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8">😊</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f498.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f498.png?v8">💘</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a9.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a9.png?v8">💩</span>:+1:<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f437.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f437.png?v8">🐷</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f1e8-1f1f3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f1e8-1f1f3.png?v8">🇨🇳</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f51e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f51e.png?v8">🔞</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f393.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f393.png?v8">🎓</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8">😍</span></p><p>但是发现在主页上的emoji表情没有显示出来</p><hr><h2 id="文章置顶标签及排序"><a href="#文章置顶标签及排序" class="headerlink" title="文章置顶标签及排序"></a>文章置顶标签及排序</h2><p><strong>添加置顶属性</strong><br>使用插件<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">hexo-generator-index-pin-top</a><br>安装：</p><blockquote><p>$ npm uninstall hexo-generator-index —save<br>$ npm install hexo-generator-index-pin-top —save</p></blockquote><p>使用：在需要置顶的<strong>Front-matter</strong>中加上<code>top: 数字</code>即可，数字越大，置顶越靠前。</p><p>但是我使用的Next主题这样配置目前还不能实现自动给置顶的博文加上置顶标签，需要手动修改代码解决。</p><p><strong>设置置顶标志</strong></p><p>打开：<code>/blog/themes/next/layout/_macro/post.swig</code>文件，定位到<code>&lt;span class="post-time"&gt;</code>标签下，插入如下代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{% if post.top %}</span><br><span class="line">  &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;</span><br><span class="line">{% endif %}</span><br></pre></td></tr></tbody></table></figure><p>重新编译博客之后就可以显示了</p><p>希望有人能把这个功能提一个pull request到官方库里面，我现在能力还有限。</p><p><strong>References</strong>:</p><ol><li><a href="https://blog.csdn.net/qwerty200696/article/details/79010629" target="_blank" rel="noopener">hexo博客优化之文章置顶+置顶标签</a></li><li><a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">https://github.com/netcan/hexo-generator-index-pin-top</a></li><li><a href="https://yelog.org/2017/02/24/hexo-top-sort/" target="_blank" rel="noopener">Hexo置顶及排序问题|叶落阁</a></li></ol><hr><p><strong>Good References:</strong></p><p>Hexo+NexT 打造一个炫酷博客：<a href="https://juejin.im/post/5bcd2d395188255c3b7dc1db" target="_blank" rel="noopener">https://juejin.im/post/5bcd2d395188255c3b7dc1db</a><br>Hexo官方中文文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><br>hexo进阶: <a href="http://stevenshi.me/2017/05/09/hexo-advance/" target="_blank" rel="noopener">http://stevenshi.me/2017/05/09/hexo-advance/</a><br>博客写作模板: <a href="https://blog.baoyukun.win/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/a-writing-model/" target="_blank" rel="noopener">https://blog.baoyukun.win/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/a-writing-model/</a><br>搭建 Hexo 博客的填坑经历和必要的优化：<a href="https://kris2d.info/posts/b706980b/" target="_blank" rel="noopener">https://kris2d.info/posts/b706980b/</a><br>Hexo程序archive页面数量设置：<a href="http://www.yuzhewo.com/2015/11/21/Hexo%E7%A8%8B%E5%BA%8Farchive%E9%A1%B5%E9%9D%A2%E6%95%B0%E9%87%8F%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener">http://www.yuzhewo.com/2015/11/21/Hexo%E7%A8%8B%E5%BA%8Farchive%E9%A1%B5%E9%9D%A2%E6%95%B0%E9%87%8F%E8%AE%BE%E7%BD%AE/</a><br>Hexo博客归档不分页显示设置方法：<a href="https://sobaigu.com/hexo-archives-show-all-in-one-page.html" target="_blank" rel="noopener">https://sobaigu.com/hexo-archives-show-all-in-one-page.html</a><br>搭建Hexo博客进阶篇—-主题自定义（三）：<a href="https://www.jianshu.com/p/4b9ee8fec3a3" target="_blank" rel="noopener">https://www.jianshu.com/p/4b9ee8fec3a3</a><br><a href="http://saili.science/2017/04/02/github-for-win/#" target="_blank" rel="noopener">Git Pages 使用指南</a><br><a href="https://theme-next.org/docs/third-party-services/search-services" target="_blank" rel="noopener">NexT官方文档</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
