<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵大寳</title>
  
  <subtitle>鶸鸡程序员，新世纪农民工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fuhailin.github.io/"/>
  <updated>2020-02-28T15:45:32.250Z</updated>
  <id>https://fuhailin.github.io/</id>
  
  <author>
    <name>赵大寳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Mac上配置Hadoop娱乐环境</title>
    <link href="https://fuhailin.github.io/Hadoop-on-MacOS/"/>
    <id>https://fuhailin.github.io/Hadoop-on-MacOS/</id>
    <published>2020-02-27T04:03:56.000Z</published>
    <updated>2020-02-28T15:45:32.250Z</updated>
    
    <content type="html"><![CDATA[<p>去年我曾发文记录如何在Ubuntu上配置伪分布式版的Hadoop3娱乐环境：<a href="https://fuhailin.github.io/Hadoop-Install/">https://fuhailin.github.io/Hadoop-Install/</a> ，通过配置Hadoop娱乐环境你可以熟悉Hadoop的一些基本概念与操作方式，后来我的Dell被我玩坏了，也就没法在Ubuntu上顺畅娱乐了，后来一狠心入手了现在MacBook Pro，希望它能皮实耐操一点。今天我们继续在MacOS配置一个Hadoop、Spark娱乐环境，看看它能不能运行处理一些HelloWorld程序。</p><a id="more"></a><h2 id="0️⃣安装Java"><a href="#0️⃣安装Java" class="headerlink" title="0️⃣安装Java"></a>0️⃣安装Java</h2><p>截至目前(2020年02月28日10:54:46)Apache Hadoop 3.x 只支持到了 Java 8，具体支持信息你可以在这里查看：<a href="https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions</a></p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop/Screen-Shot-2020-02-28-at-10.55.32-AM.png" alt="Screen Shot 2020-02-28 at 10.55.32 AM"></p><p>那我就安装jdk8吧，由于Oracle对JAVA的商业政策变化，目前Java8在Homebrew(关于Homebrew的安装查看我之前的博文：<a href="https://fuhailin.github.io/Essential-Apps/#Homebrew)里面被移除了，需要寻找开源版本的openjdk：">https://fuhailin.github.io/Essential-Apps/#Homebrew)里面被移除了，需要寻找开源版本的openjdk：</a></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew tap homebrew/cask-versions</span><br><span class="line">brew cask install homebrew/cask-versions/adoptopenjdk8</span><br><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop/Screen-Shot-2020-02-28-at-9.33.40-AM.png" alt="Screen Shot 2020-02-28 at 9.33.40 AM"></p><h2 id="1️⃣安装Hadoop"><a href="#1️⃣安装Hadoop" class="headerlink" title="1️⃣安装Hadoop"></a>1️⃣安装Hadoop</h2><p>我尝试了通过Homebrew安装Hadoop，但是它在自动安装时总是下载最新版本的jdk13，于是我就直接在官网(<a href="https://hadoop.apache.org/releases.html)下载编译好的二进制版Hadoop进行配置。这一步骤与我之前在Ubuntu配置(https://fuhailin.github.io/Hadoop-Install/)情况相同，Binary版本是编译好的二进制版本，可以直接解压安装，我将其解压在了`/Users/vincent/opt/hadoop/`；另一个包含" target="_blank" rel="noopener">https://hadoop.apache.org/releases.html)下载编译好的二进制版Hadoop进行配置。这一步骤与我之前在Ubuntu配置(https://fuhailin.github.io/Hadoop-Install/)情况相同，Binary版本是编译好的二进制版本，可以直接解压安装，我将其解压在了`/Users/vincent/opt/hadoop/`；另一个包含</a> src 的则是 Hadoop 源代码，需要进行编译才可使用。</p><p>进入解压后的文件目录，测试一下是否正常：<code>./bin/hadoop version</code></p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop/Screen-Shot-2020-02-28-at-11.11.43-AM.png" alt="Screen Shot 2020-02-28 at 11.11.43 AM"></p><p>可以看到打印了版本信息。</p><h2 id="2️⃣配置SSH免密登录"><a href="#2️⃣配置SSH免密登录" class="headerlink" title="2️⃣配置SSH免密登录"></a>2️⃣配置SSH免密登录</h2><p><code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></p><p>对于Mac系统，需要在计算机系统设置中打开远程登录许可。</p><p><img src="https://pic2.zhimg.com/80/v2-1b2a6bb7789ad5145d828ce2b5734291_1440w.jpg" alt=""></p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop/Screen-Shot-2020-02-28-at-10.48.55-PM.png" alt=""></p><h2 id="3️⃣伪分布式配置"><a href="#3️⃣伪分布式配置" class="headerlink" title="3️⃣伪分布式配置"></a>3️⃣伪分布式配置</h2><p>Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。</p><p>Hadoop 的配置文件位于 ./etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。</p><p>输入<code>/usr/libexec/java_home</code>可以查看JAVA_HOME路径。</p><ol><li>将<code>JAVA_HOME</code>的路径、<code>HADOOP_HOME</code>，<code>HADOOP_CONF_DIR</code>添加到hadoop-env.sh文件，修改<code>vim ./etc/hadoop/hadoop-env.sh</code>:</li></ol><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop/Screen-Shot-2020-02-28-at-11.22.34-AM.png" alt="Screen Shot 2020-02-28 at 11.22.34 AM"></p><ol><li>修改配置文件 <code>./etc/hadoop/core-site.xml</code>:</li></ol><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/Users/vincent/opt/hadoop/hadoop-3.1.3/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol><li>修改配置文件 <code>./etc/hadoop/hdfs-site.xml</code>：</li></ol><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/Users/vincent/opt/hadoop/hadoop-3.1.3/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/Users/vincent/opt/hadoop/hadoop-3.1.3/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="4️⃣启动与停止Hadoop"><a href="#4️⃣启动与停止Hadoop" class="headerlink" title="4️⃣启动与停止Hadoop"></a>4️⃣启动与停止Hadoop</h2><p><strong><em>第一次启动hdfs需要格式化</em></strong>：<code>./bin/hdfs namenode -format</code></p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop/Screen-Shot-2020-02-28-at-10.41.18-AM.png" alt="Screen Shot 2020-02-28 at 10.41.18 AM"></p><p><strong>启动Hadoop</strong>：<code>./sbin/start-dfs.sh</code></p><p>启动完成后，可以通过命令 <code>jps</code> 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop/Screen-Shot-2020-02-28-at-10.42.51-AM.png" alt="Screen Shot 2020-02-28 at 10.42.51 AM"></p><p>成功启动后，可以访问 HDFS的Web 界面 <a href="http://localhost:9870/" target="_blank" rel="noopener">http://localhost:9870</a> 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/hadoop/Screen-Shot-2020-02-28-at-10.49.38-AM.png" alt="Screen Shot 2020-02-28 at 10.49.38 AM"></p><p><strong>停止Hadoop</strong>：<code>./sbin/stop-dfs.sh</code></p><h2 id="5️⃣配置Hadoop环境变量简化命令"><a href="#5️⃣配置Hadoop环境变量简化命令" class="headerlink" title="5️⃣配置Hadoop环境变量简化命令"></a>5️⃣配置Hadoop环境变量简化命令</h2><p>给hadoop配置系统环境变量，将下面代码添加到<code>~/.bash_profile</code>文件:</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HADOOP CONFIG</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/Users/vincent/opt/hadoop/hadoop-3.1.3</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=$(<span class="variable">$HADOOP_HOME</span>/bin/hadoop classpath):<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_COMMON_LIB_NATIVE_DIR=<span class="variable">$HADOOP_HOME</span>/lib/native</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></tbody></table></figure><p>执行<code>source ~./bash_profile</code>使设置生效</p><h2 id="6️⃣运行Hadoop伪分布式实例"><a href="#6️⃣运行Hadoop伪分布式实例" class="headerlink" title="6️⃣运行Hadoop伪分布式实例"></a>6️⃣运行Hadoop伪分布式实例</h2><p>由于前面已经配置了Hadoop的环境变量，Hadoop和HDFS的命令已经包含在了系统当中，HDFS有三种shell命令方式：</p><ul><li>hadoop fs ： 适用于任何不同的文件系统，比如本地文件系统和HDFS文件系统</li><li>hadoop dfs ： 只能适用于HDFS文件系统</li><li>hdfs dfs ： 跟hadoop dfs的命令作用一样，也只能适用于HDFS文件系统</li></ul><h3 id="估计圆周率PI的值"><a href="#估计圆周率PI的值" class="headerlink" title="估计圆周率PI的值:"></a>估计圆周率PI的值:</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HADOOP_HOME</span></span><br><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar pi 2 5</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><blockquote><p>Job Finished in 1.441 seconds<br>Estimated value of Pi is 3.60000000000000000000</p></blockquote><h3 id="计算wordcount"><a href="#计算wordcount" class="headerlink" title="计算wordcount:"></a>计算wordcount:</h3><ul><li>创建input目录和output目录<br>input作为输入目录，output目录作为输出目录</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $HADOOP_HOME</span><br><span class="line">mkdir input </span><br><span class="line">mkdir output</span><br></pre></td></tr></tbody></table></figure><ul><li>在input文件夹中创建两个测试文件file1.txt和file2.txt</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd input</span><br><span class="line">echo 'hello world' &gt; file1.txt</span><br><span class="line">echo 'hello hadoop' &gt; file2.txt</span><br></pre></td></tr></tbody></table></figure><ul><li>把测试input文件上传到hdfs中</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put ./input input</span><br></pre></td></tr></tbody></table></figure><p>复制完成后，可以通过如下命令查看HDFS文件列表：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls input</span><br></pre></td></tr></tbody></table></figure><p></p><p>运行wordcount</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar wordcount ./input ./output</span><br></pre></td></tr></tbody></table></figure><p>查看output的结果文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -tail output/part-r-00000</span><br></pre></td></tr></tbody></table></figure><p>得到的结果是：</p><blockquote><ul><li>hadoop 1</li><li>hello 2</li><li>world 1</li></ul></blockquote><p>伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output 'dfs[a-z.]+'</span><br></pre></td></tr></tbody></table></figure><p>查看运行结果的命令（查看的是位于 HDFS 中的输出结果）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -cat output/*</span><br></pre></td></tr></tbody></table></figure><p>结果如下，注意到刚才我们已经更改了配置文件，所以运行结果不同。</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-04-25-16-21-24.png" alt=""></p><p>我们也可以将运行结果取回到本地：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -r ./output    # 先删除本地的 output 文件夹（如果存在）</span><br><span class="line">hdfs dfs -get output ./output     # 将 HDFS 上的 output 文件夹拷贝到本机</span><br><span class="line">cat ./output/*</span><br></pre></td></tr></tbody></table></figure><p>Hadoop 运行程序时，输出目录不能存在，否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -rm -r output    # 删除 output 文件夹</span><br></pre></td></tr></tbody></table></figure><p>若要关闭 Hadoop，则运行<br><code>./sbin/stop-dfs.sh</code><br>下次启动 hadoop 时，无需进行 NameNode 的初始化，只需要运行 <code>./sbin/start-dfs.sh</code> 就可以！</p><p><strong>References</strong>:</p><ol><li><p><a href="http://dblab.xmu.edu.cn/blog/install-hadoop/" target="_blank" rel="noopener">Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04</a></p></li><li><p><a href="https://www.cnblogs.com/87hbteo/p/7606012.html" target="_blank" rel="noopener">Ubuntu16.04 下 hadoop的安装与配置（伪分布式环境）</a></p></li><li><p><a href="https://dzone.com/articles/install-a-hadoop-cluster-on-ubuntu-18041" target="_blank" rel="noopener">Install a Hadoop Cluster on Ubuntu 18.04.1</a></p></li><li><p>Installing Hadoop on Mac：<a href="https://medium.com/beeranddiapers/installing-hadoop-on-mac-a9a3649dbc4d" target="_blank" rel="noopener">https://medium.com/beeranddiapers/installing-hadoop-on-mac-a9a3649dbc4d</a></p></li><li>Ubuntu18.04下Hadoop 3的安装与配置（伪分布式环境）：<a href="https://fuhailin.github.io/Hadoop-Install/">https://fuhailin.github.io/Hadoop-Install/</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年我曾发文记录如何在Ubuntu上配置伪分布式版的Hadoop3娱乐环境：&lt;a href=&quot;https://fuhailin.github.io/Hadoop-Install/&quot;&gt;https://fuhailin.github.io/Hadoop-Install/&lt;/a&gt; ，通过配置Hadoop娱乐环境你可以熟悉Hadoop的一些基本概念与操作方式，后来我的Dell被我玩坏了，也就没法在Ubuntu上顺畅娱乐了，后来一狠心入手了现在MacBook Pro，希望它能皮实耐操一点。今天我们继续在MacOS配置一个Hadoop、Spark娱乐环境，看看它能不能运行处理一些HelloWorld程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hadoop" scheme="https://fuhailin.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>激活函数</title>
    <link href="https://fuhailin.github.io/activation-functions/"/>
    <id>https://fuhailin.github.io/activation-functions/</id>
    <published>2020-02-19T03:43:45.000Z</published>
    <updated>2020-02-28T15:46:35.821Z</updated>
    
    <content type="html"><![CDATA[<p>  本文搜集整理了从Sigmoid、ReLU到Dice等十几种常见激活函数的原理与特点，并从底层用Numpy实现和Python绘制它们。<br><a id="more"></a><br>激活函数之性质</p><p><strong>1. 非线性：</strong>即导数不是常数。保证多层网络不退化成单层线性网络。这也是激活函数的意义所在。</p><p><strong>2. 可微性：</strong>保证了在优化中梯度的可计算性。虽然 ReLU 存在有限个点处不可微，但处处 subgradient，可以替代梯度。</p><p><strong>3. 计算简单：</strong>激活函数复杂就会降低计算速度，因此 RELU 要比 Exp 等操作的激活函数更受欢迎。</p><p><strong>4. 非饱和性（saturation）：</strong>饱和指的是在某些区间梯度接近于零（即梯度消失），使得参数无法继续更新的问题。最经典的例子是 Sigmoid，它的导数在 x 为比较大的正值和比较小的负值时都会接近于 0。RELU 对于 x&lt;0，其梯度恒为 0，这时候它也会出现饱和的现象。Leaky ReLU 和 PReLU 的提出正是为了解决这一问题。</p><p><strong>5. 单调性（monotonic）：</strong>即导数符号不变。当激活函数是单调的时候，单层网络能够保证是凸函数。但是激活函数如 mish 等并不满足单调的条件，因此单调性并不是硬性条件，因为神经网络本来就是非凸的。</p><p><strong>6. 参数少：</strong>大部分激活函数都是没有参数的。像 PReLU 带单个参数会略微增加网络的大小。还有一个例外是 Maxout，尽管本身没有参数，但在同样输出通道数下 k 路 Maxout 需要的输入通道数是其它函数的 k 倍，这意味着神经元数目也需要变为 k 倍。</p><h2 id="Sigmoid激活函数"><a href="#Sigmoid激活函数" class="headerlink" title="Sigmoid激活函数"></a>Sigmoid激活函数</h2><script type="math/tex; mode=display">\sigma \left( x\right) =\dfrac {1} {1+e^{-x}}</script><p>其导数为：</p><script type="math/tex; mode=display">\sigma'(x) = \sigma(x) \cdot (1 - \sigma(x))</script><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> / (<span class="number">1</span> + np.exp(-x))</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/sigmoid.png" alt="sigmoid"></p><p><strong>优点：</strong></p><ul><li>梯度平滑，求导容易</li><li>Sigmoid函数的输出映射在(0,1)之间，单调连续，输出范围有限，优化稳定，可以用作输出层</li></ul><p><strong>缺点：</strong></p><ul><li>激活函数计算量大（在正向传播和反向传播中都包含幂运算和除法）；</li><li>梯度消失：输入值较大或较小（图像两侧）时，sigmoid导数则接近于零，因此在反向传播时，这个局部梯度会与整个代价函数关于该单元输出的梯度相乘，结果也会接近为 0 ，无法实现更新参数的目的；</li><li>Sigmoid 的输出不是 0 为中心（zero-centered）。因为如果输入都是正数的话（如 <script type="math/tex">f=w^{T}x+b</script> 中每个元素都 <script type="math/tex">x>0</script> ），那么关于 <script type="math/tex">w</script> 的梯度在反向传播过程中，要么全是正数，要么全是负数（具体依据整个表达式 <script type="math/tex">f</script> 而定），这将会导致梯度下降权重更新时出现 z 字型的下降。当然，如果是按 batch 去训练，那么每个 batch 可能得到不同的信号，整个批量的梯度加起来后可以缓解这个问题。因此，该问题相对于上面的神经元饱和问题来说只是个小麻烦，没有那么严重。</li></ul><h2 id="Tanh激活函数"><a href="#Tanh激活函数" class="headerlink" title="Tanh激活函数"></a>Tanh激活函数</h2><script type="math/tex; mode=display">tanh(x) = \frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}</script><p>其导数为：</p><script type="math/tex; mode=display">tanh'(x) = 1 - tanh(x)^{2}</script><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sinh(x)/np.cosh(x)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/tanh.png" alt="tanh"></p><p><strong>优点：</strong></p><ul><li>比Sigmoid函数收敛速度更快</li><li>tanh(x) 的梯度消失问题比 sigmoid 要轻</li><li>相比Sigmoid函数，输出是以 0 为中心 zero-centered</li></ul><p><strong>缺点：</strong></p><ul><li>还是没有改变Sigmoid函数的最大问题——由于饱和性产生的梯度消失。</li></ul><h2 id="整流线性单元-ReLU"><a href="#整流线性单元-ReLU" class="headerlink" title="整流线性单元(ReLU)"></a>整流线性单元(ReLU)</h2><div class="table-container"><table><thead><tr><th>Function</th><th>Derivative</th></tr></thead><tbody><tr><td>$\begin{split}ReLU(x) = \begin{Bmatrix} x &amp; x &gt; 0 \ 0 &amp; x &lt;= 0 \end{Bmatrix}\end{split}$</td><td>$\begin{split}ReLU’(x) = \begin{Bmatrix} 1 &amp; x&gt;0 \ 0 &amp; x&lt;0 \end{Bmatrix}\end{split}$</td></tr></tbody></table></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReLU</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * (x &gt; <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/relu.png" alt="ReLU"></p><p><strong>优点：</strong></p><ul><li>计算与收敛速度非常快：不涉及指数等运算；</li><li>一定程度<strong>缓解梯度消失</strong>问题：因为导数为 1，不会像 sigmoid 那样由于导数较小，而导致连乘得到的梯度逐渐消失。</li></ul><p><strong>缺点：</strong></p><p><strong>Dying ReLU</strong>：某些神经元可能永远不会被激活，导致相应的参数永远不能被更新。有两个主要原因可能导致这种情况产生: (1) 非常不幸的参数初始化，这种情况比较少见 (2) learning rate太高导致在训练过程中参数更新太大，不幸使网络进入这种状态。解决方法是可以采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法。</p><p>尽管存在这两个问题，ReLU目前仍是最常用的activation function，在搭建人工神经网络的时候推荐优先尝试！</p><p>前面说了一大堆的 ReLU 的缺点，有很多大牛在此基础上做了改进，如 Leaky ReLU、PReLU(Parametric ReLU)等。</p><p>我整理了本文涉及到的全部十几种常见激活函数的底层实现代码Python版，关注我的公众号”趙大寳Note”（ID：StateOfTheArt）回复关键词：激活函数  下载收藏。</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/wechat_channel.png" alt="关注公众号趙大寳Note，回复“激活函数”下载全部代码"></p><h2 id="指数线性单元-ELU"><a href="#指数线性单元-ELU" class="headerlink" title="指数线性单元(ELU)"></a>指数线性单元(ELU)</h2><div class="table-container"><table><thead><tr><th>Function</th><th>Derivative</th></tr></thead><tbody><tr><td>$\begin{split}ELU(x) = \begin{Bmatrix} x &amp; x &gt; 0 \ α.( e^x – 1) &amp; x &lt;= 0 \end{Bmatrix}\end{split}$</td><td>$\begin{split}ELU’(x) = \begin{Bmatrix} 1 &amp; x&gt;0 \ α.e^x &amp; x&lt;0 \end{Bmatrix}\end{split}$</td></tr></tbody></table></div><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/ELU.png" alt="ELU"></p><p><strong>优点：</strong></p><ul><li>能避免死亡 ReLU 问题：x 小于 0 时函数值不再是 0，因此可以避免 dying relu 问题；</li><li>能得到负值输出，这能帮助网络向正确的方向推动权重和偏置变化。</li></ul><p><strong>缺点：</strong></p><ul><li>计算耗时：包含指数运算；</li><li>α 值是超参数，需要人工设定</li></ul><h2 id="SELU"><a href="#SELU" class="headerlink" title="SELU"></a>SELU</h2><p>SELU 源于论文 <strong><em>Self-Normalizing Neural Networks\</em></strong>，作者为 Sepp Hochreiter，ELU 同样来自于他们组。</p><p>SELU 其实就是 ELU 乘 lambda，关键在于这个 lambda 是大于 1 的，论文中给出了 lambda 和 alpha 的值：</p><ul><li>lambda = 1.0507</li><li>alpha = 1.67326</li></ul><script type="math/tex; mode=display">\operatorname{selu}(x)=\lambda\left\{\begin{array}{ll}{x} & {\text { if } x>0} \\ {\alpha e^{x}-\alpha} & {\text { if } x \leqslant 0}\end{array}\right.</script><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/SELU.png" alt="SELU"></p><p><strong>优点：</strong></p><ul><li>SELU 激活能够对神经网络进行自归一化（self-normalizing）；</li><li>不可能出现梯度消失或爆炸问题，论文附录的定理 2 和 3 提供了证明。</li></ul><p><strong>缺点：</strong></p><ul><li>应用较少，需要更多验证；</li><li>lecun_normal 和 Alpha Dropout：需要 lecun_normal 进行权重初始化；如果 dropout，则必须用 Alpha Dropout 的特殊版本。</li></ul><h2 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h2><p>Leaky ReLU 是为解决“ ReLU 死亡”问题的尝试。</p><div class="table-container"><table><thead><tr><th>Function</th><th>Derivative</th></tr></thead><tbody><tr><td>$\begin{split}R(x) = \begin{Bmatrix} x &amp; x &gt; 0 \ \alpha x &amp; x &lt;= 0 \end{Bmatrix}\end{split}$</td><td>$\begin{split}R’(x) = \begin{Bmatrix} 1 &amp; x&gt;0 \ \alpha &amp; x&lt;0 \end{Bmatrix}\end{split}$</td></tr></tbody></table></div><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/Leaky_ReLU.png" alt="Leaky_ReLU"></p><p><strong>优点：</strong></p><ul><li>类似于 ELU，能避免死亡 ReLU 问题：x 小于 0 时候，导数是一个小的数值，而不是 0；</li><li>与 ELU 类似，能得到负值输出；</li><li>计算快速：不包含指数运算。</li></ul><p><strong>缺点：</strong></p><ul><li>同 ELU，α 值是超参数，需要人工设定；</li><li>在微分时，两部分都是线性的；而 ELU 的一部分是线性的，一部分是非线性的。</li></ul><h2 id="Parametric-ReLU-PRELU"><a href="#Parametric-ReLU-PRELU" class="headerlink" title="Parametric ReLU (PRELU)"></a>Parametric ReLU (PRELU)</h2><p>形式上与 Leak_ReLU 在形式上类似，不同之处在于：PReLU 的参数 alpha 是可学习的，需要根据梯度更新。</p><ul><li>alpha=0：退化为 ReLU</li><li>alpha 固定不更新，退化为 Leak_ReLU</li></ul><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/ParametricReLU.png" alt="PReLU"></p><p><strong>优点：</strong></p><p>与 ReLU 相同。</p><p><strong>缺点：</strong></p><p>在不同问题中，表现不一。</p><h2 id="Gaussian-Error-Linear-Unit-GELU"><a href="#Gaussian-Error-Linear-Unit-GELU" class="headerlink" title="Gaussian Error Linear Unit(GELU)"></a>Gaussian Error Linear Unit(GELU)</h2><p>高斯误差线性单元激活函数在最近的 Transformer 模型（谷歌的 BERT 和 OpenAI 的 GPT-2）中得到了应用。GELU 的论文来自 2016 年，但直到最近才引起关注。</p><script type="math/tex; mode=display">\operatorname{GELU}(x)=0.5 x\left(1+\tanh \left(\sqrt{2 / \pi}\left(x+0.044715 x^{3}\right)\right)\right)</script><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/GELU.png" alt="GELU"></p><p>优点：</p><ul><li>似乎是 NLP 领域的当前最佳；尤其在 Transformer 模型中表现最好；</li><li>能避免梯度消失问题。</li></ul><p>缺点：</p><ul><li>这个2016 年提出的新颖激活函数还缺少实际应用的检验。</li></ul><h2 id="Swish"><a href="#Swish" class="headerlink" title="Swish"></a>Swish</h2><p>Swish激活函数诞生于Google Brain 2017的论文 <a href="https://arxiv.org/abs/1710.05941" target="_blank" rel="noopener">Searching for Activation functions</a>中，其定义为：</p><script type="math/tex; mode=display">f(x) = x · \text{sigmoid}(βx)</script><p>β是个常数或可训练的参数.Swish 具备无上界有下界、平滑、非单调的特性。</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/Swish.png" alt="Swish"></p><p>Swish 在深层模型上的效果优于 ReLU。例如，仅仅使用 Swish 单元替换 ReLU 就能把 Mobile NASNetA 在 ImageNet 上的 top-1 分类准确率提高 0.9%，Inception-ResNet-v 的分类准确率提高 0.6%。<br>当β = 0时,Swish变为线性函数$f(x) ={x\over 2}$.<br>β → ∞, $σ(x) = (1 + \exp(−x))^{−1}$为0或1. Swish变为ReLU: f(x)=2max(0,x)<br>所以Swish函数可以看做是介于线性函数与ReLU函数之间的平滑函数.</p><h2 id="Data-Adaptive-Activation-Function-Dice"><a href="#Data-Adaptive-Activation-Function-Dice" class="headerlink" title="Data Adaptive Activation Function(Dice)"></a>Data Adaptive Activation Function(Dice)</h2><p>Dice激活函数诞生于alibaba 2018 的CTR论文<strong><em>Deep Interest Network</em></strong>中，根据 Parametric ReLU 改造而来，ReLU类函数的阶跃变化点再x=0处，意味着面对不同的输入这个变化点是不变的，DIN中改进了这个控制函数，让它根据数据的分布来调整，选择了统计神经元输出的均值和方差(实际上就是<em>Batch_Normalization</em>,CTR中BN操作可是很耗时的，可以推测Dice复杂的计算快不起来不会大规模引用)来描述数据的分布：</p><script type="math/tex; mode=display">f(s)=p(s) . s+(1-p(s)) \cdot \alpha s, p(s)=\frac{1}{1+e^{-\frac{s-E(s)}{\sqrt{\operatorname{Var}(s)+\epsilon}}}}</script><p>优点：</p><ul><li>根据数据分布灵活调整阶跃变化点，具有BN的优点(解决Internal Covariate Shift)，原论文称效果好于Parametric ReLU。</li></ul><p>缺点：</p><ul><li>具有BN的缺点，大大加大了计算复杂度。</li></ul><h2 id="Maxout"><a href="#Maxout" class="headerlink" title="Maxout"></a>Maxout</h2><p>Maxout 是对 ReLU 和 Leaky ReLU 的一般化归纳，它的函数公式是（二维时）：</p><script type="math/tex; mode=display">Maxout(x) = \max \left( w_{1}^{T}x+b_{1},W_{2}^{T}x+b_{2}\right)</script><p>ReLU 和 Leaky ReLU 都是这个公式的特殊情况（比如 ReLU 就是当 <script type="math/tex">w_{1},b_{1}=0</script>时）。</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/Maxout.png" alt="Maxout"></p><p>优点：</p><ul><li>Maxout 神经元拥有 ReLU 单元的所有优点（线性和不饱和），而没有它的缺点（死亡的 ReLU 单元）</li></ul><p>缺点：</p><ul><li>和 ReLU 对比，它每个神经元的参数数量增加了一倍，这就导致整体参数的数量激增。</li></ul><h2 id="Softplus"><a href="#Softplus" class="headerlink" title="Softplus"></a>Softplus</h2><script type="math/tex; mode=display">softplus(x)=\log \left(1+e^{x}\right)</script><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/softplus.png" alt="Softplus"></p><p>softplus可以看作是ReLu的平滑，不常见。</p><h2 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h2><p>Sigmoid函数只能处理两个类别，这不适用于多分类的问题，所以Softmax可以有效解决这个问题。Softmax函数很多情况都运用在神经网路中的最后一层网络中，使得每一个类别的概率值在(0, 1)之间。</p><script type="math/tex; mode=display">s\left(x_{i}\right)=\frac{e^{x_{i}}}{\sum_{j=1}^{n} e^{x_{j}}}</script><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.exp(x) / sum(np.exp(x))</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/activation-function/softmax.png" alt="Softmax"></p><h2 id="如何选择激活函数？"><a href="#如何选择激活函数？" class="headerlink" title="如何选择激活函数？"></a>如何选择激活函数？</h2><p>通常来说，很少会把各种激活函数串起来在一个网络中使用的。</p><p>如果使用 ReLU ，那么一定要小心设置 learning rate ，而且要注意不要让你的网络出现很多 “ dead ” 神经元，如果这个问题不好解决，那么可以试试 Leaky ReLU 、 PReLU 或者 Maxout.</p><p>最好不要用 sigmoid ，可以试试 tanh ，不过可以预期它的效果会比不上 ReLU 和 Maxout.</p><hr><p>看到这里你已经知道了足够多的激活函数，那你还记得你学习激活函数的初衷吗？我们为什么需要激活函数，激活函数的作用呢？为什么SVM这类算法没有激活函数也能进行非线性分类呢？一起思考</p><p>References:</p><p>[1]: <em>(<a href="https://ml-cheatsheet.readthedocs.io/en/latest/activation_functions.html#id2" target="_blank" rel="noopener">1</a>, <a href="https://ml-cheatsheet.readthedocs.io/en/latest/activation_functions.html#id4" target="_blank" rel="noopener">2</a>)</em> <a href="http://cs231n.github.io/neural-networks-1/" target="_blank" rel="noopener">http://cs231n.github.io/neural-networks-1/</a></p><p>[2]: <a href="https://ml-cheatsheet.readthedocs.io/en/latest/activation_functions.html#activation-functions" target="_blank" rel="noopener">ML Glossary | Activation Functions</a></p><p>[3]: <a href="https://www.jiqizhixin.com/graph/technologies/1697e627-30e7-48a6-b799-39e2338ffab5" target="_blank" rel="noopener">机器之心 | 激活函数</a></p><p>[4]: <a href="https://www.cnblogs.com/makefile/p/activation-function.html" target="_blank" rel="noopener">激活函数(ReLU, Swish, Maxout)</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  本文搜集整理了从Sigmoid、ReLU到Dice等十几种常见激活函数的原理与特点，并从底层用Numpy实现和Python绘制它们。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习与算法" scheme="https://fuhailin.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linear Regression</title>
    <link href="https://fuhailin.github.io/Linear-Regression/"/>
    <id>https://fuhailin.github.io/Linear-Regression/</id>
    <published>2019-12-05T03:10:55.000Z</published>
    <updated>2020-01-02T03:37:04.618Z</updated>
    
    <content type="html"><![CDATA[<p>别看线性回归算法原理简单，但其中也还有许多特殊的问题需要特别的手段处理。比如离群点就是一个特别的案例。<br>少数离群点会显著影响训练集的均值结果，对回归线的整体拟合度产生较大的影响，因此我们需要找出其中的离群点并去除它们。</p><a id="more"></a><p><strong>异常值点</strong>: 异常值是指数据中有异常表现的数据点。在一个回归模型中，异常值点包括离群点，高杠杆值点和强影响点，这些点都可能对结果产生较大的负面影响，因此对异常值点的判断及修正对建立正确的回归模型非常重要。</p><p><strong>Outliers(离群点)</strong>: 离群点通常指残差非常大的点，即模型预测的y值与真实的y值相差非常大。通常检测离群点的方法有： 方法1：用箱线图判断，如果图中的点出现在四个分位数外的一般都是离群点。 方法2：用QQ图检测，落在置信区间外的点通常被认为是离群点。 方法3：通常认为标准化残差的绝对值大于2的点可能是离群点，也有资料说是大于3，可视情况而定 方法4：用car包的outlierTest()函数求得最大标准化残差绝对值Bonferroni调整后的p值，从而作出判断。 对离群点，我们一般会选择删除，删除离群点还有利于提高数据集对于正态分布假设的拟合度。</p><p><strong>Leverage(高杠杆值点)</strong>: 高杠杆值点指的是x值比较异常，通常与响应变量值y没有关系。 判断高杠杆值点的方法： 方法1： 杠杆点在简单线性回归中较容易辨别，一般找出预测值超出正常范围的观测点即杠杆点。 方法2： 计算点的帽子统计量，若该点的帽子统计量大于帽子统计量的均值的2或3倍，通常被认为是高杠杆值点。</p><p><strong>Influential(强影响点)</strong>: 即对模型参数估计值影响有些比例失衡的点。例如，若移除模型的一个观测点时，模型会发生巨大的改变。一般来说，高杠杆值点，若是离群点，则是强影响点。当然强影响点也不局限于此，强影响点是指对统计推断有影响的点，一般用cook距离进行判断，若cook距离的值大于4/(n-k-1),则表明是强影响点</p><h1 id="回归诊断"><a href="#回归诊断" class="headerlink" title="回归诊断"></a>回归诊断</h1><p>线性回归有诸多假设条件，对于残差来说，要求符合正态性、同方差、无自相关，因此残差诊断分析成为线性回归中必不可少一个环节。<br>假设：</p><ol><li>因变量是连续变量</li><li>自变量可以被定义为连续变量</li><li>因变量和自变量之间存在线性关系</li><li>具有相互独立的观测值</li><li>不存在显著的异常值</li><li>等方差性</li><li>回归残差近似正态分布</li></ol><p>残差图是指以某种残差为纵坐标，以其他适宜的变量为横坐标的散点图，所以残差图、残差散点图都是一个概念。这里横坐标有多种选择，最常见的选择是：1.因变量的拟合值；2. 某自变量的观察值等。</p><p>残差（residual）：</p><script type="math/tex; mode=display">e_{i} = Y_{i}-\hat{Y_{i}}</script><h4 id="高杠杆值点"><a href="#高杠杆值点" class="headerlink" title="高杠杆值点"></a>高杠杆值点</h4><p>高杠杆值点是与其他预测变量有关的离群点，即它们是由许多异常的预测变量组合起来的，与响应变量值没有关系。 高杠杆值的观测点可通过帽子矩阵的值（hat statistic）判断。对于一个给定的数据集，帽子均值为p/n，其中p是模型估计的参数数目（包含截距项），n是样本量。一般来说，若观测点的帽子值大于帽子均值的2或3倍，则可认定为高杠杆值点。</p><h4 id="离群点"><a href="#离群点" class="headerlink" title="离群点"></a>离群点</h4><p>指那些模型预测效果不佳的观测点，通常有很大的、或正或负的残差，正残差说明模型低估了响应值，负残差说明高佑了响应值。 <code>outlierTest()</code>函数是根据单个最大（或正或负）残差值的显著性来判断是否有离群点，若不显著，则说明数据集中没有离群点，若显著，则必须删除该离群点，然后再检验是否还有其他离群点存在。qqPlot图中落在置信区间带外的点可被认为时离群点，本例中未发现有离群点</p><h4 id="高杠杆值点-1"><a href="#高杠杆值点-1" class="headerlink" title="高杠杆值点"></a>高杠杆值点</h4><p>高杠杆值点是与其他预测变量有关的离群点，即它们是由许多异常的预测变量组合起来的，与响应变量值没有关系。 高杠杆值的观测点可通过帽子矩阵的值（hat statistic）判断。对于一个给定的数据集，帽子均值为p/n，其中p是模型估计的参数数目（包含截距项），n是样本量。一般来说，若观测点的帽子值大于帽子均值的2或3倍，则可认定为高杠杆值点。</p><h4 id="强影响点"><a href="#强影响点" class="headerlink" title="强影响点"></a>强影响点</h4><p>强影响点，即对模型参数估计值影响有些比例失衡的点。例如，当移除 模型的一个观测点时模型会发生巨大的改变，那么需要检测一下数据中是否存在强影响点。Cook距离，或称为D统计量。Cook’s D值大于4/(n-k-1)，则表明它是强影响点，其中n为样本量大小，k是预测变量数目（有助于鉴别强影响点，但并不提供关于这些点如何影响模型的信息），如下所示：</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="[http://rvdsd.top/2017/06/07/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-09%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/](http://rvdsd.top/2017/06/07/BioStatistics/生物统计-09线性回归/">线性回归笔记</a></li><li><a href="http://chenyuan.date/2017/11/Logistic-regression/" target="_blank" rel="noopener">Logistic regression</a></li><li><a href="https://bookdown.org/hezhijian/book/" target="_blank" rel="noopener">《数理统计讲义》</a></li><li>王斌会. 多元统计分析及R语言建模[M]. 暨南大学出版社, 2010.</li><li>汤银才. R语言与统计分析[M]. 高等教育出版社, 2008.</li><li>卡巴科弗. R语言实战[M]. 人民邮电出版社, 2016.</li><li><a href="https://zhuanlan.zhihu.com/p/54129885" target="_blank" rel="noopener">线性回归(实战)</a></li><li><a href="https://juejin.im/entry/5bdc130051882516d326946c" target="_blank" rel="noopener">机器学习之线性回归法</a></li><li><a href="http://blog.fens.me/r-linear-regression/" target="_blank" rel="noopener">R语言解读一元线性回归模型</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;别看线性回归算法原理简单，但其中也还有许多特殊的问题需要特别的手段处理。比如离群点就是一个特别的案例。&lt;br&gt;少数离群点会显著影响训练集的均值结果，对回归线的整体拟合度产生较大的影响，因此我们需要找出其中的离群点并去除它们。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CatBoost</title>
    <link href="https://fuhailin.github.io/CatBoost/"/>
    <id>https://fuhailin.github.io/CatBoost/</id>
    <published>2019-12-02T04:46:32.000Z</published>
    <updated>2019-12-20T07:03:06.626Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/XmpvNH97k1z6P9kYA36X_Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XmpvNH97k1z6P9kYA36X_Q</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XmpvNH97k1z6P9kYA36X_Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/XmpvNH97k1z6P9kYA36
      
    
    </summary>
    
      <category term="机器学习与算法" scheme="https://fuhailin.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>使用数据库连接池提升读写性能</title>
    <link href="https://fuhailin.github.io/Connection-Pool/"/>
    <id>https://fuhailin.github.io/Connection-Pool/</id>
    <published>2019-12-02T03:41:27.000Z</published>
    <updated>2019-12-20T07:03:02.702Z</updated>
    
    <content type="html"><![CDATA[<p>以我目前使用较多的Python语言编程为例，可以使用<code>PyMysql</code>来连接MySQL数据库并进行“query、insert、update”等操作，但是这样的方案你每次请求连接MySQL都会有一个单独的连接，这很浪费资源，特别是当请求的数量达到一定数量时会对MySQL的性能产生明显的影响。因此在实际使用中，数据库连接池技术通常被用来进行数据库连接中的资源复用。</p><h1 id="Solution：DBUtils"><a href="#Solution：DBUtils" class="headerlink" title="Solution：DBUtils"></a>Solution：DBUtils</h1><p>DBUtils是一个允许在非线程安全数据库接口周围使用线程安全包装器的Python数据库连接池工具包。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以我目前使用较多的Python语言编程为例，可以使用&lt;code&gt;PyMysql&lt;/code&gt;来连接MySQL数据库并进行“query、insert、update”等操作，但是这样的方案你每次请求连接MySQL都会有一个单独的连接，这很浪费资源，特别是当请求的数量达到一定数量
      
    
    </summary>
    
    
      <category term="Python" scheme="https://fuhailin.github.io/tags/Python/"/>
    
      <category term="数据库连接池" scheme="https://fuhailin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Docker Cheat Sheet</title>
    <link href="https://fuhailin.github.io/Docker-Cheat-Sheet/"/>
    <id>https://fuhailin.github.io/Docker-Cheat-Sheet/</id>
    <published>2019-09-18T15:37:29.000Z</published>
    <updated>2019-12-23T14:46:42.852Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要使用Docker：“有了Docker，开发人员能够借助任何工具、使用语言来构建任何应用”。Docker化的应用是完全绿色便携的，能运行在任何平台。</p><a id="more"></a><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><p>Linux：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></tbody></table></figure><p></p><p>OR</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screenshot from 2019-09-20 22-12-42.png" alt=""></p><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><div class="table-container"><table><thead><tr><th>Docker语法</th><th>描述</th></tr></thead><tbody><tr><td>docker search  searchterm</td><td>Search Docker Hub for images.</td></tr><tr><td>docker pull user/image</td><td>Downloads an image from Docker Hub.</td></tr><tr><td>docker login</td><td>Authenticate to Docker Hub (or other Docker registry).</td></tr><tr><td>docker push user/image</td><td>Uploads an image to Docker Hub. You must be authenticated to run this command.</td></tr></tbody></table></div><h2 id="Image-and-Container-Information"><a href="#Image-and-Container-Information" class="headerlink" title="Image and Container Information"></a>Image and Container Information</h2><div class="table-container"><table><thead><tr><th>Docker语法</th><th>描述</th></tr></thead><tbody><tr><td>docker ps</td><td>List all running containers.</td></tr><tr><td>docker ps -a</td><td>List all container instances, with their ID and status.</td></tr><tr><td>docker history user/image</td><td>Lists the history of an image.</td></tr><tr><td>docker logs [container name or ID]</td><td>Displays the logs from a running container.</td></tr><tr><td>docker port [container name or ID]</td><td>Displays the exposed port of a running container.</td></tr><tr><td>docker diff [container name or ID]</td><td>Lists the changes made to a container.</td></tr></tbody></table></div><h2 id="Work-With-Images-and-Containers"><a href="#Work-With-Images-and-Containers" class="headerlink" title="Work With Images and Containers"></a>Work With Images and Containers</h2><div class="table-container"><table><thead><tr><th>Docker语法</th><th>描述</th></tr></thead><tbody><tr><td>docker run -it user/image</td><td>Runs an image, creating a container and changing the terminal to the terminal within the container.</td></tr><tr><td>docker run -p $HOSTPORT:$CONTAINERPORT -d user/image</td><td>Run an image in detached mode with port forwarding.</td></tr><tr><td>ctrl+p then ctrl+q</td><td>From within the container’s command prompt, detach and return to the host’s prompt.</td></tr><tr><td>docker attach [container name or ID]</td><td>Changes the command prompt from the host to a running container.</td></tr><tr><td>docker stop [container name or ID]</td><td>Stop a container.</td></tr><tr><td>docker rm -f [container name or ID]</td><td>Delete a container.</td></tr><tr><td>docker rmi</td><td>Delete an image.</td></tr><tr><td>docker tag user/image:tag user/image:newtag</td><td>Add a new tag to an image.</td></tr><tr><td>docker exec [container name or ID] shell command</td><td>Executes a command within a running container.</td></tr></tbody></table></div><h2 id="Image-Creation"><a href="#Image-Creation" class="headerlink" title="Image Creation"></a>Image Creation</h2><div class="table-container"><table><thead><tr><th>Docker语法</th><th>描述</th></tr></thead><tbody><tr><td>docker commit user/image</td><td>Save a container as an image.</td></tr><tr><td>docker save user/image</td><td>Save an image to a tar archive.</td></tr><tr><td>docker build -t sampleuser/ubuntu .</td><td>Builds a Docker image from a Dockerfile in the current directory.</td></tr><tr><td>docker load</td><td>Loads an image from file.</td></tr></tbody></table></div><h2 id="Docker-net-http-TLS-handshake-timeout的解决办法"><a href="#Docker-net-http-TLS-handshake-timeout的解决办法" class="headerlink" title="Docker net/http: TLS handshake timeout的解决办法"></a>Docker net/http: TLS handshake timeout的解决办法</h2><p>由于国内网络环境问题，Docker pull国外镜像出现无法使用的网络问题，因此更换国内镜像：<br>修改 <code>sudo vim /etc/docker/daemon.json</code>，添加如下地址：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://khec465u.mirror.aliyuncs.com"</span></span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重启Docker服务：<code>sudo service docker restart</code></p><h2 id="解决每次使用Docker命令都需要root权限的问题"><a href="#解决每次使用Docker命令都需要root权限的问题" class="headerlink" title="　解决每次使用Docker命令都需要root权限的问题"></a>　解决每次使用Docker命令都需要root权限的问题</h2><p>将你使用的具有root权限的用户加入docker group： <code>sudo usermod -aG docker $USER</code></p><p><a href="https://www.linode.com/docs/applications/containers/docker-commands-quick-reference-cheat-sheet/" target="_blank" rel="noopener">https://www.linode.com/docs/applications/containers/docker-commands-quick-reference-cheat-sheet/</a></p><hr><h1 id="Kubernets"><a href="#Kubernets" class="headerlink" title="Kubernets"></a>Kubernets</h1><p><strong>Deploying the Dashboard UI</strong>：<code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</code><br><a href="https://jimmysong.io/kubernetes-handbook/guide/auth-with-kubeconfig-or-token.html" target="_blank" rel="noopener">使用 kubeconfig 或 token 进行用户身份认证</a><br><strong>生成 token</strong></p><p>需要创建一个admin用户并授予admin角色绑定，使用下面的yaml文件创建admin用户并赋予他管理员权限，然后可以通过token访问kubernetes，该文件见<a href="https://github.com/rootsongjc/kubernetes-handbook/tree/master/manifests/dashboard-1.7.1/admin-role.yaml" target="_blank" rel="noopener">admin-role.yaml</a>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 serviceaccount 和角色绑定:</span></span><br><span class="line">$ kubectl create -f admin-role.yaml</span><br><span class="line"><span class="comment"># 获取admin-token的secret名字:</span></span><br><span class="line">$ kubectl -n kube-system get secret|grep admin-token</span><br><span class="line"><span class="comment"># 获取token的值</span></span><br><span class="line">$ kubectl -n kube-system describe secret admin-token-528zm</span><br><span class="line"><span class="comment"># 使用 kubectl 提供的 Proxy 服务来访问Dashboard</span></span><br><span class="line"><span class="comment"># 如果8001端口号占用，加 --port 8002 参数</span></span><br><span class="line">kubectl proxy</span><br><span class="line"><span class="comment"># 打开如下地址：</span></span><br><span class="line"><span class="comment"># http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Screen Shot 2019-12-20 at 11.16.39 AM.png" alt="/ "><br><a href="https://spin.atomicobject.com/2019/07/11/docker-volumes-explained/" target="_blank" rel="noopener">Docker Volumes: Why, When, and Which Ones?</a></p><p><a href="https://www.dongwm.com/post/use-kubernetes-1/" target="_blank" rel="noopener">Python项目容器化实践(四) - Kubernetes基础篇</a><br><a href="https://alexioannides.com/2019/01/10/deploying-python-ml-models-with-flask-docker-and-kubernetes/" target="_blank" rel="noopener">Deploying Python ML Models with Flask, Docker and Kubernetes</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要使用Docker：“有了Docker，开发人员能够借助任何工具、使用语言来构建任何应用”。Docker化的应用是完全绿色便携的，能运行在任何平台。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://fuhailin.github.io/tags/Docker/"/>
    
      <category term="Kubernets" scheme="https://fuhailin.github.io/tags/Kubernets/"/>
    
  </entry>
  
  <entry>
    <title>树莓派4B 玩转指南</title>
    <link href="https://fuhailin.github.io/Raspberry-pi-4/"/>
    <id>https://fuhailin.github.io/Raspberry-pi-4/</id>
    <published>2019-09-10T15:32:11.000Z</published>
    <updated>2019-12-20T07:02:54.478Z</updated>
    
    <content type="html"><![CDATA[<p>我的新玩具树莓派4B到手啦，我选择的是2GB RAM版本，刷上系统先，开干!</p><a id="more"></a><h2 id="安装轻量级无图形界面系统"><a href="#安装轻量级无图形界面系统" class="headerlink" title="安装轻量级无图形界面系统"></a>安装轻量级无图形界面系统</h2><p>树莓派开发板没有配置板载FLASH，因为它支持SD卡启动，所有我们需要下载相应镜像，并将其烧写在SD上，启动系统即可。(这个镜像里包含了我们通常所说的bootloader、kernel、文件系统)</p><p>树莓派由于其开源特性，支持非常多的系统类型：</p><p>Raspbian、Arch Linux ARM、Debian Squeeze、Firefox OS、Gentoo Linux、OpenWRT、<br>Google Chrome OS、Raspberry Pi Fedora Remix、Slackware ARM<br>QtonPi、Slackware ARM、WebOS、RISC OS、FreeBSD、NetBSD、Android 4.0(Ice Cream Sandwich)</p><p>树莓派4B暂时只提供官方raspbian系统</p><p>树莓派官网的下载地址：<a href="http://www.raspberrypi.org/downloads" target="_blank" rel="noopener">http://www.raspberrypi.org/downloads</a></p><p>我下载安装的轻量化无图形界面系统为 <strong>Raspbian Buster Lite</strong> Minimal image based on Debian Buster。使用的镜像刻录工具是 <strong>balenaEtcher-1.5.56-x64.AppImage</strong>。</p><h2 id="启动树莓派"><a href="#启动树莓派" class="headerlink" title="启动树莓派"></a>启动树莓派</h2><p>烧写完后把MicroSD卡直接插入树莓派的MicroSD卡插槽，另外我们给莓派连接显示器、电源、鼠标、键盘，打开数据线上的电源开关以后，就可以进入树莓派系统了。正常情况下红色电源灯常亮，绿色信号灯不规律闪烁。红灯偶尔出现灭的情况可能是供电不足，只要系统可以正常进入就可以了。</p><h2 id="连接WiFi"><a href="#连接WiFi" class="headerlink" title="连接WiFi"></a>连接WiFi</h2><p><code>sudo raspi-config</code>：选择【2 Network Options】-&gt;【N2 Wi-fi】-&gt;输入SSID、密码。<br><code>sudo iwlist wlan0 scan</code>：扫描树莓派已经识别的wifi</p><h2 id="启用SSH"><a href="#启用SSH" class="headerlink" title="启用SSH"></a>启用SSH</h2><p><code>sudo raspi-config</code>：选择【5 Interface Options】-&gt;[SSH]进行SSH的启用</p><h2 id="更换国内源"><a href="#更换国内源" class="headerlink" title="更换国内源"></a>更换国内源</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib</span><br><span class="line"></span><br><span class="line"># 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br></pre></td></tr></tbody></table></figure><p>使用<code>sudo apt-get update</code>进行更新</p><h2 id="显示CPU温度"><a href="#显示CPU温度" class="headerlink" title="显示CPU温度"></a>显示CPU温度</h2><p><code>cat /sys/class/thermal/thermal_zone0/temp</code>：返回值除以1000极为当前CPU温度</p><h2 id="必备软件安装"><a href="#必备软件安装" class="headerlink" title="必备软件安装"></a>必备软件安装</h2><p><code>sudo apt install vim tmux git</code>：安装VIM、tmux、git<br>安装Python3：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line">chmod +x Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line">./Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line"></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>curl -sLf https://spacevim.org/install.sh | bash</code>：配置SpaceVim</p><p><strong>安装Docker</strong>:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sL get.docker.com | sed <span class="string">'s/9)/10)/'</span> | sh</span><br><span class="line">pip3 config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">sudo pip3 install docker-compose</span><br></pre></td></tr></tbody></table></figure><br>更换Docker清华镜像<br><code>sudo vim /etc/apt/sources.list.d/docker.list</code>:<br><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb [arch=armhf] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/raspbian buster stable</span><br></pre></td></tr></tbody></table></figure><br><a href="https://mirror.tuna.tsinghua.edu.cn/help/docker-ce/" target="_blank" rel="noopener">Docker Community Edition 镜像使用帮助</a><p></p><h2 id="关机与重启"><a href="#关机与重启" class="headerlink" title="关机与重启"></a>关机与重启</h2><p><code>sudo shutdown</code>：一分钟之后关机，<code>shutdown -c</code>取消关机<br><code>sudo shutdown now</code>：立即关机<br><code>sudo reboot</code>、<code>sudo shutdown -r</code>：重新启动<br><code>sudo shutdown 11:00</code>：上午11:00定时关机<br><code>sudo shutdown +10</code>：10分钟后关机</p><h2 id="打造树莓派路由器"><a href="#打造树莓派路由器" class="headerlink" title="打造树莓派路由器"></a>打造树莓派路由器</h2><p><a href="https://github.com/billz/raspap-webgui" target="_blank" rel="noopener">billz/<strong>raspap-webgui</strong></a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name=gitea -p 1008x:3000 -v /var/lib/gitea:/data --restart unless-stopped kunde21/gitea-arm:latest</span><br></pre></td></tr></tbody></table></figure><h2 id="打造私人git服务器"><a href="#打造私人git服务器" class="headerlink" title="打造私人git服务器"></a>打造私人git服务器</h2><p><strong>安装Gitea</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitea/gitea:latest</span><br><span class="line"></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line">sudo mkdir -p /var/lib/gitea</span><br><span class="line"></span><br><span class="line">docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /var/lib/gitea:/data gitea/gitea:latest</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="打造家用云服务器"><a href="#打造家用云服务器" class="headerlink" title="打造家用云服务器"></a>打造家用云服务器</h2><p><strong>安装NextCloudPi</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Start docker with custom storage volume with:</span><br><span class="line">sudo mkdir /media/ncdata</span><br><span class="line"># 主机80端口已被raspap-webgui占用</span><br><span class="line">docker run -d -p 4443:4443 -p 443:443 -p 81:80 -v /media/ncdata:/data --name nextcloudpi ownyourbits/nextcloudpi-armhf $DOMAIN</span><br><span class="line"># 观察nextcloudpi的安装进度</span><br><span class="line">docker logs -f nextcloudpi</span><br></pre></td></tr></tbody></table></figure><p></p><p>Login with user <code>pi</code> and password <code>raspberry</code>(&lt;- For default).<br><strong>进入系统设置</strong><br><code>sudo raspi-config</code><br><strong>进入nextcloud app 设置</strong><br><code>sudo sudo ncp-config</code><br><a href="https://docs.nextcloudpi.com/en/how-to-get-started-with-ncp-docker/" target="_blank" rel="noopener">https://docs.nextcloudpi.com/en/how-to-get-started-with-ncp-docker/</a></p><h2 id="挂载移动硬盘并设置Samba共享"><a href="#挂载移动硬盘并设置Samba共享" class="headerlink" title="挂载移动硬盘并设置Samba共享"></a>挂载移动硬盘并设置Samba共享</h2><p><strong>挂载硬盘</strong><br>我的硬盘之前安装过Ubuntu系统，因此为ext4文件系统，树莓派的是Debian系统可以直接读取ext4文件系统，因此挂载后可以直接读取，如果是Windows的NTFS系统需要另外处理<br>插上硬盘，查看状态：sudo fdisk -l<br>新建一个目录 ，让树莓派将硬盘挂载到创建的目录：<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/toshiba</span><br><span class="line">sudo mount /dev/sda2  /mnt/data</span><br></pre></td></tr></tbody></table></figure><br>还可以设置开机自动挂载<p></p><p><strong>Samba</strong><br>sudo apt install samba samba-common-bin<br>sudo vim /etc/samba/smb.conf<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pi]           # Name will show on Internet</span><br><span class="line">path = /mnt/data</span><br><span class="line">valid users = pi</span><br><span class="line">browseable = yes</span><br><span class="line">public = yes</span><br><span class="line">writable = yes</span><br></pre></td></tr></tbody></table></figure><br>设置<code>pi</code>用户的密码：sudo smbpasswd -a pi<br>重启Samba服务：sudo systemctl restart smbd.service<p></p><p>打开MacOS的finder，从<code>Go</code>选项中点击<code>Connect to Server…</code>，输入树莓派Samba地址：<code>192.168.1.3/pi</code>输入用户名密码即可完成连接。</p><hr><p><a href="https://docs.gitea.io/zh-tw/install-with-docker/" target="_blank" rel="noopener">https://docs.gitea.io/zh-tw/install-with-docker/</a></p><p><a href="https://docs.gitea.io/zh-cn/install-with-docker/" target="_blank" rel="noopener">https://docs.gitea.io/zh-cn/install-with-docker/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的新玩具树莓派4B到手啦，我选择的是2GB RAM版本，刷上系统先，开干!&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://fuhailin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Raspbian" scheme="https://fuhailin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Raspbian/"/>
    
    
      <category term="Linux" scheme="https://fuhailin.github.io/tags/Linux/"/>
    
      <category term="Raspberry" scheme="https://fuhailin.github.io/tags/Raspberry/"/>
    
  </entry>
  
  <entry>
    <title>Smart Beta</title>
    <link href="https://fuhailin.github.io/Smart-Beta/"/>
    <id>https://fuhailin.github.io/Smart-Beta/</id>
    <published>2019-08-21T09:06:41.000Z</published>
    <updated>2019-11-26T02:52:39.219Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DeepWalk</title>
    <link href="https://fuhailin.github.io/DeepWalk/"/>
    <id>https://fuhailin.github.io/DeepWalk/</id>
    <published>2019-08-20T14:57:46.000Z</published>
    <updated>2019-11-26T02:52:39.218Z</updated>
    
    <content type="html"><![CDATA[<p>DeepWalk(2014’KDD)，一种用于学习网络中顶点的潜在表示方法.DeepWalk提出了新的、无监督的、独立于标签分布的（捕获结构信息时不考虑标签）、捕获图结构信息的算法。算法目标是学习图的结构特征<script type="math/tex">\mathbf{X}_{\mathrm{E}} \in \mathbf{R}^{|\mathbf{V}| \times \mathbf{d}}</script>，其中d是节点的潜在表示（向量形式）的维数。图结构特征可以用于任何分类算法。将<script type="math/tex">\mathbf{X}_{\mathrm{E}} \in \mathbf{R}^{|\mathbf{V}| \times \mathbf{d}}</script>与简单的机器学习算法集成，还可以用来实现很多其他问题。<br><a id="more"></a></p><p>图的表示：令G =(V,E)，其中V表示网络的节点，E是网络中的连接，E⊆ (V×V)。<br>GL=(V,E,X,Y)是部分标记的社交网络。X是各个节点的属性空间，X∈R|V|×S，其中S是每个节点的属性向量的特征空间的大小；Y∈R|V|×|Y|，Y是标签的集合。</p><p><a href="https://github.com/phanein/deepwalk" target="_blank" rel="noopener">phanein/deepwalk</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DeepWalk(2014’KDD)，一种用于学习网络中顶点的潜在表示方法.DeepWalk提出了新的、无监督的、独立于标签分布的（捕获结构信息时不考虑标签）、捕获图结构信息的算法。算法目标是学习图的结构特征&lt;script type=&quot;math/tex&quot;&gt;\mathbf{X}_{\mathrm{E}} \in \mathbf{R}^{|\mathbf{V}| \times \mathbf{d}}&lt;/script&gt;，其中d是节点的潜在表示（向量形式）的维数。图结构特征可以用于任何分类算法。将&lt;script type=&quot;math/tex&quot;&gt;\mathbf{X}_{\mathrm{E}} \in \mathbf{R}^{|\mathbf{V}| \times \mathbf{d}}&lt;/script&gt;与简单的机器学习算法集成，还可以用来实现很多其他问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="https://fuhailin.github.io/elasticsearch/"/>
    <id>https://fuhailin.github.io/elasticsearch/</id>
    <published>2019-08-14T08:58:15.000Z</published>
    <updated>2019-11-26T02:52:39.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p><h1 id="Linux上的安装"><a href="#Linux上的安装" class="headerlink" title="Linux上的安装"></a>Linux上的安装</h1><blockquote><p>jdk至少需要在1.8.0_73以上版本</p></blockquote><a id="more"></a><p>解压文件<code>tar -zxvf elasticsearch-x.x.x.tar.gz</code>，<code>./bin/elasticsearch</code>为启动文件，但如果此时直接启动elasticsearch的话，会报错<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/Image 3.png" alt=""><br>原因是elasticsearch默认不支持root用户运行，因为正式环境用root运行可能会有安全风险，不建议用root来跑。我们可以单独为elasticsearch单独创建一个用户<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m elastic -s /bin/bash          <span class="comment">#创建elastic用户，并使用/bin/bash作为shell</span></span><br><span class="line">sudo passwd elastic                           <span class="comment">#为elastic用户设置密码，之后需要连续输入两次密码</span></span><br><span class="line">sudo adduser elastic sudo                     <span class="comment">#为elastic用户增加管理员权限</span></span><br><span class="line">chown -R elastic:elastic  elasticsearch-x.x.x <span class="comment">#为elastic添加文件权限</span></span><br><span class="line">su - elastic                                  <span class="comment">#切换当前用户为用户elastic</span></span><br><span class="line"><span class="built_in">cd</span> elasticsearch-x.x.x                        <span class="comment">#切换目录</span></span><br><span class="line">./bin/elasticsearch                           <span class="comment">#执行</span></span><br></pre></td></tr></tbody></table></figure><br>如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 <code>-d</code> 。<br>如果你是在 Windows 上面运行 Elasticseach，你应该运行 <code>bin\elasticsearch.bat</code> 而不是 <code>bin\elasticsearch</code> 。<br>使用 <code>curl http://localhost:9200/</code> 查看是否运行，如果返回如下信息则标示运行正常：<br><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"RjxKv_d"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"SYM-Wb6xR3mqGLx4bHtBNA"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : {</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"6.1.3"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"af51318"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2018-01-26T18:22:55.523Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"7.1.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p><a href="https://www.biaodianfu.com/centos-7-install-elasticsearch.html" target="_blank" rel="noopener">Elasticsearch在Centos 7上的安装与配置</a><br><a href="https://es.xiaoleilu.com/010_Intro/05_What_is_it.html" target="_blank" rel="noopener">Elasticsearch权威指南</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。&lt;/p&gt;
&lt;h1 id=&quot;Linux上的安装&quot;&gt;&lt;a href=&quot;#Linux上的安装&quot; class=&quot;headerlink&quot; title=&quot;Linux上的安装&quot;&gt;&lt;/a&gt;Linux上的安装&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;jdk至少需要在1.8.0_73以上版本&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="elasticsearch" scheme="https://fuhailin.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>machine learning in finance</title>
    <link href="https://fuhailin.github.io/ML-in-Finance/"/>
    <id>https://fuhailin.github.io/ML-in-Finance/</id>
    <published>2019-08-02T06:31:09.000Z</published>
    <updated>2019-11-26T02:52:39.218Z</updated>
    
    <content type="html"><![CDATA[<p><strong>沪深300指数</strong>由上海和深圳证券市场中市值大、流动性好的300只股票组成，综合反映中国A股市场上市股票价格的整体表现。<br><strong>恒生指数</strong>(Hang Seng Index)是以反映香港股市行情的重要指标，指数由五十只恒指成份股的市值计算出来的，代表了香港交易所所有上市公司的十二个月平均市值涵盖率的63%。<br><strong>标普500</strong>是由标准普尔於1957年创立的，被广泛认为是三只股指中衡量美国经济状况最好的一项指标。标普500股票平均价格指数是由每支成分股公司的市场价值之和除以一个由标准普尔设定的除数得到的终值。简而言之就是，所有股票的市值总和除以标普除数，或总市值/标普除数。<br><strong>道琼斯工业平均指数</strong>，简称道指，是三只股指中历史最为悠久也是全球最知名的股指。道指最早是在1884年由道琼斯公司的创始人查尔斯·亨利·道开始编制的一种算术平均股价指数。道指代表了华尔街日报确认的30只大盘股。不同於标普500和纳指，道指成分股的比重是根据股票价格排序的，也就是说股票价格越高的公司越能影响道指的表现。道指股票价格平均指数是入选股票的价格之和除以道指除数得到的终值。<br><strong>纳斯达克指数</strong>，简称纳指，1985年开始交易，是三只股指中最为年轻的股指。纳指代表著在纳斯达克上市的最大的非金融公司，其中科技股所占比重较大，因此通常被认为是一只科技股指。该股指是根据每个公司的市场价值来设置权重，这意味著每个公司对指数的影响力是由其市场价值决定的。</p><a id="more"></a><p><strong>市场（或代表性指数）收益率market rate of return</strong>：国内市场通常使用沪深300指数作为市场代表，美股则常用标普500指数，港股则常用恒生指数</p><p><strong>无风险利率risk-free rate</strong>：这是投资者将资金投资于某一项没有任何风险的投资对象而能得到的利息率，例如以人民币投资的中国国债、美元投资的美国国库券、以欧元交易和投资的德国政府债券等。该数字通常以百分比表示。<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-08-12-11-34-20.png" alt="Investing.com - 中国政府债券"></p><h1 id="Capital-Asset-Pricing-Model资本资产定价模型"><a href="#Capital-Asset-Pricing-Model资本资产定价模型" class="headerlink" title="Capital Asset Pricing Model资本资产定价模型"></a>Capital Asset Pricing Model资本资产定价模型</h1><p>在金融世界，人们手持多余的资金时候本能欲望都会寻求让资金尽量增长，投资因此诞生。但并不是每项投资都能带来收益，人的本能让人追求收益畏惧风险。<br>在现实世界的自由投资途径中，低风险高收益的投资项人们会蜂拥而至进行瓜分，高风险低收益的对象会逐渐被人抛弃。<br>现实世界的投资途径如此之多，有一类投资能让你保证获得收益，这类投资称为无风险收益，例如以国家信用做背书的国债和银行定期存款。但有些人为了获得更高的收益愿意承担一定的风险选择投资股市，因此有一个市场的平均收益。有没有一个收益最大风险最小的投资组合？它在哪里？这是每一个投资者每天都在考虑的问题。为了搞清这个问题，经济学家尝试简化世界，构建了CAPM模型来进行风险评估和收益预计：</p><script type="math/tex; mode=display">E(r_{i})=r_{f}+\beta[E(r_{m})-r_{f}]</script><p>其中</p><ul><li>$E(r_{i})$是资产$i$的期望收益率;</li><li>$r_{f}$是无风险收益率，通常以短期国债的利率来近似替代;</li><li>$\beta$是资产$i$的系统性风险系数;</li><li>$E(r_{m})$是市场收益率，通常用股票价格指数收益率的平均值或所有股票的平均收益率来代替;<!-- - $E(r_{m})-r_{f}$是市场风险溢价(Market Risk Premium)，即市场投资组合的期望收益率与无风险收益率之差。 -->这个简洁的模型将无风险收益与市场平均收益都考虑进来，毕竟如果没有一个预估的高收益吸引投资者，那还不如把钱存个定期。</li></ul><h1 id="Beta系数"><a href="#Beta系数" class="headerlink" title="Beta系数"></a>Beta系数</h1><p><strong>Beta系数$\beta$</strong>作为一个统计学上的概念，用以度量一项资产系统性风险的指标，是资本资产定价模型的参数之一。指用以衡是资产i的系统性风险系数，量一种证券或一个投资证券组合相对总体市场的波动性的一种证券系统性风险的评估工具。Beta系数可用于计算股票的预期收益率。Beta系数是股票分析师们在选择资产组合中的股票时要考虑的基本因素之一，其他因素包括市盈率、股东权益、资本负债比率等。</p><ul><li>如果是负值，则显示其变化的方向与大盘的变化方向相反;大盘涨的时候它跌，大盘跌的时候它涨；有一些行业组织，如黄金矿工，其中负beta很常见。</li><li>$\beta$ =0，表示投资组合和市场走向没有相关性，如固定收益类；</li><li>当$\beta$=1，说明投资对象的价值与市场强烈相关。在投资组合中加入Beta为1的股票并没有增加任何风险，也没有增加获得超额收益的可能性。</li><li>当$\beta$&lt;1，显示其价值波动理论上小于市场，意味着在投资组合中加入这样的对象能减小风险，公共事业股票utility stocks通常有较低的beta，因为它们变化往往比市场平均值更慢。</li><li>当$\beta$&gt;1，显示其价值波动理论上大于市场。例如如果一个股票的Beta为1.2，说明其比市场还多20%的波动性，科技股通常拥有比市场基准更高的beta，这样的对象会增加投资组合的风险但也更可能带来超额收益。</li></ul><h2 id="Beta系数有什么用"><a href="#Beta系数有什么用" class="headerlink" title="Beta系数有什么用;"></a>Beta系数有什么用;</h2><ul><li>使用Beta来选择股票是减少波动性和创建更多元化投资组合的工具之一。</li><li>计算资本成本，进行资产估值、做出投资决策、制定考核及激励标准</li><li>计算单个资产或组合的系统风险(投资组合的Beta等于单个Beta系数的加权求和)，进行投资管理</li><li>牛市时选择高Beta证券，将成倍放大市场收益；熊市时选择低Beta证券以抵御市场风险</li></ul><!-- ![](v4-728px-Calculate-Beta-Step-3-Version-4.jpg.jfif) --><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/download.png" alt="图中我们可以看出，谷歌股票的回报波动比较大（蓝色），标普500的回报波动比较小（橙色）"></p><h1 id="Beta系数计算方法"><a href="#Beta系数计算方法" class="headerlink" title="Beta系数计算方法"></a>Beta系数计算方法</h1><h2 id="通过相关系数计算Beta"><a href="#通过相关系数计算Beta" class="headerlink" title="通过相关系数计算Beta"></a>通过相关系数计算Beta</h2><p>既然Beta是衡量股票收益相对于市场收益的风险程度，于是可以通过计算两者的相关系数来确定Beta：</p><script type="math/tex; mode=display">Beta=\beta_{p}=\frac{Cov(D_{p},D_{m})}{Var(D_{m})}</script><p>其中<script type="math/tex">D_{p}</script>为策略每日收益，<script type="math/tex">D_{m}</script>为大盘每日收益，<script type="math/tex">Cov(D_{p},D_{m})</script>是策略每日收益与大盘每日收益的协方差,<script type="math/tex">Var(D_{m})</script>为大盘每日收益方差</p><h2 id="通过历史已知的策略收益反推"><a href="#通过历史已知的策略收益反推" class="headerlink" title="通过历史已知的策略收益反推"></a>通过历史已知的策略收益反推</h2><p>在CAPM模型中如果已知历史策略收益，那么带入已知项可求得Beta：</p><script type="math/tex; mode=display">Beta=\beta_{p}=\frac{E(r_{i})-r_{f}}{E(r_{m})-r_{f}}</script><h2 id="通过线性回归拟合"><a href="#通过线性回归拟合" class="headerlink" title="通过线性回归拟合"></a>通过线性回归拟合</h2><p>既然在CAPM模型中Beta作为市场收益减去无风险收益的系数，对于历史已知的股票收益，</p><script type="math/tex; mode=display">R_{p}=\alpha+\beta_{p} R_{m}+\varepsilon</script><p>将大盘收益率作为Y，将策略历史收益率作为X进行回归，$\varepsilon$是建模误差。通过最小化回归方程预测的 y 值与实际 y 值之间的平方差（垂直距离），能够得到一条最合理的回归直线，直线与Y轴截距是事后的 $\alpha$，即与市场指数回报相比，超额回报的衡量。如果截距是负数，则意味着策略在风险调整的基础上表现落后于大盘，而截距是正数，则意味着其在风险调整基础上有超额收益。回归线的斜率系数 Beta 被计算为 x 和 y 的协方差除以 x 的方差，在数学上与方式一是一致的。</p><p>这种方式得出的Beta值相对稳定<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/download1.png" alt=""></p><h1 id="Alpha系数"><a href="#Alpha系数" class="headerlink" title="Alpha系数"></a>Alpha系数</h1><p>实际风险回报和平均预期风险回报的差额即 α 系数。<br>投资中面临着系统性风险(即$\beta$)和非系统性风险(即$\alpha$)，$\alpha$是投资者获得与市场波动无关的回报。比如</p><ul><li>α&gt;0，表示一基金或股票的价格可能被低估，建议买入。亦即表示该基金或股票以投资技术获得比平均预期回报大的实际回报。较高的α一般由股票的个性特征所决定，与大势和行业无关，应尽可能寻找高α的个股。</li><li>α&lt;0，表示一基金或股票的价格可能被高估，建议卖空。亦即表示该基金或股票以投资技术获得比平均预期回报小的实际回报。</li><li>α=0，表示一基金或股票的价格准确反映其内在价值，未被高估也未被低估。亦即表示该基金或股票以投资技术获得平均与预期回报相等的实际回报。</li></ul><h1 id="Alpha的计算"><a href="#Alpha的计算" class="headerlink" title="Alpha的计算"></a>Alpha的计算</h1><p>alpha是超额收益，它与市场波动无关，也就是说不是靠系统性的上涨而获得收益。</p><script type="math/tex; mode=display">Alpha=\alpha=\mathrm{R}_{p}-\left[R_{f}+\beta *\left(R_{m}-R_{f}\right)\right]</script><h1 id="使用Python计算Beta及Alpha系数"><a href="#使用Python计算Beta及Alpha系数" class="headerlink" title="使用Python计算Beta及Alpha系数"></a>使用Python计算Beta及Alpha系数</h1><h2 id="CAPM及Beta、Alpha系数的局限"><a href="#CAPM及Beta、Alpha系数的局限" class="headerlink" title="CAPM及Beta、Alpha系数的局限"></a>CAPM及Beta、Alpha系数的局限</h2><p>Beta系数为股票评估提供了参考，但它具有它固有的局限性。尽管Beta可用于确定证券的短期风险，并用于CAPM分析波动率以计算股权成本，由于β系数是使用历史数据点计算的，因此对于希望预测股票未来走势的投资者来说，它变得没那么有意义。Beta对长期投资的作用也不大，因为股票的波动性每年都会发生显着变化，具体取决于公司的增长阶段和其他因素。</p><p>CAPM(资产资本定价模型)是在金融经济学中发挥了广泛的应用，但其作为对理想情况的一个建模，建立在假设投资者信息对等、投资行为不会对股票价格产生影响的前提下。有研究学者指出，CAPM不适用于中国股票市场，收益率和Beta之间并不是线性相关。</p><p>许多学者提出异议，认为市场过于“有效”，投资者除非碰巧，否则无法重复地赚得超额收益。另一方面，由Russ Wermers领衔的对共同基金的实证研究得到的结论认为，基金经理寻找、挑选有正α值的证券是有价值的。然而这一研究结论遭到非议，批评者认为Russ的结论受到“幸存者偏差”的影响。虽然受到争议，詹森阿尔法仍然被广泛的用于评价基金经理表现。</p><p><strong>Good References:</strong></p><ol><li><a href="https://www.cnvar.cn/2019/01/11/beta-calculation-linear-regression/" target="_blank" rel="noopener">贝塔值（beta）的线性回归方法实践</a></li><li><a href="https://zh.wikihow.com/%E8%AE%A1%E7%AE%97%E8%82%A1%E7%A5%A8%E7%9A%84-Beta-%E7%B3%BB%E6%95%B0" target="_blank" rel="noopener">如何计算股票的 Beta 系数</a></li><li><a href="https://www.money-zine.com/investing/stocks/stock-beta-and-volatility/" target="_blank" rel="noopener">Stock Beta and Volatility</a></li><li><a href="https://www.cnvar.cn/2017/08/28/negative-betas/" target="_blank" rel="noopener">贝塔系数(Betas)能否为负数?一个经常被问到的面试问题</a></li><li><a href="https://xueqiu.com/2551686004/129137796" target="_blank" rel="noopener">沪深300指数与标普500指数差距有多大？</a></li><li><a href="https://xueqiu.com/2551686004/102206316" target="_blank" rel="noopener">跨越半个世纪的资产配置量化研究，少踩坑，多赚钱</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;沪深300指数&lt;/strong&gt;由上海和深圳证券市场中市值大、流动性好的300只股票组成，综合反映中国A股市场上市股票价格的整体表现。&lt;br&gt;&lt;strong&gt;恒生指数&lt;/strong&gt;(Hang Seng Index)是以反映香港股市行情的重要指标，指数由五十只恒指成份股的市值计算出来的，代表了香港交易所所有上市公司的十二个月平均市值涵盖率的63%。&lt;br&gt;&lt;strong&gt;标普500&lt;/strong&gt;是由标准普尔於1957年创立的，被广泛认为是三只股指中衡量美国经济状况最好的一项指标。标普500股票平均价格指数是由每支成分股公司的市场价值之和除以一个由标准普尔设定的除数得到的终值。简而言之就是，所有股票的市值总和除以标普除数，或总市值/标普除数。&lt;br&gt;&lt;strong&gt;道琼斯工业平均指数&lt;/strong&gt;，简称道指，是三只股指中历史最为悠久也是全球最知名的股指。道指最早是在1884年由道琼斯公司的创始人查尔斯·亨利·道开始编制的一种算术平均股价指数。道指代表了华尔街日报确认的30只大盘股。不同於标普500和纳指，道指成分股的比重是根据股票价格排序的，也就是说股票价格越高的公司越能影响道指的表现。道指股票价格平均指数是入选股票的价格之和除以道指除数得到的终值。&lt;br&gt;&lt;strong&gt;纳斯达克指数&lt;/strong&gt;，简称纳指，1985年开始交易，是三只股指中最为年轻的股指。纳指代表著在纳斯达克上市的最大的非金融公司，其中科技股所占比重较大，因此通常被认为是一只科技股指。该股指是根据每个公司的市场价值来设置权重，这意味著每个公司对指数的影响力是由其市场价值决定的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Outfits dataset</title>
    <link href="https://fuhailin.github.io/Outfits-dataset/"/>
    <id>https://fuhailin.github.io/Outfits-dataset/</id>
    <published>2019-07-25T13:39:08.000Z</published>
    <updated>2019-11-26T02:52:39.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Task："><a href="#Task：" class="headerlink" title="Task："></a>Task：</h1><p>1、Fill in the blank</p><p>2、Outfit generation given texts or images</p><p>3、 Compatibility prediction</p><a id="more"></a><h1 id="Dataset："><a href="#Dataset：" class="headerlink" title="Dataset："></a>Dataset：</h1><p><strong>The Polyvore dataset</strong></p><p>是一个流行的时尚搭配网站，用户可以自由搭配喜欢的时装配饰等单品，并通过在线社区分享，同时了解其它用户的穿衣搭配。Polyvore数据集是从Polyvore.com上爬取的用户搭配方案与单品信息数据集，根据爬取的数量不同有多个不同的版本。网络上公开可用的The Polyvore dataset 有 <a href="https://github.com/xthan/polyvore-datasepolyvore-datasett" target="_blank" rel="noopener">polyvore-dataset</a> 等，其中包含的搭配Outfits方案数与单品Items数量如下：</p><blockquote><p><code>#Outfits</code>: 21889 (17316 for training, 1497 for validation and 3076 for testing)<br><code>#Categories</code>: 380<br><code>#Items</code>: 164,379<br>Max Items/Outfit: 8<br>Average Items/Outfit: 6.5<br>Text Available?: Titles &amp; Descriptions</p></blockquote><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-07-25-23-05-54.png" alt=""></p><p><a href="https://drive.google.com/drive/folders/0B4Eo9mft9jwoVDNEWlhEbUNUSE0" target="_blank" rel="noopener">polyvore-images.tar.gz</a> 是一个更大的版本（33,375 outfits），polyvore-dataset为其真子集。</p><h2 id="论文中相关数据使用情况："><a href="#论文中相关数据使用情况：" class="headerlink" title="论文中相关数据使用情况："></a>论文中相关数据使用情况：</h2><p><a href="https://arxiv.org/abs/1707.05691" target="_blank" rel="noopener">Learning Fashion Compatibility with Bidirectional LSTMs</a> “只用了polyvore-dataset”<br><a href="https://arxiv.org/abs/1902.08009" target="_blank" rel="noopener">Dressing as a Whole: Outfit Compatibility Learning Based on Node-wise Graph Neural Networks</a> “只用了polyvore-dataset”<br><a href="https://arxiv.org/abs/1803.09196" target="_blank" rel="noopener">Learning Type-Aware Embeddings for Fashion Compatibility</a> “只用了自己爬取的更大的polyvore数据集”<br><a href="https://github.com/WangXin93/fashion_compatibility_mcn" target="_blank" rel="noopener">Outfit Compatibility Prediction and Diagnosis with Multi-Layered Comparison Network</a>:尚未公开论文，但从代码看就polyvore-dataset一个数据集</p><!--**The Fashion-Gen Outfits dataset****Amazon products dataset** --><h1 id="Learning-Fashion-Compatibility-with-Bidirectional-LSTMs"><a href="#Learning-Fashion-Compatibility-with-Bidirectional-LSTMs" class="headerlink" title="Learning Fashion Compatibility with Bidirectional LSTMs"></a>Learning Fashion Compatibility with Bidirectional LSTMs</h1><p>将一个搭配方案视为从上到下然后到饰品的单品序列。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Task：&quot;&gt;&lt;a href=&quot;#Task：&quot; class=&quot;headerlink&quot; title=&quot;Task：&quot;&gt;&lt;/a&gt;Task：&lt;/h1&gt;&lt;p&gt;1、Fill in the blank&lt;/p&gt;
&lt;p&gt;2、Outfit generation given texts or images&lt;/p&gt;
&lt;p&gt;3、 Compatibility prediction&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark编程指南</title>
    <link href="https://fuhailin.github.io/Spark-Programming-Tutorial/"/>
    <id>https://fuhailin.github.io/Spark-Programming-Tutorial/</id>
    <published>2019-05-24T10:34:02.000Z</published>
    <updated>2019-11-26T02:52:39.217Z</updated>
    
    <content type="html"><![CDATA[<p>Spark编程指南、API文档：  <a href="https://spark.apache.org/docs/latest/#spark-overview" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/#spark-overview</a><br><a id="more"></a></p><h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><p>Spark支持的文件读写来源有：文件系统(本地文件系统、HDFS、远程Amazon S3)、数据库(MySQL、HBase、Hive)<br>SPark支持支持很多其他常见的文件格式：文本文件、JSON、CSV、SequenceFile，以及protocol buffer<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/1136325-20170915111603547-1070150402.png" alt=""></p><h2 id="读取本地文件系统"><a href="#读取本地文件系统" class="headerlink" title="读取本地文件系统"></a>读取本地文件系统</h2><p>要加载本地文件，必须采用<code>file:///</code>开头的这种格式;<br><code>Spark 将传入的路径作为目录对待，会在那个目录下输出多个文件</code><br>如果路径简写为<code>path/to/somewhere</code>，<code>sc.textFile()</code>将默认认为其为HDFS路径<br></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">myRdd = sc.textFile(<span class="string">"file:///home/holden/repos/spark/README.md"</span>) <span class="comment">#读取本地文本文件</span></span><br><span class="line"></span><br><span class="line">outputFile = <span class="string">"file:///home/holden/repos/spark/result.txt"</span> <span class="comment"># 保存为本地文本文件</span></span><br><span class="line">myRdd.saveAsTextFile(outputFile)</span><br><span class="line"></span><br><span class="line">myRdd = sc.textFile(<span class="string">"hdfs://master:9000/user/root/people.txt"</span>) <span class="comment"># 从HDFS加载数据</span></span><br><span class="line"></span><br><span class="line">myRdd = sc.textFile(<span class="string">"s3://your_bucket/"</span>) <span class="comment"># 从 AWS s3 加载数据</span></span><br><span class="line">myRDD.saveAsTextFile(<span class="string">"s3://your_bucket/test/"</span>)  <span class="comment"># 将数据保存到 AWS s3</span></span><br><span class="line"></span><br><span class="line">jsonRdd = sc.textFile(<span class="string">"file:///usr/local/people.json"</span>) <span class="comment"># 加载JSON文件</span></span><br><span class="line"></span><br><span class="line">myRdd = sc.read.format(<span class="string">'csv'</span>)</span><br><span class="line">               .options(header=<span class="string">'true'</span>, inferSchema=<span class="string">'true'</span>)</span><br><span class="line">               .load(<span class="string">'/diamonds.csv'</span>) <span class="comment"># 读取CSV文件</span></span><br><span class="line"></span><br><span class="line">df.write.parquet(<span class="string">"output/proto.parquet"</span>)</span><br><span class="line"><span class="comment"># using SQLContext to read parquet file</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SQLContext</span><br><span class="line">sqlContext = SQLContext(sc)</span><br><span class="line"></span><br><span class="line">df = sqlContext.read.parquet(<span class="string">"output/proto.parquet"</span>)</span><br></pre></td></tr></tbody></table></figure><br><a href="https://hadoop.apache.org/docs/r1.2.1/file_system_shell.html" target="_blank" rel="noopener">File System Shell Guide</a><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spark编程指南、API文档：  &lt;a href=&quot;https://spark.apache.org/docs/latest/#spark-overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://spark.apache.org/docs/latest/#spark-overview&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://fuhailin.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="https://fuhailin.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Scala刚刚入门的学习笔记</title>
    <link href="https://fuhailin.github.io/Hello-Scala/"/>
    <id>https://fuhailin.github.io/Hello-Scala/</id>
    <published>2019-05-21T03:44:14.000Z</published>
    <updated>2019-11-26T02:52:39.217Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="http://twitter.github.io/scala_school/basics.html" target="_blank" rel="noopener">Basics</a></strong>：Values, functions, classes, methods, inheritance, try-catch-finally. Expression-oriented programming<br><strong><a href="http://twitter.github.io/scala_school/basics2.html" target="_blank" rel="noopener">Basics continued</a></strong>：Case classes, objects, packages, apply, update, Functions are Objects (uniform access principle), pattern matching.<br><strong><a href="http://twitter.github.io/scala_school/collections.html" target="_blank" rel="noopener">Collections</a></strong>：Lists, Maps, functional combinators (map, foreach, filter, zip, folds)<br><strong><a href="http://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html" target="_blank" rel="noopener">Pattern matching &amp; functional composition</a></strong>：More functions! PartialFunctions, more Pattern Matching<br><strong><a href="http://twitter.github.io/scala_school/type-basics.html" target="_blank" rel="noopener">Type &amp; polymorphism basics</a></strong>：Basic Types and type polymorphism, type inference, variance, bounds, quantification<br><strong><a href="http://twitter.github.io/scala_school/advanced-types.html" target="_blank" rel="noopener">Advanced types</a></strong>: Advanced Types, view bounds, higher-kinded types, recursive types, structural types<br><strong><a href="http://twitter.github.io/scala_school/sbt.html" target="_blank" rel="noopener">Simple Build Tool</a>:</strong> All about SBT, the standard Scala build tool<br><strong><a href="http://twitter.github.io/scala_school/coll2.html" target="_blank" rel="noopener">More collections</a></strong>: Tour of the Scala Collections library<br><strong><a href="http://twitter.github.io/scala_school/specs.html" target="_blank" rel="noopener">Testing with specs</a></strong>:<br><strong><a href="http://twitter.github.io/scala_school/concurrency.html" target="_blank" rel="noopener">Concurrency in Scala</a>:</strong> Runnable, Callable, threads, Futures<br><strong><a href="http://twitter.github.io/scala_school/java.html" target="_blank" rel="noopener">Java + Scala</a></strong>: Java interop: Using Scala from Java<br><strong><a href="http://twitter.github.io/scala_school/finagle.html" target="_blank" rel="noopener">An introduction to Finagle</a></strong>: Finagle primitives: Future, Service, Filter, Builder<br><strong><a href="http://twitter.github.io/scala_school/searchbird.html" target="_blank" rel="noopener">Searchbird</a></strong>: Building a distributed search engine using Finagle</p><p><strong><a href="http://twitter.github.io/scala_school/" target="_blank" rel="noopener">Scala School!</a></strong><br><a href="https://www.52cs.com/archives/3077" target="_blank" rel="noopener">一个简洁的scala快速教程</a><br><a href="http://dblab.xmu.edu.cn/blog/spark/" target="_blank" rel="noopener">子雨大数据之Spark入门教程（Scala版）</a><br><a href="https://www.runoob.com/scala/scala-tutorial.html" target="_blank" rel="noopener">Scala 教程|菜鸟教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      Scala上手教程
    
    </summary>
    
      <category term="大数据" scheme="https://fuhailin.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Scala" scheme="https://fuhailin.github.io/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>自然常数e到底自然在哪？</title>
    <link href="https://fuhailin.github.io/Euler-number/"/>
    <id>https://fuhailin.github.io/Euler-number/</id>
    <published>2019-05-10T02:42:15.000Z</published>
    <updated>2019-11-26T02:52:39.217Z</updated>
    
    <content type="html"><![CDATA[<p>自然常数$e$是一个奇妙的数字，这里的$e$并不仅仅代表一个字母，它还是一个数学中的无理常数，约等于2.718281828459。<br>但你是否有想过，它到底怎么来的呢？为啥一个无理数却被人们称之为“自然常数”？<br></p><a id="more"></a><p>说到$e$，我们会很自然地想起另一个无理常数$\pi$。$\pi$的含义可以通过下图中的内接与外切多边形的边长逼近来很形象的理解。<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/641.jfif" alt="图片来源: betterexplained"></p><p>假设一个圆的直径为1，其外切与内接多边形的周长可以构成$\pi$ 的估计值的取值范围上下限，内接与外切多边形的边越多，取值范围就越窄，只要边数足够多，取值范围上下限就可以越来越逼近圆周率$\pi$ 。</p><p>如果说$\pi$ 的计算很直观，那$e$呢？所以在此也用一种图解法来直观理解e。</p><p>首先，我们需要知道e 这个表示自然底数的符号是由瑞士数学和物理学家Leonhard Euler(莱昂纳德·欧拉)命名的，取的正是Euler的首字母“e ”。</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/640.jpg" alt="Leonhard Euler (1707-1783)"><br>但实际上，第一个发现这个常数的，并非欧拉本人，而是雅可比·伯努利（Jacob Bernoulli）。</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/641.jpg" alt="伯努利家族"></p><p>伯努利家族是17〜18世纪瑞士的一个赫赫有名的家族，其中出了很多著名的数理科学家，雅可比·伯努利是约翰·伯努利（Johann Bernoulli）的哥哥，而约翰·伯努利则是欧拉的数学老师。总之，大佬们之间有着千丝万缕的联系。<br></p><p>要了解e 的由来，一个最直观的方法是引入一个经济学名称“<span style="color:red"><strong>复利(Compound Interest)</strong></span>”。</p><blockquote><p><strong>复利率法</strong>（英文：compound interest），是一种计算利息的方法。按照这种方法，利息除了会根据本金计算外，新得到的利息同样可以生息，因此俗称“利滚利”、“驴打滚”或“利叠利”。只要计算利息的周期越密，财富增长越快，而随着年期越长，复利效应亦会越为明显。—— 维基百科</p></blockquote><p>在引入“<strong>复利模型</strong>”之前，先试着看看更基本的 “指数增长模型”。</p><p>我们知道，大部分细菌是通过二分裂进行繁殖的，假设某种细菌1天会分裂一次，也就是一个增长周期为1天，如下图，这意味着：<strong>每一天，细菌的总数量都是前一天的两倍</strong>。<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510111844.png" alt="(图片来源: betterexplained)"></p><p>显然，如果经过$x$天（或者说，经过个增长周期）的分裂，就相当于翻了$x$倍。在第$x$天时，细菌总数将是初始数量的$2x$倍。如果细菌的初始数量为1，那么$x$天后的细菌数量即为$2x$：</p><script type="math/tex; mode=display">\mathbf{细菌数量}=2^{x}</script><p>如果假设初始数量为$K$，那么$x$天后的细菌数量则为$K\cdot 2x$：</p><script type="math/tex; mode=display">\mathbf{细菌数量}=K\cdot 2^{x}</script><p>因此，只要保证所有细菌一天分裂一次，不管初始数量是多少，最终数量都将是初始数量的2x 倍。因此也可以写为：</p><script type="math/tex; mode=display">Q=2^{x}</script><p>上式含义是：<strong>第$x$天时，细菌总数量是细菌初始数量的$Q$倍</strong>。</p><p>如果将 “<strong>分裂</strong>”或“<strong>翻倍</strong>”换一种更文艺的说法，也可以说是：“<strong>增长率为100%</strong>”。那我们可以将上式写为：</p><script type="math/tex; mode=display">Q=(1+100 \%)^{x}</script><p>当增长率不是100%，而是50%、25%之类的时候，则只需要将上式的100%换成想要的增长率即可。这样就可以得到更加普适的公式：</p><script type="math/tex; mode=display">Q=(1+r)^{x}</script><p><strong>这个公式的数学内涵是</strong>：<span style="color:red"><strong>一个增长周期内的增长率为$r$，在增长了$x$个周期之后，总数量将为初始数量的$Q$倍</strong></span>。</p><p>以上为指数增长的简单实例，下面来看看雅可比·伯努利的发现：</p><p>假设你有1元钱存在银行里，此时发生了严重的通货膨胀，银行的利率飙到了100%（夸张一下，为了方便计算）。如果银行一年付一次利息，自然在一年后你可以拿到1元的本金（蓝色圆）和1元的利息（绿色圆），总共两元的余额。<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112331.png" alt="(图片来源: betterexplained)"><br>现在银行的年利率不变，但银行为了招揽客户，推出一项惠民政策，每半年就付一次利息。那么到第六个月的时候，你就能够提前从银行拿到0.5元的利息了。<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112343.png" alt="(图片来源: betterexplained)"></p><p>机智的你会马上把这0.5元的利息再次存入银行，这0.5元的利息也将在下一结算周期产生利息(红色圆)，专业术语叫“复利”，那么年底的存款余额将等于2.25元。<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112351.png" alt="(图片来源: betterexplained)"></p><p>此时，我们可以换个角度这样看：即，每个结算（增长）周期为半年，每半年的利率是50%（或者说100%/2），一年结算两次利息，且第一次结算完后，立马将利息存入。此时我们的计算公式和结果如下：</p><script type="math/tex; mode=display">Q=\left(1+\frac{100 \%}{2}\right)^{2}=2.25</script><p>继续，假设现在银行为了和其他银行抢生意，短期不想赚钱了，每四个月就付一次利息！而机智的你依然一拿到利息就立马存入，与半年结算一次利息类似：即，每个结算周期为四个月，每四个月的利率是33.33%（或者说100%/3），一年结算三次利息，且前两次结算完后，都立马将所有利息存入。<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112417.png" alt=""></p><p>此时计算公式和结果如下：</p><script type="math/tex; mode=display">Q=\left(1+\frac{100 \%}{3}\right)^{3} \approx 2.37037</script><p>我的天，年利率虽然没有变，但随着每年利息交付次数的增加，你年底能从银行拿到的钱居然也在增加！</p><p>那么是不是会一直增大到无穷大呢？想得倒美…</p><p>现在假设存款人和银行都疯了，银行在保证年利率为100%的前提下连续不断地付给存款人利息，存款人天天呆在银行不走，拿到利息就往银行里存。这样，所得利息即所谓“<span style="color:red"><strong>连续复利</strong></span>”。</p><p>但是，你会发现，似乎有一个“天花板”挡住了你企图靠1块钱疯狂赚取1个亿的小目标，这个“天花板”就是$e$ ！<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112410.jpg" alt=""></p><p>如果，我们进行一系列的迭代运算，我们将看到以下结果：<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112404.png" alt=""><br>其中，$n$指的是一年中结算利息的次数。</p><p>只要在年利率保持100%不变的情况下，不断地提高利息的结算次数，余额就将会逼近$e$=2.718281845…</p><p>然后，终于可以祭出这个高等数学微积分里计算$e$的一个重要极限了：</p><script type="math/tex; mode=display">e = \mathop {\lim }\limits_{n \to \infty } \left( {1 + \frac{1}{n}} \right)^n</script><p>现在再回头看这个重要极限，想必会有更加直观的理解。</p><p>也就是说，就算银行的年利率是100%，再怎么求银行给你“复利”，年底也不可能得到超过本金e 倍的余额。况且，我是没见过哪个银行的年利率是100%。</p><p>虽然正常的银行不会推出连续复利这种优惠政策，但在自然界中，大多数事物都处在一种“无意识的连续增长”状态中。对于一个连续增长的事物，如果单位时间的增长率为100%，那么经过一个单位时间后，其将变成原来的$e$倍。生物的生长与繁殖，就也类似于“利滚利”的过程。</p><p>再比如，在等角螺线中：<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20190510112358.png" alt="等角螺线"></p><p>如果用极坐标表示，其通用数学表达式为：</p><script type="math/tex; mode=display">r=a \cdot e^{b \cdot \theta}</script><p>其中，$a$、$b$ 为系数，$r$ 螺线上的点到坐标原点的距离，$θ$ 为转角。这正是一个以自然常数$e$为底的指数函数。</p><p>例如，鹦鹉螺外壳切面就呈现优美的等角螺线：<br><br>热带低气压的外观也像等角螺线：<br><br>就连旋涡星系的旋臂都像等角螺线：<br></p><p>或许这也是e 被称为“<span style="color:red"><strong>自然常数</strong></span>”的原因吧。当然，自然常数e 的奇妙之处还远不止这些，一本书都写不完。</p><p><strong>Good References:</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/yAZiYYJBUJuesBCTUL_tBg" target="_blank" rel="noopener">自然常数e到底自然在哪？|科研狗</a></li><li><a href="https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/" target="_blank" rel="noopener">An Intuitive Guide To Exponential Functions &amp; e</a></li><li><a href="https://betterexplained.com/articles/prehistoric-calculus-discovering-pi/" target="_blank" rel="noopener">Prehistoric Calculus: Discovering Pi</a></li><li><a href="https://en.wikipedia.org/wiki/Compound_interest" target="_blank" rel="noopener">Compound interest</a></li><li><a href="https://en.wikipedia.org/wiki/Leonhard_Euler" target="_blank" rel="noopener">Leonhard Euler</a></li><li><a href="https://en.wikipedia.org/wiki/Logarithmic_spiral" target="_blank" rel="noopener">Logarithmic spiral</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自然常数$e$是一个奇妙的数字，这里的$e$并不仅仅代表一个字母，它还是一个数学中的无理常数，约等于2.718281828459。&lt;br&gt;但你是否有想过，它到底怎么来的呢？为啥一个无理数却被人们称之为“自然常数”？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="https://fuhailin.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="自然常数" scheme="https://fuhailin.github.io/tags/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何通过反向代理远程访问内网主机</title>
    <link href="https://fuhailin.github.io/How-to-access-intranet-hosts-with-reverse-proxy/"/>
    <id>https://fuhailin.github.io/How-to-access-intranet-hosts-with-reverse-proxy/</id>
    <published>2019-05-07T10:49:23.000Z</published>
    <updated>2019-11-26T02:52:39.216Z</updated>
    
    <content type="html"><![CDATA[<p>首先一定需要一台固定IP的服务器做转发代理，而且保证我们需要连接的目标主机能够通过SSH连接这台主机。原理在这里</p><p><strong>2019年5月7日19:00:39 更新 目前已发现一款优秀的开源反向代理软件<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">FRP</a>，使用体验很稳定，已经基本抛弃ssh进行命令行操作的方式，ssh的方式很不稳定。</strong></p><a id="more"></a><h1 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h1><p>分为Server端配置和Client配置，详见frp readme。</p><h2 id="配合Supervisor守护FRP"><a href="#配合Supervisor守护FRP" class="headerlink" title="配合Supervisor守护FRP"></a>配合Supervisor守护FRP</h2><p>使用Supervisor来做进程的监控，让服务器重启或者FRP down掉之后还能自动重新连接</p><p>安装Supervisor：<code>sudo apt install supervisor</code><br>编辑FRP client的配置文件：<code>vim /etc/supervisord.d/frpc.ini</code>：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[program:frps]</span><br><span class="line">command = ./frp_0.24.1_linux_amd64/frpc -c ./frp_0.24.1_linux_amd64/frpc.ini</span><br><span class="line">autostart = true</span><br></pre></td></tr></tbody></table></figure><br>重启Supervisor后配置生效：<code>sudo service supervisord restart</code><p></p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>主要使用命令如下：</p><h2 id="在目标主机上执行如下命令："><a href="#在目标主机上执行如下命令：" class="headerlink" title="在目标主机上执行如下命令："></a>在目标主机上执行如下命令：</h2><p><code>ssh -fCNR B_port:localhost:22 B_username@B_IP</code><br>其中<code>B_username</code>表示代理服务器的用户名，<code>B_IP</code>表示代理服务器IP地址，<code>B_port</code>表示与目标主机建立直接转发连接的代理服务器端口，这里我使用的是代理服务器1234端口，<strong>某些云主机还需要添加安全规则使B_port能够被外网访问</strong></p><p>测试转发连接是否建立成功：<br><strong>在代理服务器上查看<code>ss -ant</code> ：</strong><br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180729122546729" alt="这里写图片描述"></p><p>在目标主机上查看 <code>ps aux | grep ssh</code> ：<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180729123244214" alt="这里写图片描述"></p><h2 id="在代理服务器上执行如下命令"><a href="#在代理服务器上执行如下命令" class="headerlink" title="在代理服务器上执行如下命令:"></a>在代理服务器上执行如下命令:</h2><p><code>ssh -fCNL *:1235:localhost:1234 localhost</code></p><h2 id="稳定方式"><a href="#稳定方式" class="headerlink" title="稳定方式"></a>稳定方式</h2><p>在目标主机上运行：<code>autossh -M 1235 -NR 1234:localhost:22 ubuntu@193.112.140.**</code>，意思是在中转主机上的端口<code>1235</code>上建立监听，保持连接。</p><p>然后我们在本地就可以通过ssh，经过代理服务器转发来登陆远程内网服务器了：<br><code>ssh -p 1235 A_username@B_IP</code><br>其中A_username是目标主机的用户名</p><p>References:<br><a href="https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html" target="_blank" rel="noopener">https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先一定需要一台固定IP的服务器做转发代理，而且保证我们需要连接的目标主机能够通过SSH连接这台主机。原理在这里&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2019年5月7日19:00:39 更新 目前已发现一款优秀的开源反向代理软件&lt;a href=&quot;https://github.com/fatedier/frp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FRP&lt;/a&gt;，使用体验很稳定，已经基本抛弃ssh进行命令行操作的方式，ssh的方式很不稳定。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://fuhailin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Spark学习笔记之Broadcast Join性能调优</title>
    <link href="https://fuhailin.github.io/Spark-Performance-Tuning-with-Broadcast-Join/"/>
    <id>https://fuhailin.github.io/Spark-Performance-Tuning-with-Broadcast-Join/</id>
    <published>2019-05-07T03:06:40.000Z</published>
    <updated>2019-11-26T02:52:39.216Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      spark-sql或者hive-sql 很多业务场景都会有表关联的的操作，在hive中有map side join优化，对应的在spark-sql中也有map side join。spark中如果在参与join的表中存在小表，可以采用cache broadcast的方式进行优化，避免数据的shuffle，从而一定程度上可以避免数据倾斜，增加spark作业的执行速度。本文主要阐述怎么使用spark sql的map side join进行优化，及使用过程需要注意的内容，同时mark自己研究spark的过程。
    
    </summary>
    
      <category term="大数据" scheme="https://fuhailin.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="https://fuhailin.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Cache() or not Cache() in Spark, 这是一个价值百万的问题</title>
    <link href="https://fuhailin.github.io/Data-Persistence-in-Spark/"/>
    <id>https://fuhailin.github.io/Data-Persistence-in-Spark/</id>
    <published>2019-05-06T08:34:19.000Z</published>
    <updated>2019-11-26T02:52:39.216Z</updated>
    
    <content type="html"><![CDATA[<p>Spark一个重要的功能就是将RDD持久化到内存中。当对RDD进行持久化操作时，每个节点都会将自己操作的RDD的partition持久化到内存中，并在之后对RDD的反复使用中，直接使用内存中缓存的partition。这样的话，对于一个RDD反复执行的操作场景中，就只需要对RDD计算一次即可，而不需要反复计算RDD。巧妙使用RDD持久化,甚至在某种场景下，可以将Spark应用程序性能提升10倍。对于迭代式算法和快速交互应用来说，RDD的持久化是非常必要的。<br><a id="more"></a></p><p>要持久化一个RDD，只需要调用RDD的cache()或者persist()方法即可。在该RDD第一次被计算出来时，就会直接缓存到每个节点中。而且Spark的持久化机制还是自动容错的，如果持久化的RDD的任何partition丢失了，那么Spark会自动通过其源RDD,使用transformation操作重新计算该partition。</p><p>Spark自己在shuffle过程中，会进行数据的持久化，比如写在磁盘中，主要是为了在节点失败时，避免需要重新计算整个过程。</p><h1 id="cache-和presist-的区别"><a href="#cache-和presist-的区别" class="headerlink" title="cache()和presist()的区别"></a>cache()和presist()的区别</h1><p>Spark提供了5中等级的持久化存储级别</p><ul><li>MEMORY_ONLY</li><li>MEMORY_ONLY_SER</li><li>MEMORY_AND_DISK</li><li>MEMORY_AND_DISK_SER</li><li>DISK_ONLY</li></ul><p>cache()和presist()的区别在于，cache()是persist()的一种简化方式，<code>cache()</code>的底层就是调用persist()的无参版本，即调用<code>persist(StorageLevel.MEMORY_ONLY)</code>,将数据持久化到内存中。如果需要从内存中清除缓存，那么可以使用<code>unpersist()</code>方法。</p><div class="table-container"><table><thead><tr><th style="text-align:center">cache()=persist(StorageLevel.MEMORY_ONLY)</th><th style="text-align:center">persist(StorageLevel.MEMORY_AND_DISK)</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/ekNcE.png" alt="MEMORY_ONLY"></td><td style="text-align:center"><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/cjD3K.png" alt="MEMORY_AND_DISK"></td></tr></tbody></table></div><h1 id="什么时候应该持久化RDD或DataFrame？"><a href="#什么时候应该持久化RDD或DataFrame？" class="headerlink" title="什么时候应该持久化RDD或DataFrame？"></a>什么时候应该持久化RDD或DataFrame？</h1><p>在以下情况下，你绝对应该<code>cache()</code>RDD或DataFrame：</p><ul><li>在一个迭代循环中重复使用它们时，一定要cache()（ie. 机器学习算法中）</li><li>在某个应用、任务中，一个RDD或DataFrame复用两次及以上的，一定要cache，避免不必要的重复计算。</li><li>当重新计算生成RDD或DataFrame的成本很高时，请记住cache()（即HDFS，在一组复杂的map()，filter()等之后）如果Worker节点死亡，这有助于恢复过程。</li></ul><p>要记住的是，当Worker节点内存不够用时，Spark将以LRU方式自动从Workers中替换RDD分区，并且这种替换在每个Worker上是独立发生。</p><p><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/DInZf.png" alt=""></p><p><a href="https://stackoverflow.com/questions/26870537/what-is-the-difference-between-cache-and-persist" target="_blank" rel="noopener">What is the difference between cache and persist?</a><br><a href="https://www.jianshu.com/p/0b2ea4cfdc8a" target="_blank" rel="noopener">spark 数据持久化与释放</a><br><a href="https://unraveldata.com/to-cache-or-not-to-cache/" target="_blank" rel="noopener">TO CACHE OR NOT TO CACHE, THAT’S THE MILLION DOLLAR QUESTION</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spark一个重要的功能就是将RDD持久化到内存中。当对RDD进行持久化操作时，每个节点都会将自己操作的RDD的partition持久化到内存中，并在之后对RDD的反复使用中，直接使用内存中缓存的partition。这样的话，对于一个RDD反复执行的操作场景中，就只需要对RDD计算一次即可，而不需要反复计算RDD。巧妙使用RDD持久化,甚至在某种场景下，可以将Spark应用程序性能提升10倍。对于迭代式算法和快速交互应用来说，RDD的持久化是非常必要的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://fuhailin.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="https://fuhailin.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>配置ssh密钥登录与别名登录</title>
    <link href="https://fuhailin.github.io/ssh-login-without-passwd/"/>
    <id>https://fuhailin.github.io/ssh-login-without-passwd/</id>
    <published>2019-05-04T08:33:45.000Z</published>
    <updated>2019-11-26T02:52:39.216Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们在 Termianl 下用 ssh 链接远程主机的时候，每次都需要输入一长串的用户名加主机地址，是不是觉得很麻烦？那么好吧，这个 Tips 也需能帮你解决这一烦恼，让你通过密钥甚至别名快速登录远程主机。<br><a id="more"></a></p><h1 id="通过密钥登录"><a href="#通过密钥登录" class="headerlink" title="通过密钥登录"></a>通过密钥登录</h1><h2 id="查看local有没有公钥"><a href="#查看local有没有公钥" class="headerlink" title="查看local有没有公钥"></a>查看local有没有公钥</h2><p><code>ls ~/.ssh/</code><br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180816111251441" alt="ls ~/.ssh/"></p><p>如果local没有公钥的话需要生成公钥<br><code>ssh-keygen</code>：产生公钥与私钥对<br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-05-04-16-51-01.png" alt="ssh-keygen"></p><h2 id="将公钥上传给主机"><a href="#将公钥上传给主机" class="headerlink" title="将公钥上传给主机"></a>将公钥上传给主机</h2><p><code>ssh-copy-id</code> 将本机的公钥复制到目的机器的authorized_keys文件中<br>使用方式为：<code>ssh-copy-id -i .ssh/id_rsa.pub name@193.112.x.xxx</code><br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/2019-05-04-16-31-52.png" alt="ssh-copy-id"><br>我这里多出来的-oPort=xxxx参数是因为我配置了反向代理，所以需要指定登录端口号。</p><h2 id="登录到远程机器不用输入密码"><a href="#登录到远程机器不用输入密码" class="headerlink" title="登录到远程机器不用输入密码"></a>登录到远程机器不用输入密码</h2><p>直接使用命令：<code>ssh hailin@193.112.x.xxx -oPort=xxxx</code></p><h1 id="配置ssh别名登录"><a href="#配置ssh别名登录" class="headerlink" title="配置ssh别名登录"></a>配置ssh别名登录</h1><p><code>vi ~/.ssh/config</code><br><img src="https://gitee.com/fuhailin/Object-Storage-Service/raw/master/20180809175741834" alt=""><br>登录到远程机器使用简短的别名：<br><code>ssh GPU</code><br><code>ssh cloud</code><br>即可登录！</p><p><a href="https://blog.csdn.net/yanzhibo/article/details/75804619" target="_blank" rel="noopener">https://blog.csdn.net/yanzhibo/article/details/75804619</a><br><a href="https://blog.csdn.net/superbfly/article/details/66970114" target="_blank" rel="noopener">https://blog.csdn.net/superbfly/article/details/66970114</a><br><a href="https://stackoverflow.com/questions/48328446/id-rsa-pub-file-ssh-error-invalid-format" target="_blank" rel="noopener">https://stackoverflow.com/questions/48328446/id-rsa-pub-file-ssh-error-invalid-format</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常我们在 Termianl 下用 ssh 链接远程主机的时候，每次都需要输入一长串的用户名加主机地址，是不是觉得很麻烦？那么好吧，这个 Tips 也需能帮你解决这一烦恼，让你通过密钥甚至别名快速登录远程主机。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://fuhailin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>终端复用神器Tmux</title>
    <link href="https://fuhailin.github.io/Tmux/"/>
    <id>https://fuhailin.github.io/Tmux/</id>
    <published>2019-05-04T03:26:27.000Z</published>
    <updated>2019-11-26T02:52:39.216Z</updated>
    
    <content type="html"><![CDATA[<p>Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机；是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。<br><a id="more"></a><br>1）Tmux功能：</p><ul><li>提供了强劲的、易于使用的命令行界面。</li><li>可横向和纵向分割窗口。</li><li>窗格可以自由移动和调整大小，或直接利用四个预设布局之一。</li><li>支持 UTF-8 编码及 256 色终端。</li><li>可在多个缓冲区进行复制和粘贴。</li><li>可通过交互式菜单来选择窗口、会话及客户端。</li><li>支持跨窗口搜索。</li><li>支持自动及手动锁定窗口。</li></ul><p>2）Tmux安装<br>a）ubuntu版本下直接apt-get安装</p><blockquote><p>sudo apt-get install tmux</p></blockquote><p>b）在Mac OS中安装</p><blockquote><p>brew install tmux</p></blockquote><h1 id="Tmux-快捷键-amp-速查表"><a href="#Tmux-快捷键-amp-速查表" class="headerlink" title="Tmux 快捷键 &amp; 速查表"></a>Tmux 快捷键 &amp; 速查表</h1><p>启动新会话：</p><pre><code>tmux [new -s 会话名 -n 窗口名]</code></pre><p>恢复会话：</p><pre><code>tmux at [-t 会话名]</code></pre><p>列出所有会话：</p><pre><code>tmux ls</code></pre><p><a name="killSessions"></a>关闭会话：</p><pre><code>tmux kill-session -t 会话名orTMUX Prefix (e.g. ctrl+b) + :kill-session</code></pre><p><a name="killAllSessions"></a>关闭所有会话：</p><pre><code>tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill</code></pre><h1 id="在-Tmux-中，按下-Tmux-前缀-ctrl-b，然后："><a href="#在-Tmux-中，按下-Tmux-前缀-ctrl-b，然后：" class="headerlink" title="在 Tmux 中，按下 Tmux 前缀 ctrl+b，然后："></a>在 Tmux 中，按下 Tmux 前缀 <code>ctrl+b</code>，然后：</h1><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><pre><code>:new&lt;回车&gt;  启动新会话s           列出所有会话$           重命名当前会话</code></pre><h2 id="窗口-标签页"><a href="#窗口-标签页" class="headerlink" title="窗口 (标签页)"></a><a name="WindowsTabs"></a>窗口 (标签页)</h2><pre><code>c  创建新窗口w  列出所有窗口n  后一个窗口p  前一个窗口f  查找窗口,  重命名当前窗口&amp;  关闭当前窗口</code></pre><h2 id="调整窗口排序"><a href="#调整窗口排序" class="headerlink" title="调整窗口排序"></a>调整窗口排序</h2><pre><code>swap-window -s 3 -t 1  交换 3 号和 1 号窗口swap-window -t 1       交换当前和 1 号窗口move-window -t 1       移动当前窗口到 1 号</code></pre><h2 id="窗格（分割窗口）"><a href="#窗格（分割窗口）" class="headerlink" title="窗格（分割窗口）"></a><a name="PanesSplits"></a>窗格（分割窗口）</h2><pre><code>%  垂直分割"  水平分割o  交换窗格x  关闭窗格⍽  左边这个符号代表空格键 - 切换布局q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格{ 与上一个窗格交换位置} 与下一个窗格交换位置z 切换窗格最大化/最小化</code></pre><h2 id="同步窗格"><a href="#同步窗格" class="headerlink" title="同步窗格"></a><a name="syncPanes"></a>同步窗格</h2><p>这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setw synchronize-panes</span><br></pre></td></tr></tbody></table></figure><p>你可以指定开或关，否则重复执行命令会在两者间切换。<br>这个选项值针对某个窗口有效，不会影响别的会话和窗口。<br>完事儿之后再次执行命令来关闭。<a href="http://blog.sanctum.geek.nz/sync-tmux-panes/" target="_blank" rel="noopener">帮助</a></p><h2 id="调整窗格尺寸"><a href="#调整窗格尺寸" class="headerlink" title="调整窗格尺寸"></a>调整窗格尺寸</h2><p>如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：</p><pre><code>PREFIX : Alt + ↓          当前窗格向下扩大 1 格PREFIX : Alt + ↑          当前窗格向上扩大 1 格PREFIX : Alt + ←          当前窗格向左扩大 1 格PREFIX : Alt + →          当前窗格向右扩大 1 格PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格</code></pre><h2 id="文本复制模式："><a href="#文本复制模式：" class="headerlink" title="文本复制模式："></a>文本复制模式：</h2><p>按下<strong>前缀 [</strong>进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：</p><pre><code>setw -g mode-keys vi</code></pre><p>启用这条配置后，就可以使用 h、j、k、l 来移动光标了。</p><p>想要退出文本复制模式的话，按下回车键就可以了。一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。</p><p>例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。</p><pre><code>vi             emacs        功能^              M-m          反缩进Escape         C-g          清除选定内容Enter          M-w          复制选定内容j              Down         光标下移h              Left         光标左移l              Right        光标右移L                           光标移到尾行M              M-r          光标移到中间行H              M-R          光标移到首行k              Up           光标上移d              C-u          删除整行D              C-k          删除到行末$              C-e          移到行尾:              g            前往指定行C-d            M-Down       向下滚动半屏C-u            M-Up         向上滚动半屏C-f            Page down    下一页w              M-f          下一个词p              C-y          粘贴C-b            Page up      上一页b              M-b          上一个词q              Escape       退出C-Down or J    C-Down       向下翻C-Up or K      C-Up         向下翻n              n            继续搜索?              C-r          向前搜索/              C-s          向后搜索0              C-a          移到行首Space          C-Space      开始选中               C-t          字符调序</code></pre><h2 id="杂项："><a href="#杂项：" class="headerlink" title="杂项："></a>杂项：</h2><pre><code>d  退出 tmux（tmux 仍在后台运行）t  窗口中央显示一个数字时钟?  列出所有快捷键:  命令提示符</code></pre><h2 id="配置选项："><a href="#配置选项：" class="headerlink" title="配置选项："></a>配置选项：</h2><pre><code># 鼠标支持 - 设置为 on 来启用鼠标* setw -g mode-mouse off* set -g mouse-select-pane off* set -g mouse-resize-pane off* set -g mouse-select-window off# 设置默认终端模式为 256colorset -g default-terminal "screen-256color"# 启用活动警告setw -g monitor-activity onset -g visual-activity on# 居中窗口列表set -g status-justify centre# 最大化/恢复窗格unbind Up bind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmpunbind Downbind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp</code></pre><h2 id="配置文件（-tmux-conf）："><a href="#配置文件（-tmux-conf）：" class="headerlink" title="配置文件（~/.tmux.conf）："></a>配置文件（~/.tmux.conf）：</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础设置</span></span><br><span class="line"><span class="built_in">set</span> -g default-terminal <span class="string">"screen-256color"</span></span><br><span class="line"><span class="built_in">set</span> -g display-time 3000</span><br><span class="line"><span class="built_in">set</span> -g escape-time 0</span><br><span class="line"><span class="built_in">set</span> -g <span class="built_in">history</span>-limit 65535</span><br><span class="line"><span class="built_in">set</span> -g base-index 1</span><br><span class="line"><span class="built_in">set</span> -g pane-base-index 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前缀绑定 (Ctrl+a)</span></span><br><span class="line"><span class="built_in">set</span> -g prefix ^a</span><br><span class="line">unbind ^b</span><br><span class="line"><span class="built_in">bind</span> a send-prefix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割窗口</span></span><br><span class="line">unbind <span class="string">'"'</span></span><br><span class="line"><span class="built_in">bind</span> - splitw -v</span><br><span class="line">unbind %</span><br><span class="line"><span class="built_in">bind</span> | splitw -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选中窗口</span></span><br><span class="line"><span class="built_in">bind</span>-key k select-pane -U</span><br><span class="line"><span class="built_in">bind</span>-key j select-pane -D</span><br><span class="line"><span class="built_in">bind</span>-key h select-pane -L</span><br><span class="line"><span class="built_in">bind</span>-key l select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy-mode 将快捷键设置为 vi 模式</span></span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用鼠标(Tmux v2.1)</span></span><br><span class="line"><span class="built_in">set</span> -g mouse on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新配置文件</span></span><br><span class="line"><span class="built_in">bind</span> r <span class="built_in">source</span>-file ~/.tmux.conf \; display <span class="string">"已更新"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment"># Tmux Plugin Manager(Tmux v2.1)</span></span><br><span class="line"><span class="comment"># Tmux Resurrect</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-resurrect'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of plugins</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tpm'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-sensible'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Other examples:</span></span><br><span class="line"><span class="comment"># set -g @plugin 'github_username/plugin_name'</span></span><br><span class="line"><span class="comment"># set -g @plugin 'git@github.com/user/plugin'</span></span><br><span class="line"><span class="comment"># set -g @plugin 'git@bitbucket.com/user/plugin'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</span></span><br><span class="line">run <span class="string">'~/.tmux/plugins/tpm/tpm'</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br></pre></td></tr></tbody></table></figure><pre><code>Tmux (Local) → Ctrl+bTmux (Local) inside Tmux (ssh) → Ctrl+b+bTmux (Local) inside Tmux (ssh) inside Tmux (other ssh) → Ctrl+b+b+b+b</code></pre><p>References:<br><a href="https://www.cnblogs.com/kevingrace/p/6496899.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/6496899.html</a><br><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7" target="_blank" rel="noopener">https://gist.github.com/ryerh/14b7c24dfd623ef8edc7</a><br><a href="https://blog.fatedier.com/2015/12/18/terminal-multiplexer-tmux/" target="_blank" rel="noopener">终端利器 Tmux</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机；是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://fuhailin.github.io/tags/Linux/"/>
    
      <category term="Tmux" scheme="https://fuhailin.github.io/tags/Tmux/"/>
    
  </entry>
  
</feed>
